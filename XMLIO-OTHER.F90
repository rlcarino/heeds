!======================================================================
!
!    HEEDS (Higher Education Enrollment Decision Support) - A program
!      to create enrollment scenarios for 'next term' in a university
!    Copyright (C) 2012-2014 Ricolindo L. Carino
!
!    This file is part of the HEEDS program.
!
!    HEEDS is free software: you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    (at your option) any later version.
!
!    HEEDS is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU General Public License for more details.
!
!    You should have received a copy of the GNU General Public License
!    along with this program (see the file COPYING.TXT). If not, see
!    <http://www.gnu.org/licenses/>.
!
!    Send inquiries about HEEDS to:
!      Ricolindo L Carino
!      E-mail: Ricolindo.Carino@AcademicForecasts.com
!      Address: 600 Cruise St., Starkville, MS 39759, U.S.A.
!
!======================================================================

    subroutine xml_write_student_grades(std)

        integer, intent (in) :: std

        integer :: idx

        if (isReadOnly) return

        ! generate file name
        idx = year_prefix(Student(std))
        fileName = trim(dirTRANSCRIPTS)//trim(Student(std)%StdNo(1:idx))//DIRSEP//trim(Student(std)%StdNo)//'.XML'
        call move_to_backup(fileName)
        !call html_comment('xml_write_student_grades('//trim(fileName)//')')

        ! write file
        open(unit=unitXML, file=fileName, status='unknown')
        write(unitXML,AFORMAT) XML_DOC

        write(unitXML,AFORMAT) '<'//XML_ROOT_STUDENT_RECORD//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
            FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        StdNo - Student number', &
            '        Name - Student name', &
            '        Curriculum - Curriculum code', &
            '        '//txtGradeType(1)//' - YEAR,TERM,SUBJECT,GRADE', &
            '    </comment>'

        call xml_write_character(unitXML, indent0, 'StdNo', Student(std)%StdNo)
        if (trim(Student(std)%Name)/='(Name)') &
            call xml_write_character(unitXML, indent0, 'Name', Student(std)%Name)
        call xml_write_character(unitXML, indent0, 'Curriculum', Curriculum(Student(std)%CurriculumIdx)%Code)

        do idx=1,lenTCG

            if (TCG(idx)%Code/=3 .or. TCG(idx)%Subject<=0 .or. TCG(idx)%Grade==0) cycle
            if (TCG(idx)%Year==currentYear .and. TCG(idx)%Term==currentTerm) cycle

            call xml_write_character(unitXML, indent0, txtGradeType(1), &
                trim(itoa(TCG(idx)%Year))//COMMA// &
                trim(txtSemester(TCG(idx)%Term))//COMMA// &
                trim(Subject(TCG(idx)%Subject)%Name)//COMMA// &
                txtGrade(pGrade(TCG(idx)%Grade)) )
        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_STUDENT_RECORD//'>'
        close(unitXML)

    end subroutine xml_write_student_grades


    subroutine xml_write_student_advance_credits(std)

        integer, intent (in) :: std

        integer :: idx

        if (isReadOnly) return

        ! generate file name
        idx = year_prefix(Student(std))
        fileName = trim(dirADVANCECREDITS)//trim(Student(std)%StdNo(1:idx))//DIRSEP//trim(Student(std)%StdNo)//'.XML'

        call move_to_backup(fileName)
        call html_comment('xml_write_student_advance_credits('//trim(fileName)//')')

        ! write file
        open(unit=unitXML, file=fileName, status='unknown')
        write(unitXML,AFORMAT) XML_DOC

        write(unitXML,AFORMAT) '<'//XML_ROOT_STUDENT_RECORD//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
            FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        StdNo - Student number', &
            '        Name - Student name', &
            '        '//txtGradeType(0)//' - YEAR,TERM,SUBJECT,GRADE', &
            '    </comment>'

        call xml_write_character(unitXML, indent0, 'StdNo', Student(std)%StdNo)
        if (trim(Student(std)%Name)/='(Name)') &
            call xml_write_character(unitXML, indent0, 'Name', Student(std)%Name)
        call xml_write_character(unitXML, indent0, 'Curriculum', Curriculum(Student(std)%CurriculumIdx)%Code)

        do idx=1,lenTCG
            if (TCG(idx)%Code/=2 .or. TCG(idx)%Grade==0) cycle ! not a ADVANCE/TRANSFER credit
            call xml_write_character(unitXML, indent0, txtGradeType(0), &
                trim(itoa(TCG(idx)%Year))//COMMA// &
                trim(txtSemester(TCG(idx)%Term))//COMMA// &
                trim(Subject(TCG(idx)%Subject)%Name)//COMMA// &
                txtGrade(pGrade(TCG(idx)%Grade)) )
        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_STUDENT_RECORD//'>'
        close(unitXML)

    end subroutine xml_write_student_advance_credits


    subroutine xml_write_student_completions(std)

        integer, intent (in) :: std

        integer :: idx

        if (isReadOnly) return

        ! generate file name
        idx = year_prefix(Student(std))
        fileName = trim(dirCOMPLETIONS)//trim(Student(std)%StdNo(1:idx))//DIRSEP//trim(Student(std)%StdNo)//'.XML'

        call move_to_backup(fileName)
        call html_comment('xml_write_student_completions('//trim(fileName)//')')

        ! write file
        open(unit=unitXML, file=fileName, status='unknown')
        write(unitXML,AFORMAT) XML_DOC

        write(unitXML,AFORMAT) '<'//XML_ROOT_STUDENT_RECORD//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
            FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        StdNo - Student number', &
            '        Name - Student name', &
            '        '//txtGradeType(3)//' - YEAR,TERM,SUBJECT,GRADE', &
            '    </comment>'

        call xml_write_character(unitXML, indent0, 'StdNo', Student(std)%StdNo)
        if (trim(Student(std)%Name)/='(Name)') &
            call xml_write_character(unitXML, indent0, 'Name', Student(std)%Name)
        call xml_write_character(unitXML, indent0, 'Curriculum', Curriculum(Student(std)%CurriculumIdx)%Code)

        do idx=1,lenTCG

            if (TCG(idx)%Code/=5 .or. TCG(idx)%Grade==0) cycle ! not a COMPLETION

            call xml_write_character(unitXML, indent0, txtGradeType(3), &
                trim(itoa(TCG(idx)%Year))//COMMA// &
                trim(txtSemester(TCG(idx)%Term))//COMMA// &
                trim(Subject(TCG(idx)%Subject)%Name)//COMMA// &
                txtGrade(pGrade(TCG(idx)%Grade)) )
        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_STUDENT_RECORD//'>'
        close(unitXML)

    end subroutine xml_write_student_completions


    subroutine xml_write_substitutions(std)
        implicit none
        integer, intent (in) :: std

        integer :: crse_required, idx, k, l
        integer :: rank, Year, Term, idxCURR

        if (isReadOnly) return

        ! generate file name
        idx = year_prefix(Student(std))
        fileName = trim(dirSUBSTITUTIONS)//trim(Student(std)%StdNo(1:idx))//DIRSEP//trim(Student(std)%StdNo)//'.XML'

        call move_to_backup(fileName)
        call html_comment('xml_write_substitutions('//trim(filename)//')')

        ! write file
        open(unit=unitXML, file=fileName, status='unknown')
        write(unitXML,AFORMAT) XML_DOC

        write(unitXML,AFORMAT) '<'//XML_ROOT_SUBSTITUTIONS//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        StdNo - Student number', &
            '        Name - Student name', &
            '        Curriculum - Curriculum code', &
            '        Substitution - REQUIRED SUBJECT(S),REPLACEMENT SUBJECT(S)', &
            '    </comment>'

        idxCURR = Student(std)%CurriculumIdx
        call xml_write_character(unitXML, indent0, 'StdNo', Student(std)%StdNo)

        if (trim(Student(std)%Name)/='(Name)') &
            call xml_write_character(unitXML, indent0, 'Name', Student(std)%Name)

        if (Student(std)%CurriculumIdx/=0) &
            call xml_write_character(unitXML, indent0, 'Curriculum', Curriculum(idxCURR)%Code)

        l = 0 ! how many unspecified subjects?
        do k=1,Curriculum(idxCURR)%NSubjects
            crse_required = Curriculum(idxCURR)%SubjectIdx(k)
            if (crse_required < 0) l = l + 1
        end do

        if (l>0) then
            write(unitXML,AFORMAT) '    <comment>', &
                '        Substitutions for '//trim(Curriculum(idxCURR)%Code)
            do k=1,Curriculum(idxCURR)%NSubjects
                crse_required = Curriculum(idxCURR)%SubjectIdx(k)
                if (crse_required < 0) then
                    rank = Curriculum(idxCURR)%SubjectTerm(k)
                    call rank_to_year_term(rank, Year, Term)
                    write(unitXML, aformat) indentation(:indent1)// &
                        trim(txtYear(Year))//' Year, '// &
                        trim(txtSemester(Term))//' Term: '// &
                        Subject(crse_required)%Name
                end if
            end do
            write(unitXML,AFORMAT) '    </comment>'
        end if

        do idx=1,lenTCG

            if (TCG(idx)%Code/=1 .or. TCG(idx)%Reqd(0)==0) cycle

            call xml_write_character(unitXML, indent0, 'Substitution')
            if (TCG(idx)%Year>0 .and. TCG(idx)%Term>0) then
                ! call rank_to_year_term(TCG(idx)%Year, Year, Term)
                call xml_write_character(unitXML, indent1, 'Year', txtYear(TCG(idx)%Year) )
                call xml_write_character(unitXML, indent1, 'Term', txtSemester(TCG(idx)%Term) )
            end if

            line = SPACE
            do k=1,TCG(idx)%Reqd(0)
                line = COMMA//trim(Subject(TCG(idx)%Reqd(k))%Name)//line
            end do
            call xml_write_character(unitXML, indent1, 'Required', line(2:))

            line = SPACE
            do k=1,TCG(idx)%Subst(0)
                line = COMMA//trim(Subject(TCG(idx)%Subst(k))%Name)//line
            end do
            call xml_write_character(unitXML, indent1, 'Replacement', line(2:))

            call xml_write_character(unitXML, indent0, '/Substitution')

        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_SUBSTITUTIONS//'>'
        close(unitXML)

    end subroutine xml_write_substitutions


    subroutine xml_read_student_grades(std, dirGRADE, errNo)

        integer, intent (in) :: std
        character(len=*), intent (in) :: dirGRADE
        integer, intent (out) :: errNo

        character (len=MAX_LEN_SUBJECT_CODE) :: tSubject
        character (len=MAX_LEN_TEXT_GRADE) :: tGrade
        character (len=MAX_LEN_TEXT_SEMESTER) :: tTerm
        integer :: idx, grdType, gdx, cdx, iYear, iTerm
        logical :: flag

        ! generate file name
        idx = year_prefix(Student(std))
        fileName = trim(dirGRADE)//trim(Student(std)%StdNo(1:idx))//DIRSEP//trim(Student(std)%StdNo)//'.XML'

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_STUDENT_RECORD, fileName, errNo)
        if (errNo/=0) return

        !call html_comment('xml_read_student_grades('//trim(filename)//')')

        ! examine the file line by line
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('StdNo')
                    ! do nothing

                case ('Name')
                    ! do nothing

                case ('Gender')
                    ! do nothing

                case ('Curriculum')
                    ! do nothing

                case ('Country')
                    ! do nothing

                case ('Classification') ! ignore
                    ! do nothing

                case default ! grade

                    grdType = 0
                    do idx=0,3
                        if ( trim(tag)==trim(txtGradeType(idx)) ) then
                            grdType = idx+2
                            exit
                        end if
                    end do
                    if (grdType==0) cycle  !not a grade entry

                    lenTCG = lenTCG + 1
                    TCG(lenTCG)%Code    = grdType

                    TCG(lenTCG)%Used = .false.

                    call index_to_delimiters(COMMA, value, ndels, pos)

                    iYear = atoi(value(1:pos(2)-1)) ! year
                    TCG(lenTCG)%Year    = iYear

                    tTerm = value(pos(2)+1:pos(3)-1)
                    call upper_case(tTerm)
                    iTerm = index_to_term(tTerm) ! term
                    TCG(lenTCG)%Term    = iTerm

                    tGrade = value(pos(4)+1:pos(5)-1)
                    gdx = index_to_grade(tGrade) ! grade
                    TCG(lenTCG)%Grade   = gdx

                    tSubject = value(pos(3)+1:pos(4)-1)
                    cdx = index_to_subject(tSubject) ! subject
                    TCG(lenTCG)%Subject = cdx

                    if (cdx==0 .or. gdx<=0) then ! discard
                        lenTCG = lenTCG - 1
                        call html_comment('Invalid subject and/or grade in '//trim(line) )
                        cycle
                    end if

                    ! discard grades for current (or future) subjects in the record
                    if (grdType==3) then ! FINALGRADE
                        if (iYear>currentYear .or. &
                            (iYear==cTm1Year .and. iTerm==cTm1) .or. & ! previous term
                            (iYear==currentYear .and. iTerm>=currentTerm) ) then ! discard
                            lenTCG = lenTCG - 1
                            !call html_comment('Year-term is current or future in '//trim(line) )
                            cycle
                        end if
                    end if

                    if (tSubject(1:3)/='PE ') then
                    ! check for duplicates (same subject-grade) in case checklists were regenerated
                    ! without deleting the older versions
                    ! or same year-term-subject
                        flag = .false.
                        do idx=1,lenTCG-1
                            if ( TCG(idx)%Subject/=cdx ) cycle
                            ! proposed replacement logic
                            if (TCG(idx)%Year==iYear .and. TCG(idx)%Term==iTerm) then
                                if (TCG(idx)%Grade==gdx) then ! same grade
                                elseif (is_grade_passing(gdx) .and. is_grade_passing(TCG(idx)%Grade)) then ! both passing, no change
                                elseif (is_grade_passing(TCG(idx)%Grade) ) then ! already passing
                                else ! use passing
                                  TCG(idx)%Grade = gdx
                                end if
                                flag = .true.
                                exit
                            end if
                            !if ( TCG(idx)%Grade==gdx .or. &
                            !    (TCG(idx)%Year==iYear .and. TCG(idx)%Term==iTerm) ) then
                            !    flag = .true.
                            !    exit
                            !end if
                        end do
                        if (flag) then ! discard
                            lenTCG = lenTCG - 1
                            !call html_comment('Duplicate entry '//trim(line) )
                            cycle
                        end if
                    end if

            end select

        end do
        close(unitXML)

    end subroutine xml_read_student_grades


    subroutine xml_read_substitutions(std, errNo)

        integer, intent (in) :: std
        integer, intent (out) :: errNo

        character (len=MAX_LEN_TEXT_SEMESTER) :: tTerm
        character (len=MAX_LEN_TEXT_YEAR) :: tYear
        integer :: idx

        ! generate file name
        idx = year_prefix(Student(std))
        fileName = trim(dirSUBSTITUTIONS)//trim(Student(std)%StdNo(1:idx))//DIRSEP//trim(Student(std)%StdNo)//'.XML'

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_SUBSTITUTIONS, fileName, errNo)
        if (errNo/=0) return

        !call html_comment('xml_read_substitutions('//trim(filename)//')')

        ! examine the file line by line
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('Substitution')
                    call check_array_bound (lenTCG+1, MAX_LEN_STUDENT_RECORD, &
                        'MAX_LEN_STUDENT_RECORD @ '//fileName)

                case ('Year') ! value is one of FIRST, SECOND, THIRD, FOURTH, ...
                    tYear = adjustl(value)
                    TCG(lenTCG+1)%Year = index_to_year(tYear)

                case ('Term') ! value is one of FIRST, SECOND, SUMMER
                    tTerm = adjustl(value)
                    TCG(lenTCG+1)%Term = index_to_term(tTerm)

                case ('Required') ! value is comma-separated list of subjects
                    call tokenize_subjects(value, ',', 5, &
                        TCG(lenTCG+1)%Reqd(0), TCG(lenTCG+1)%Reqd(1:), eof)

                case ('Replacement') ! value is comma-separated list of subjects
                    call tokenize_subjects(value, ',', 5, &
                        TCG(lenTCG+1)%Subst(0), TCG(lenTCG+1)%Subst(1:), eof)

                case ('/Substitution')

                    if (TCG(lenTCG+1)%Reqd(0)*TCG(lenTCG+1)%Subst(0)>0) then
                        lenTCG = lenTCG+1
                        TCG(lenTCG)%Code = 1
                        TCG(lenTCG)%Used = .false.
                    else
                        call html_comment('Invalid substitution entry in '//trim(filename))
                    end if

                case default

            end select

        end do
        close(unitXML)

    end subroutine xml_read_substitutions


    subroutine read_student_records (std)
        integer, intent (in) :: std

        integer :: ierr, i, j, k, crse, grd

        ! student info
        call xml_read_student_info(std, ierr)

        ! record
        TCG = TYPE_STUDENT_RECORD (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.0, .false., SPACE, SPACE)
        lenTCG = 0

#if defined REGIST
        ! retrieve record of substitutions
        call custom_read_substitutions(std)
        ! retrieve record of grades
        call custom_read_student_grades(std)
#else
        ! retrieve record of substitutions
        call xml_read_substitutions(std, ierr)
        ! retrieve record of advanced/transfer credits
        call xml_read_student_grades(std, dirADVANCECREDITS, ierr)
        ! retrieve record of grades per semester
        call xml_read_student_grades(std, dirTRANSCRIPTS, ierr)
        ! retrieve record of completions
        call xml_read_student_grades(std, dirCOMPLETIONS, ierr)
#endif

        ! add subjects previous term
        !call html_comment('Previous term: '//txtSemester(cTm1))
        !call html_comment('# subjects='//itoa(Enlistment(cTm1,std)%NPriority+Enlistment(cTm1,std)%NAlternates+ &
        !    Enlistment(cTm1,std)%NCurrent) )

        do i=1,Enlistment(cTm1,std)%NPriority+Enlistment(cTm1,std)%NAlternates+Enlistment(cTm1,std)%NCurrent

            grd = Enlistment(cTm1,std)%Grade(i)
            if (grd==0) cycle
            crse = Enlistment(cTm1,std)%Subject(i)
            !call html_comment(itoa(i)//Subject(crse)%Name//txtGrade(pGrade(grd)) )

            ! update if already included
            k = 0
            do j=1,lenTCG
                if ( TCG(j)%Subject/=crse ) cycle
                if ( TCG(j)%Year==cTm1Year .and. TCG(j)%Term==cTm1) then
                    k = j
                    exit
                end if
            end do
            if (k==0) then ! not found; add
                k = lenTCG+1
                lenTCG = k
                !call html_comment('Enlisted previous term: '//itoa(lenTCG)//Subject(crse)%Name//txtGrade(pGrade(grd)) )
            end if

            TCG(k)%Code    = 3           ! FINALGRADE
            TCG(k)%Used    = .false.

            TCG(k)%Year    = cTm1Year ! year
            TCG(k)%Term    = cTm1 ! term
            TCG(k)%Subject = crse
            TCG(k)%Grade   = grd

!            ! convert REGD to PASS during enlistment
!            if (isPeriodOne .and. grd==gdxREGD) then
!                TCG(k)%Grade = gdxPASS
!                call html_comment('Converted to '//txtGrade(pGrade(gdxPASS)) )
!            end if

        end do

        ! add enlisted subjects
        if (.not. isPeriodOne) then
            do i=1,Enlistment(currentTerm,std)%NPriority+Enlistment(currentTerm,std)%NAlternates+ &
                Enlistment(currentTerm,std)%NCurrent

                grd = Enlistment(currentTerm,std)%Grade(i)
                if (grd==0) cycle
                crse = Enlistment(currentTerm,std)%Subject(i)

                ! update if already included
                k = 0
                do j=1,lenTCG
                    if ( TCG(j)%Subject/=crse ) cycle
                    if ( TCG(j)%Year==currentYear .and. TCG(j)%Term==currentTerm) then
                        k = j
                        exit
                    end if
                end do
                if (k==0) then ! not found
                    k = lenTCG+1
                    lenTCG = k
                    !call html_comment('Enlisted current term: '//itoa(lenTCG)//Subject(crse)%Name//txtGrade(pGrade(grd)) )
                end if

                TCG(k)%Code    = 3           ! FINALGRADE
                TCG(k)%Used    = .false.

                TCG(k)%Year    = currentYear ! year
                TCG(k)%Term    = currentTerm ! term
                TCG(k)%Subject = crse
                TCG(k)%Grade   = grd

            end do
        end if

        ! match INCs with completion grades
        do i=1,lenTCG
            if (TCG(i)%Grade/=gdxINC .and. TCG(i)%Grade/=gdxNFE) cycle ! not INC/NFE
            ! find completion, if any
            crse = TCG(i)%Subject
            k = 0
            do j=1,lenTCG
                if ( TCG(j)%Code/=5) cycle ! not completion
                if ( TCG(j)%Subject/=crse ) cycle ! not the subject
                k = j
            end do
            if (k==0) cycle ! not found
            TCG(i)%ReExam = TCG(k)%Grade
            TCG(k)%Used = .true.
        end do

        ! compute when grades were received relative to baseYear
        do i=1,lenTCG
            if (TCG(i)%Code<2) cycle
            if (TCG(i)%Year==0 .or. TCG(i)%Term==-1) then
                TCG(i)%Year = baseYear
                TCG(i)%Term = 0
            end if
            TCG(i)%Taken = 3*(TCG(i)%Year - BaseYear + 1) + TCG(i)%Term
        end do

        ! sort TCG; place 0-credit subjects last in each semester
        k = lenTCG + 1
        do i=1,lenTCG-1
            if (TCG(i)%Code<2) cycle
            do j=i+1,lenTCG
                if (TCG(j)%Code<2) cycle
                if (TCG(j)%Taken<TCG(i)%Taken) then
                    TCG(k) = TCG(i)
                    TCG(i) = TCG(j)
                    TCG(j) = TCG(k)
                else if (TCG(j)%Taken==TCG(i)%Taken) then
                    if (Subject(TCG(j)%Subject)%Units>Subject(TCG(i)%Subject)%Units) then
                        TCG(k) = TCG(i)
                        TCG(i) = TCG(j)
                        TCG(j) = TCG(k)
                    end if
                end if
            end do
        end do
        TCG(k) = TCG(k+1)

    end subroutine read_student_records


    subroutine xml_student_info(std, wrkStudent)

        integer, intent (in) :: std
        type (TYPE_STUDENT), intent(in), optional :: wrkStudent

        integer :: idx

        if (isReadOnly) return

        ! generate file name
        if (present(wrkStudent)) then
            idx = year_prefix(wrkStudent)
            fileName = trim(dirSTUDENTINFO)//trim(wrkStudent%StdNo(1:idx))//DIRSEP//trim(wrkStudent%StdNo)//'.XML'
            call student_copy_to_info(wrkStudent)
        else
            idx = year_prefix(Student(std))
            fileName = trim(dirSTUDENTINFO)//trim(Student(std)%StdNo(1:idx))//DIRSEP//trim(Student(std)%StdNo)//'.XML'
        end if

        ! write file
        open(unit=unitXML, file=fileName)
        write(unitXML,AFORMAT) XML_DOC

        !call html_comment('xml_student_info('//trim(filename)//')')

        write(unitXML,AFORMAT) '<'//XML_ROOT_STUDENT_INFO//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        Name - Student name', &
            '        Gender - M=male, F=female', &
            '        Curriculum - Curriculum code', &
            '        Adviser - TeacherId of adviser', &
            '        Country - Country index; 1=Philippines', &
            '        Classification - Year level', &
            '        BirthDate - Birth date', &
            '        BirthPlace - Birth place', &
            '        HomeAddress - Home address', &
            '        EntryDate - Entry date', &
            '        GraduationDate - Graduation date', &
            '        TranscriptRemark - Remark on transcript', &
            '        LastAttended - Last school attended', &
            '        AdmissionData - Admission data', &
            '        Scholarship - Scholarship code', &
            '    </comment>'

        call xml_write_character(unitXML, indent0, 'Name', StudentInfo%Name)

        call xml_write_character(unitXML, indent0, 'Gender', StudentInfo%Gender)

        call xml_write_character(unitXML, indent0, 'Curriculum', Curriculum(StudentInfo%CurriculumIdx)%Code)

        if (len_trim(StudentInfo%Adviser)/=0) &
            call xml_write_character(unitXML, indent0, 'Adviser', StudentInfo%Adviser)

        if (StudentInfo%CountryIdx/=1) &
            call xml_write_integer(unitXML,   indent0, 'Country', StudentInfo%CountryIdx)

        if (StudentInfo%Classification/=0) &
            call xml_write_integer(unitXML,   indent0, 'Classification', StudentInfo%Classification)

        if (len_trim(StudentInfo%BirthDate)/=0) &
            call xml_write_character(unitXML, indent0, 'BirthDate', StudentInfo%BirthDate)

        if (len_trim(StudentInfo%EntryDate)/=0) &
            call xml_write_character(unitXML, indent0, 'EntryDate', StudentInfo%EntryDate)

        if (len_trim(StudentInfo%GraduationDate)/=0) &
            call xml_write_character(unitXML, indent0, 'GraduationDate', StudentInfo%GraduationDate)

        if (len_trim(StudentInfo%BirthPlace)/=0) &
            call xml_write_character(unitXML, indent0, 'BirthPlace', StudentInfo%BirthPlace)

        if (len_trim(StudentInfo%HomeAddress)/=0) &
            call xml_write_character(unitXML, indent0, 'HomeAddress', StudentInfo%HomeAddress)

        if (len_trim(StudentInfo%LastAttended)/=0) &
            call xml_write_character(unitXML, indent0, 'LastAttended', StudentInfo%LastAttended)

        if (len_trim(StudentInfo%TranscriptRemark)/=0) &
            call xml_write_character(unitXML, indent0, 'TranscriptRemark', StudentInfo%TranscriptRemark)

        if (len_trim(StudentInfo%AdmissionData)/=0) &
            call xml_write_character(unitXML, indent0, 'AdmissionData', StudentInfo%AdmissionData)

        if (len_trim(StudentInfo%Scholarship)/=0) &
            call xml_write_character(unitXML, indent0, 'Scholarship', StudentInfo%Scholarship)

        write(unitXML,AFORMAT) '</'//XML_ROOT_STUDENT_INFO//'>'
        close(unitXML)

    end subroutine xml_student_info


    subroutine xml_read_student_info(std, errNo)

        integer, intent (in) :: std
        integer, intent (out) :: errNo

        integer :: idx, idxCURR
        character(len=MAX_LEN_CURRICULUM_CODE) :: tCurriculum

        call initialize_student_info()

        ! generate file name
        idx = year_prefix(Student(std))
        fileName = trim(dirSTUDENTINFO)//trim(Student(std)%StdNo(1:idx))//DIRSEP//trim(Student(std)%StdNo)//'.XML'

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_STUDENT_INFO, fileName, errNo)
        if (errNo/=0) return

        !call html_comment('xml_read_student_info('//trim(filename)//')')

        ! examine the file line by line
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            value = adjustl(value)
            select case (trim(tag))

                case ('Name')
                    call upper_case(value)
                    StudentInfo%Name = value

                case ('Gender')
                    StudentInfo%Gender = value

                case ('Curriculum')
                    tCurriculum = value
                    idxCurr = index_to_curriculum(tCurriculum)
                    if (idxCurr<0) then
                        idxCurr = -idxCurr
                    else if (idxCurr==0) then
                        idxCurr = NumCurricula
                    end if
                    StudentInfo%CurriculumIdx = idxCurr

                case ('Adviser')
                    StudentInfo%Adviser = value

                case ('Country')
                    StudentInfo%CountryIdx = atoi(value)

                case ('Classification')
                    StudentInfo%Classification = atoi(value)

                case ('BirthDate')
                    StudentInfo%BirthDate = value

                case ('EntryDate')
                    StudentInfo%EntryDate = value

                case ('GraduationDate')
                    StudentInfo%GraduationDate = value

                case ('BirthPlace')
                    StudentInfo%BirthPlace = value

                case ('HomeAddress')
                    StudentInfo%HomeAddress = value

                case ('LastAttended')
                    StudentInfo%LastAttended = value

                case ('AdmissionData')
                    StudentInfo%AdmissionData = value

                case ('Scholarship')
                    StudentInfo%Scholarship = value

                case ('TranscriptRemark')
                    StudentInfo%TranscriptRemark = value

                case default
                    ! do nothing

            end select

        end do
        close(unitXML)

    end subroutine xml_read_student_info


    subroutine get_subject_areas()

        character (len=MAX_LEN_SUBJECT_CODE) :: token
        integer :: i, j, k

        NumSubjectAreas = 0
        SubjectArea = TYPE_SUBJECT_AREA (SPACE, 0, 0)
        do i=1,NumSubjects+NumAdditionalSubjects
            token = get_area(Subject(i)%Name)
            ! find token if it already exists
            k = 0
            do j=NumSubjectAreas,1,-1
                if (SubjectArea(j)%Code/=token) cycle
                k = j
                exit
            end do
            if (k==0) then ! not found
                call check_array_bound (NumSubjectAreas+1, MAX_ALL_SUBJECTS/3, 'NumSubjectAreas')
                NumSubjectAreas = NumSubjectAreas+1
                SubjectArea(NumSubjectAreas) = TYPE_SUBJECT_AREA(token, Department(Subject(i)%DeptIdx)%CollegeIdx, 1)
            else
                SubjectArea(k)%Count = SubjectArea(k)%Count + 1
            end if
        end do
    end subroutine get_subject_areas


    subroutine make_student_directories()

        integer :: iTmp, jTmp

        ! create student directories
        dirSUBSTITUTIONS    = trim(dirDATA)//'substitutions'//DIRSEP ! directory for input/UNEDITED checklists from Registrar
        dirTRANSCRIPTS      = trim(dirDATA)//'transcripts'//DIRSEP ! directory for raw transcripts
        dirADVANCECREDITS   = trim(dirDATA)//'advancecredits'//DIRSEP ! directory for advance/transfer credit records
        dirCOMPLETIONS      = trim(dirDATA)//'completions'//DIRSEP ! directory for completion records
        dirSTUDENTINFO      = trim(dirDATA)//'info'//DIRSEP ! directory for individual student info

        call make_directory( dirTRANSCRIPTS )
        call make_directory( dirSUBSTITUTIONS )
        call make_directory( dirADVANCECREDITS )
        call make_directory( dirCOMPLETIONS )
        call make_directory( dirSTUDENTINFO )

        call make_directory( trim(dirBACKUP)//'transcripts' )
        call make_directory( trim(dirBACKUP)//'substitutions' )
        call make_directory( trim(dirBACKUP)//'advancecredits' )
        call make_directory( trim(dirBACKUP)//'completions' )
        call make_directory( trim(dirBACKUP)//'info' )

        call collect_prefix_years()
        iTmp = 1
        do jTmp=2,len_trim(StdNoPrefix)
            if (StdNoPrefix(jTmp:jTmp)/=':') cycle

            call make_directory( trim(dirTRANSCRIPTS)//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirSUBSTITUTIONS)//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirADVANCECREDITS)//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirCOMPLETIONS)//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirSTUDENTINFO)//StdNoPrefix(iTmp+1:jTmp-1) )

            call make_directory( trim(dirBACKUP)//'transcripts'//DIRSEP//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirBACKUP)//'substitutions'//DIRSEP//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirBACKUP)//'advancecredits'//DIRSEP//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirBACKUP)//'completions'//DIRSEP//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirBACKUP)//'info'//DIRSEP//StdNoPrefix(iTmp+1:jTmp-1) )

            call make_directory( trim(dirLOG)//StdNoPrefix(iTmp+1:jTmp-1) )

            iTmp = jTmp
        end do

    end subroutine make_student_directories


    subroutine write_classes_blocks_csv (device, Term, NumSections, Section, NumBlocks, Block )

        integer, intent (in) :: device, Term, NumSections, NumBlocks
        type (TYPE_SECTION), intent(in) :: Section(0:)
        type (TYPE_BLOCK), intent(in) :: Block(0:)

        integer :: i, blk, sect, subj, mdx

        write(device,AFORMAT) &
            '#', &
            '#  Schedule of Classes for '//txtSemester(Term)//termQualifier(Term), &
            '#', &
            '# Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '#', &
            '# Columns are : ', &
            '#   Subject - subject code', &
            '#   Section - section code, to differentiate section for the same subject', &
            '#   GradesIn - Date grades submitted', &
            '#   Owner - responsible department', &
            '#   Seats - class capacity', &
            '#   Time - begin time - end time of meeting', &
            '#   Day - days of meetings', &
            '#   Room - code for meeting room', &
            '#   Teacher - code for teacher of meeting', &
            '#', '#', &
            '"Subject","Section","GradesIn","Owner","Seats","Time","Day","Room","Teacher"'

        do sect=1,NumSections
            subj = Section(sect)%SubjectIdx
            if (subj==0) cycle
            !write(*,*) Section(sect)%ClassId, Section(sect)%SubjectIdx

            line = SPACE
            if (is_regular_schedule(sect, Section)) then

                line = COMMA//'"'//trim(Teacher(Section(sect)%TeacherIdx(1))%TeacherId)//'"'//line
                line = COMMA//'"'//trim(Room(Section(sect)%RoomIdx(1))%Code)//'"'//line
                line = COMMA//'"'//trim(text_days_of_section(Section(sect)))//'"'//line
                line = COMMA//'"'//trim(text_time_period(Section(sect)%bTimeIdx(1), Section(sect)%eTimeIdx(1)))//'"'//line

            else ! class is "irregular": one entry for each meeting

                do mdx=Section(sect)%NMeets,1,-1
                    line = COMMA//'"'//trim(Teacher(Section(sect)%TeacherIdx(mdx))%TeacherId)//'"'//line
                    line = COMMA//'"'//trim(Room(Section(sect)%RoomIdx(mdx))%Code)//'"'//line
                    line = COMMA//'"'//trim(txtDay(Section(sect)%DayIdx(mdx)))//'"'//line
                    line = COMMA//'"'//trim(text_time_period(Section(sect)%bTimeIdx(mdx), Section(sect)%eTimeIdx(mdx)))//'"'//line
                end do

            end if

            line = COMMA//'"'//trim(itoa(Section(sect)%Slots))//'"'//line
            line = COMMA//'"'//trim(Department(Section(sect)%DeptIdx)%Code)//'"'//line
            line = COMMA//'"'//trim(Section(sect)%GradeSubmissionDate)//'"'//line
            line = COMMA//'"'//trim(Section(sect)%Code)//'"'//line
            line = '"'//trim(Subject(subj)%Name)//'"'//line

            write(device,AFORMAT) trim(line)

        end do


        write(device,AFORMAT) &
            SPACE, '#', &
            '#  Blocks for '//txtSemester(Term)//termQualifier(Term), &
            '#', &
            '# Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '#', &
            '# Columns are : ', &
            '#   Code - Block identifier', &
            '#   Curriculum - Curricular program for block', &
            '#   Description - Block description', &
            '#   Year - Year level in curriculum', &
            '#   Term - Term of the year in curriculum', &
            '#   Owner - Department that created (thus, can modify) block', &
            '#   Subject - Subject code', &
            '#   Section - Section code, if any', &
            '#', '#', &
            '"Code","Curriculum","Description","Year","Term","Owner","Subject",Section"'

        ! loop over blocks
        do blk=1,NumBlocks

            ! any classes assigned to this block?
            if (Block(blk)%NumClasses==0) cycle

            line = SPACE

            ! classes assigned to block
            do i=Block(blk)%NumClasses,1,-1
                sect = Block(blk)%Section(i)
                if (sect==0) then
                    line = COMMA//'"NONE"'//line
                else
                    line = COMMA//'"'//trim(Section(sect)%Code)//'"'//line
                end if
                line = COMMA//'"'//trim(Subject(Block(blk)%Subject(i))%Name)//'"'//line
            end do
            line = COMMA//'"'//trim(Department(Block(blk)%DeptIdx)%Code)//'"'//line
            line = COMMA//'"'//trim(txtSemester(Block(blk)%Term))//'"'//line
            line = COMMA//'"'//trim(txtYear(Block(blk)%Year))//'"'//line
            line = COMMA//'"'//trim(Block(blk)%Name)//'"'//line
            line = COMMA//'"'//trim(Curriculum(Block(blk)%CurriculumIdx)%Code)//'"'//line
            line = '"'//trim(Block(blk)%BlockID)//'"'//line

            write(device,AFORMAT) trim(line)
        end do

    end subroutine write_classes_blocks_csv


    subroutine write_enlistment_csv(device, Term, eList, Section)

        integer, intent (in) :: device, Term
        type (TYPE_PRE_ENLISTMENT), intent(in) :: eList(0:)
        type (TYPE_SECTION), intent(in) :: Section(0:)

        integer :: i, sect, std, lenRecord

        write(device,AFORMAT) &
            '#', &
            '#  Enlistment for '//txtSemester(Term)//termQualifier(Term), &
            '#', &
            '# Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '#', '#', &
            '"StdNo","Name","Curriculum","Subject","Section","Grade"'

        do std=1,NumStudents+NumAdditionalStudents
            ! skip student with no record
            lenRecord = max(eList(std)%lenSubject, eList(std)%NPriority+eList(std)%NAlternates+eList(std)%NCurrent)
            if (lenRecord==0) cycle

            line = SPACE
            do i=lenRecord,1,-1
                sect = eList(std)%Section(i)
                if (sect==0) cycle
                line = COMMA//'"'//trim(Subject(Section(sect)%SubjectIdx)%Name)//'","'// &
                    & trim(Section(sect)%Code)//'","'//trim(txtGrade(pGrade(eList(std)%Grade(i))))//'"'//line
            end do

            line = COMMA//'"'//trim(Curriculum(Student(std)%CurriculumIdx)%Code)//'"'//line
            line = COMMA//'"'//trim(Student(std)%Name)//'"'//line
            line = '"'//trim(Student(std)%StdNo)//'"'//line

            write(device,AFORMAT) trim(line)
        end do

    end subroutine write_enlistment_csv


    subroutine log_record_change(fName, mesg)

        character (len=*), intent (in) :: fName, mesg

        logical :: logExists

        if (isReadOnly) return

        inquire(file=fName, exist=logExists)
        if (.not. logExists) then
            open(unit=unitUSER, file=fName, status='new')
        else
            open(unit=unitUSER, file=fName, status='old', position='append')
        end if
        write(unitUSER,AFORMAT) SPACE, 'RECORD CHANGE BY: '// &
            trim(USERNAME)//' : '//REMOTE_ADDR//' : '//currentDate//DASH//currentTime, trim(mesg)
        close(unitUSER)

    end subroutine log_record_change


    subroutine log_student_record_change(std, mesg)

        integer, intent (in) :: std
        character (len=*), intent (in) :: mesg

        integer :: idx

        idx = year_prefix(Student(std))
        fileName = trim(dirLOG)//trim(Student(std)%StdNo(1:idx))//DIRSEP//trim(Student(std)%StdNo)//'.log'
        call log_record_change(fileName, mesg)

    end subroutine log_student_record_change


    subroutine log_teacher_record_change(fac, mesg)

        integer, intent (in) :: fac
        character (len=*), intent (in) :: mesg

        fileName = trim(dirLOG)//trim(College(Department(Teacher(fac)%DeptIdx)%CollegeIdx)%Code)//DIRSEP// &
            trim(Teacher(fac)%TeacherId)//'.log'
        call log_record_change(fileName, mesg)

    end subroutine log_teacher_record_change


    subroutine xml_write_transcripts(idxYear, idxTerm)

        integer, intent (in) :: idxYear, idxTerm
        logical :: pathExists

        integer :: idx, std

        ! create student directories
        call make_student_directories()
        do std=1,NumStudents+NumAdditionalStudents

            ! generate file name
            idx = year_prefix(Student(std))
            fileName = trim(dirTRANSCRIPTS)//trim(Student(std)%StdNo(1:idx))//DIRSEP// &
                trim(Student(std)%StdNo)//'.XML'

            inquire(file=trim(fileName), exist=pathExists)
            if (.not. pathExists) then
                open(unit=unitXML, file=trim(fileName), status='new')

                write(unitXML,AFORMAT) XML_DOC, &
                    '<'//XML_ROOT_STUDENT_RECORD//'>', &
                    '    <comment>', &
                    '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                    FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
                    '        StdNo - Student number', &
                    '        Name - Student name', &
                    '        Grade - YEAR,TERM,SUBJECT,GRADE', &
                    '    </comment>'

                call xml_write_character(unitXML, indent0, 'StdNo', Student(std)%StdNo)
                call xml_write_character(unitXML, indent0, 'Name', Student(std)%Name)

            else
                open(unit=unitXML, file=trim(fileName), status='old', position='append')
                backspace(unitXML)
            end if

            do idx=1,Enlistment(idxTerm,std)%lenSubject
                call xml_write_character(unitXML, indent0, txtGradeType(1), &
                    trim(itoa(idxYear))//COMMA// &
                    trim(txtSemester(idxTerm))//COMMA// &
                    trim(Subject(Enlistment(idxTerm,std)%Subject(idx))%Name)//COMMA// &
                    txtGrade(pGrade(Enlistment(idxTerm,std)%Grade(idx))) )
            end do

            write(unitXML,AFORMAT) '</'//XML_ROOT_STUDENT_RECORD//'>'
            close(unitXML)

            if (mod(std,1000)==0) write(*,*) std,  '/', NumStudents, ' done...'
        end do

    end subroutine xml_write_transcripts


#if defined REGIST

    subroutine custom_read_student_grades (std, DoNotRename)
        integer, intent (in) :: std
        logical, optional, intent (in) :: DoNotRename
        character (len=MAX_LEN_TEXT_YEAR) :: tYear
        character (len=MAX_LEN_TEXT_SEMESTER) :: tTerm
        !type (TYPE_CURRICULUM) :: tCheckList
        character (len=MAX_LEN_SUBJECT_CODE) :: tSubject, token
        character (len=MAX_LEN_CURRICULUM_CODE) :: stdCurriculum
        character (len=10) :: tSection
        character (len=4) :: tGrade!, tUnits
        integer :: idxCURR
        integer :: i, j, k, cdx, eof, gdx, tdx
        logical :: fileOK

        idxCURR = Student(std)%CurriculumIdx
        StdNoYearLen = year_prefix(Student(std))
        fileTCG = trim(dirTRANSCRIPTS)//trim(Student(std)%StdNo(1:StdNoYearLen))//DIRSEP//Student(std)%StdNo

        inquire (file=fileTCG, exist=fileOK)
        if (fileOK) then
            open(200, file=fileTCG, form='formatted', status='old')

            ! first line will indicate updated student info
            read (200, AFORMAT, iostat = eof) line
            call index_to_delimiters(COMMA, line, ndels, pos)
            stdCurriculum = line(pos(5)+1:pos(6)-1)
            idxCURR = index_to_curriculum(stdCurriculum)
            if (stdCurriculum==SPACE .or. idxCURR==0) then ! first line does not contain student info
                if (line(1:5)=='Grade') then
                    lenTCG = lenTCG + 1
                    call check_array_bound (lenTCG, MAX_LEN_STUDENT_RECORD, 'MAX_LEN_STUDENT_RECORD @ '//fileTCG)
                    TCG(lenTCG)%txtLine = line
                    TCG(lenTCG)%Code = 0
                end if
            else if (idxCURR<=0) then
                idxCURR = -idxCURR
            end if
            if (idxCURR>0 .and. idxCURR/=Student(std)%CurriculumIdx) then
                Student(std)%CurriculumIdx = idxCURR
                isDirtySTUDENTS = .true.
                write (unitLOG,AFORMAT) 'UPDATE: '//trim(line)
            else ! revert
                idxCURR = Student(std)%CurriculumIdx
            end if
            do
                read (200, AFORMAT, iostat = eof) line
                if (eof<0) exit
                if (line(1:5)=='Grade') then
                    lenTCG = lenTCG + 1
                    call check_array_bound (lenTCG, MAX_LEN_STUDENT_RECORD, 'MAX_LEN_STUDENT_RECORD @ '//fileTCG)
                    TCG(lenTCG)%txtLine = line
                end if
            end do
            close(200)

        end if

        ! parse TCG; assume initial good academic standing
        !tCheckList = Curriculum(idxCURR)
        loop_tcg: &
        do tdx=1,lenTCG
            line = TCG(tdx)%txtLine
            TCG(tdx)%Used = .false.

            i = index(line, '0A')
            if (i>0) then
                line(i+1:i+1) = 'a'
                TCG(tdx)%txtLine(i+1:i+1) = 'a'
            end if

            !write(*,*) trim(line)

            if (line(1:5)=='Grade') then
                TCG(tdx)%Code = 3 ! assume FINALGRADE
                call index_to_delimiters(COMMA, line, ndels, pos)
                !Grade,Year,Term,Subject,Section,Units,Grade
                ! 1   2    3    4      5       6     7
                if (ndels<7) then
                    TCG(tdx)%ErrorCode = 5
                    TCG(tdx)%errLine = ' ERROR : '
                    TCG(tdx)%errLine(pos(ndels+1):) = ' ^ missing token(s)'
                    !write(*,AFORMAT) trim(TCG(tdx)%txtLine), trim(TCG(tdx)%errLine)
                    cycle loop_tcg
                end if
                tSection = adjustl(line(pos(5)+1:pos(6)-1))
                !tUnits = adjustl(line(pos(6)+1:pos(7)-1))
                tGrade  = adjustl(line(pos(7)+1:pos(8)-1))
                tYear = adjustl(line(pos(2)+1:pos(3)-1))
                tTerm = adjustl(line(pos(3)+1:pos(4)-1))
                tSubject = adjustl(line(pos(4)+1:pos(5)-1))

                !write(*,*) tYear, tTerm, tSubject, tSection, tUnits, tGrade
                gdx = index_to_grade(tGrade)
                !! exclude REGD subjects (i.e. "current")?
                !if (gdx<0 .or. (gdx==gdxREGD .and. excludeREGD)) then
                !  TCG(tdx)%ErrorCode = 16
                !  TCG(tdx)%errLine = ' ERROR : '
                !  TCG(tdx)%errLine(pos(7):) = ' ^ grade not valid, or REGD subjects excluded on purpose'
                !  !write(*,AFORMAT) trim(TCG(tdx)%txtLine), trim(TCG(tdx)%errLine)
                !  cycle loop_tcg
                !end if
                ! exclude invalid grades
                if (gdx<=0) then
                    TCG(tdx)%ErrorCode = 16
                    TCG(tdx)%errLine = ' ERROR : '
                    TCG(tdx)%errLine(pos(7):) = ' ^ grade not valid'
                    !write(*,AFORMAT) trim(TCG(tdx)%txtLine), trim(TCG(tdx)%errLine)
                    cycle loop_tcg
                end if

                ! check subject
                cdx = index_to_subject(tSubject)
                if (cdx==0) then
                    TCG(tdx)%ErrorCode = 18
                    TCG(tdx)%errLine = ' ERROR : '
                    TCG(tdx)%errLine(pos(4):) = ' ^ not in catalog'
                    !write(*,AFORMAT) trim(TCG(tdx)%txtLine), trim(TCG(tdx)%errLine)
                    cycle loop_tcg
                end if
                ! Gender-specific PE? Add M or F

                i = index(tSection, DASH)
                if ( (tSubject(1:4)=='PE 2' .or. tSubject(1:4)=='PE 3') .and. &
                     i>0) then
                  tSubject = tSubject(1:4)//DASH//tSection(:i-1)
                  if (tSubject=='PE 2-BB' .or. tSubject=='PE 2-BS' .or. &
                      tSubject=='PE 2-JD' .or. tSubject=='PE 2-SF' .or. &
                      tSubject=='PE 2-SO' .or. tSubject=='PE 2-SW' .or. &
                      tSubject=='PE 2-FUT' .or. &
                      tSubject=='PE 2-VB' .or. tSubject=='PE 2-BD') then
                    tSubject = 'PE 2-'//StudentInfo%Gender//tSubject(6:)
                  end if
                  k = index_to_subject(tSubject)
                  cdx = max(cdx, k)
                end if

                ! Called from HTMLTranscripts? Do not renamed subject!
                if (.not. present(DoNotRename)) then
                    k = index_to_new_subject(cdx)
                    if (k/=cdx) then
                        !write(*,*) trim(line)//' - subject taken as '//tSubject// &
                        !  ' renamed '//Subject(k)%Name
                        cdx = k
                    end if
                end if
                j = atoi(tYear)
                k = index_to_term(tTerm)
                if (k==3) j = j-1 ! make summer the end of the school year

                ! exclude future grades
                if ( j>currentYear .or. (j==currentYear .and. k>currentTerm) ) cycle

                TCG(tdx)%Subject = cdx
                TCG(tdx)%Grade = gdx
                TCG(tdx)%Year  = j
                TCG(tdx)%Term = k
                !write(*,*) trim(line)//' : ', j, k, cdx, gdx

                ! record type
                select case ( adjustl(line(pos(5)+1:pos(6)-1)) )
                    case ('APE')
                        TCG(i)%Code = 2
                    case ('REMOVAL')
                        TCG(i)%Code = 4
                    case ('COMPLETION')
                        TCG(i)%Code = 5
                    case default
                        TCG(i)%Code = 3
                end select

                ! check for duplicates
                do i=tdx-1,1,-1
                    if (TCG(i)%Code<2) cycle
                    if (TCG(i)%Subject/=cdx) cycle
                    if (TCG(i)%Grade/=gdx) cycle
                    if (TCG(i)%Year/=j) cycle
                    if (TCG(i)%Term/=k) cycle
                    ! duplicate: same subject, same grade, same semester
                    TCG(tdx)%Code = 0
                    TCG(tdx)%ErrorCode = 15
                    TCG(tdx)%errLine = ' ERROR : '
                    TCG(tdx)%errLine(pos(2):) = ' ^ duplicate grade?'
                    !write(*,AFORMAT) trim(TCG(tdx)%txtLine), trim(TCG(tdx)%errLine)
                    exit
                end do

            end if
        end do loop_tcg
        ! match COMPLETIONS & REMOVALS with original grades
        do tdx=1,lenTCG
            if (TCG(tdx)%Code<2) cycle
            cdx = TCG(tdx)%Subject
            if (index(TCG(tdx)%txtLine, 'REMOVAL')>0) then
                k = 0
                if (Subject(cdx)%Name(1:4)/='PE 2' .and. Subject(cdx)%Name(1:4)/='PE 3') then
                    do j=lenTCG,1,-1
                        if (TCG(j)%Code<2) cycle
                        if (TCG(j)%Subject/=TCG(tdx)%Subject) cycle
                        if (TCG(j)%Grade/=gdx4) cycle
                        k = j
                        exit
                    end do
                else
                    do j=lenTCG,1,-1
                        if (TCG(j)%Code<2) cycle
                        if (Subject(TCG(j)%Subject)%Name(1:4)/=Subject(cdx)%Name(1:4)) cycle
                        if (TCG(j)%Grade/=gdx4) cycle
                        k = j
                        exit
                    end do
                end if
                if (k>0) then
                    TCG(k)%ReExam = TCG(tdx)%Grade
                ! WARNING: Uncommenting next line will cause errors in forecasting demand
                !           TCG(tdx)%Code = -1
                else
                    write(unitLOG,AFORMAT) 'Original grade of 4 not found: '// &
                        Student(std)%StdNo//SPACE//trim(TCG(tdx)%txtLine)
                end if
            else if (index(TCG(tdx)%txtLine, 'COMPLETION')>0) then
                k = 0
                if (Subject(cdx)%Name(1:4)/='PE 2' .and. Subject(cdx)%Name(1:4)/='PE 3') then
                    do j=lenTCG,1,-1
                        if (TCG(j)%Code<2) cycle
                        if (TCG(j)%Subject/=TCG(tdx)%Subject) cycle
                        if (TCG(j)%Grade/=gdxINC) cycle
                        k = j
                        exit
                    end do
                else
                    do j=lenTCG,1,-1
                        if (TCG(j)%Code<2) cycle
                        if (Subject(TCG(j)%Subject)%Name(1:4)/=Subject(cdx)%Name(1:4)) cycle
                        if (TCG(j)%Grade/=gdxINC) cycle
                        k = j
                        exit
                    end do
                end if
                if (k>0) then
                    TCG(k)%ReExam = TCG(tdx)%Grade
                    ! WARNING: Uncommenting next line will cause errors in forecasting demand
                    !           TCG(tdx)%Code = -1
                else
                    write(unitLOG,AFORMAT) 'Original grade of INC not found: '// &
                        Student(std)%StdNo//SPACE//trim(TCG(tdx)%txtLine)
                end if
            end if
        end do

        ! remove grade for "CHEM XX" subjects if grade for "CHEM XX.0" and/or "CHEM XX.1" are available
        do tdx=1,lenTCG
            tSubject = Subject(TCG(tdx)%Subject)%Name
            if (tSubject == 'CHEM 40' .or. &
                tSubject == 'CHEM 32' .or. &
                tSubject == 'CHEM 17' .or. &
                tSubject == 'CHEM 15' .or. &
                tSubject == 'CHEM 16' .or. &
                tSubject == 'CHEM 43' .or. &
                tSubject == 'CHEM 44') then

                ! find "CHEM XX.0 and/or "CHEM XX.1"
                token = trim(tSubject)//'.0'
                cdx = index_to_subject(token)
                token = trim(tSubject)//'.1'
                gdx = index_to_subject(token)
                j = 0
                do i=1,lenTCG
                    if (TCG(i)%Code<2) cycle ! not a grade
                    if (TCG(i)%Subject/=cdx .and. TCG(i)%Subject/=gdx) cycle ! not CHEM XX.0 nor CHEM XX.1
                    if (TCG(i)%Taken/=TCG(tdx)%Taken) cycle ! grade not in the same semester
                    j = i
                    exit
                end do
                if (j>0) then ! found
                    TCG(tdx)%Code = -1
                    !write(*,*) 'Mistake : '//Student(std)%StdNo//DASH//trim(TCG(tdx)%txtLine)
                end if
            end if
        end do

    end subroutine custom_read_student_grades


    subroutine  custom_read_substitutions (std, DoNotRename)
        integer, intent (in) :: std
        logical, optional, intent (in) :: DoNotRename
        character (len=MAX_LEN_TEXT_YEAR) :: tYear
        character (len=MAX_LEN_TEXT_SEMESTER) :: tTerm
        type (TYPE_CURRICULUM) :: tCheckList
        character (len=MAX_LEN_SUBJECT_CODE) :: token
        integer :: q(MAX_LEN_STUDENT_RECORD)
        integer :: idxCURR, pocw
        integer :: i, j, k, cdx, eof, tdx

        idxCURR = Student(std)%CurriculumIdx
        StdNoYearLen = year_prefix(Student(std))
        fileTCG = trim(dirTRANSCRIPTS)//trim(Student(std)%StdNo(1:StdNoYearLen))//DIRSEP//Student(std)%StdNo
        pocw = 0 ! no. of PlanOfStudy entries

        open(200, file=fileTCG, form='formatted', status='old', iostat=eof)
        if (eof==0) then
            do
                read (200, AFORMAT, iostat=eof) line
                if (eof<0) exit
                if (line(1:16)=='PlanOfCoursework') then
                    lenTCG = lenTCG + 1
                    pocw = pocw + 1
                    call check_array_bound (lenTCG, MAX_LEN_STUDENT_RECORD, 'MAX_LEN_STUDENT_RECORD @ '//fileTCG)
                    if (line(17:22)==',PE 2,') line = line(1:16)//',,'//line(17:)
                    TCG(lenTCG)%txtLine = line
                    !call html_comment(line)
                end if
            end do
            close(200)
        end if

        if (pocw==0) then ! get default GE
            fileTCG = trim(pathToYear)//'defaultGE'
            !write(*,*) 'Looking into '//trim(fileTCG)
            open(200, file=fileTCG, form='formatted', status='old', iostat=eof)
            if (eof==0) then
                do
                    read (200, AFORMAT, iostat = eof) line
                    if (eof<0) exit
                    if (line(1:1)=='#' .or. line(1:1)==SPACE) cycle
                    call index_to_delimiters(COMMA, line, ndels, pos)
                    if (line(1:pos(2)-1)/=trim(CurrProgCode(idxCURR))) cycle
                    lenTCG = lenTCG + 1
                    call check_array_bound (lenTCG, MAX_LEN_STUDENT_RECORD, 'MAX_LEN_STUDENT_RECORD @ '//fileTCG)
                    TCG(lenTCG)%txtLine = line(pos(2)+1:)
                    !call html_comment(TCG(lenTCG)%txtLine)
                end do
                close(200)
            end if
        end if

        ! parse TCG; assume initial good academic standing
        tCheckList = Curriculum(idxCURR)
        loop_tcg: &
        do tdx=1,lenTCG
            line = TCG(tdx)%txtLine
            TCG(tdx)%Used = .false.

            i = index(line, '0A')
            if (i>0) then
                line(i+1:i+1) = 'a'
                TCG(tdx)%txtLine(i+1:i+1) = 'a'
            end if

            if (line(1:16)=='PlanOfCoursework') then
                !call html_comment(line)
                !write(*,*) tdx, trim(line)
                ! PlanOfCoursework,Year,Term,Reqd(1),Reqd(2),...,Reqd(m),Subst(1),Subst(2),...,Subst(n)
                !1                2    3    4                           5
                call index_to_delimiters(COMMA, line, ndels, pos)
                if (ndels<5) then
                    TCG(tdx)%ErrorCode = 25
                    TCG(tdx)%errLine = ' ERROR : '
                    TCG(tdx)%errLine(pos(ndels+1):) = ' ^ missing token(s)'
                    !write(*,AFORMAT) trim(TCG(tdx)%txtLine), trim(TCG(tdx)%errLine)
                    cycle loop_tcg
                end if
                tYear = line(pos(2)+1:pos(3)-1)
                tTerm = line(pos(3)+1:pos(4)-1)
                i = index_to_term(tTerm)
                j = index_to_year(tYear)
                if (i<0 .or. j==0) then
                    TCG(tdx)%ErrorCode = 1
                    TCG(tdx)%errLine = ' WARNING : '
                    TCG(tdx)%errLine(pos(3):) = ' ^ error in YEAR or TERM'
                    TCG(tdx)%Term = tCheckList%NumTerms   ! last semester
                else
                    TCG(tdx)%Term = (j-1)*3 + i
                end if
                ! check validity of tokens
                q = 0
                do k=4,ndels
                    token = line(pos(k)+1:pos(k+1)-1)

                    ! add gender to certain PE 2 activities
                    if (token=='PE 2-BB' .or. token=='PE 2-BS' .or. &
                        token=='PE 2-JD' .or. token=='PE 2-SF' .or. &
                        token=='PE 2-SO' .or. token=='PE 2-SW' .or. &
                        token=='PE 2-FUT' .or. &
                        token=='PE 2-VB' .or. token=='PE 2-BD') then
                        token = 'PE 2-'//StudentInfo%Gender//token(6:)
                    end if

                    i = index_to_subject(token)
                    if (i/=0) then
                        if (.not. present(DoNotRename)) then
                            j = index_to_new_subject(i)
                            if (j/=i) then
                                ! write(*,*) Student(std)%StdNo//' - in plan of study: '//token// &
                                !   ' renamed '//Subject(j)%Name
                                i = j
                            end if
                        end if
                        q(k) = i
                    else
                        TCG(tdx)%ErrorCode = 30
                        TCG(tdx)%errLine = ' ERROR : '
                        TCG(tdx)%errLine(pos(k):) = ' ^ not in catalog'
                        !call html_comment(TCG(tdx)%txtLine, TCG(tdx)%errLine)
                        cycle loop_tcg
                    end if
                end do

                ! determine which are required, which are not
                do j=4,ndels
                    token = Subject(q(j))%Name
                    if (token=='ADDITIONAL') then
                        i = TCG(tdx)%Reqd(0) + 1
                        TCG(tdx)%Reqd(0) = i
                        TCG(tdx)%Reqd(i) = q(j)
                    else
                        k = index_of_subject_in_curriculum(tCheckList, q(j))
                        if (k==0) then ! not in curriculum
                            if (q(j)<0) then ! dummy subject that is not in curriculum
                                TCG(tdx)%ErrorCode = 40
                                TCG(tdx)%errLine = ' ERROR : '
                                TCG(tdx)%errLine(pos(j):) = ' ^ not in curriculum; extra dummy?'

                                !call html_comment(TCG(tdx)%txtLine, TCG(tdx)%errLine)
                                cycle loop_tcg
                            !else if (token(1:4)=='PE 2') then ! extra PE 2 choice
                            !    i = TCG(tdx)%Reqd(0) + 1
                            !    TCG(tdx)%Reqd(0) = i
                            !    TCG(tdx)%Reqd(i) = q(j)
                            else ! other named subject that is not in curriculum
                                i = TCG(tdx)%Subst(0) + 1
                                TCG(tdx)%Subst(0) = i
                                TCG(tdx)%Subst(i) = q(j)

                                !call html_comment(token//' - other named subject that is not in curriculum')
                            end if
                        else ! required in curriculum
                            ! check if prior token is dummy
                            if (j>4 .and. q(j-1)<0) then ! PlanOfStudy,Year,Term,dummy,Reqd (added previously)
                                i = TCG(tdx)%Subst(0) + 1
                                TCG(tdx)%Subst(0) = i
                                TCG(tdx)%Subst(i) = q(j)

                              !call html_comment(token//' - named subject for a dummy in curriculum')
                            else ! j=4 .or. previous is not a dummy (therefore, substitution?)
                                i = TCG(tdx)%Reqd(0) + 1
                                TCG(tdx)%Reqd(0) = i
                                TCG(tdx)%Reqd(i) = q(j)

                              !call html_comment(token//' - named subject/dummy that is in curriculum')
                            end if

                        end if
                    end if
                end do

                ! if (m==0 or n==0)  then
                !   ERROR
                if (TCG(tdx)%Reqd(0)==0) then
                    TCG(tdx)%ErrorCode = 50
                    TCG(tdx)%errLine = ' ERROR : '
                    TCG(tdx)%errLine(pos(4):) = ' ^ required subject is missing or is extra?'

                    !call html_comment(TCG(tdx)%txtLine, TCG(tdx)%errLine)
                    cycle loop_tcg
                else if (TCG(tdx)%Reqd(0)*TCG(tdx)%Subst(0)==0) then
                    TCG(tdx)%ErrorCode = 50
                    TCG(tdx)%errLine = ' ERROR : '
                    TCG(tdx)%errLine(pos(5):) = ' ^ subject is missing or is a duplicate?'

                    !call html_comment(TCG(tdx)%txtLine, TCG(tdx)%errLine)
                    cycle loop_tcg
                end if
                ! else if (m==1) then
                !   if (Reqd(1)==ADDITIONAL) then
                !     ADD Subst(1) to Year,Term in curriculum
                if (TCG(tdx)%Reqd(0)==1) then
                    token = Subject(TCG(tdx)%Reqd(1))%Name
                    if (token=='ADDITIONAL') then
                        i = tCheckList%NSubjects
                        do j = 1,TCG(tdx)%Subst(0)
                            tCheckList%NSubjects = i+j
                            tCheckList%SubjectTerm(i+j) = TCG(tdx)%Term
                            tCheckList%SubjectIdx(i+j) = TCG(tdx)%Subst(j)
                        end do
                    !   else if (Reqd(1) is a dummy subject) then
                    !     REPLACE Reqd(1) in Year,Term of curriculum with Subst(1)
                    else if (TCG(tdx)%Reqd(1)<0) then
                        k = 0
                        do i=1,tCheckList%NSubjects
                            if (tCheckList%SubjectTerm(i)==TCG(tdx)%Term .and. &
                            tCheckList%SubjectIdx(i)==TCG(tdx)%Reqd(1)) then
                                k = i
                                exit
                            end if
                        end do
                        if (k>0) then ! found exact position in curriculum
                            tCheckList%SubjectIdx(k) = TCG(tdx)%Subst(1)
                        else ! find a similar dummy not in specified term
                            do i=1,tCheckList%NSubjects
                                if (tCheckList%SubjectIdx(i)==TCG(tdx)%Reqd(1)) then
                                    k = i
                                    exit
                                end if
                            end do
                            if (k>0) then ! found one similar dummy
                                tCheckList%SubjectIdx(k) = TCG(tdx)%Subst(1)
                                TCG(tdx)%ErrorCode = 1
                                TCG(tdx)%errLine = ' WARNING : '
                                TCG(tdx)%errLine(pos(3):) = ' ^ error in YEAR or TERM'
                            else ! none found
                                TCG(tdx)%ErrorCode = 1
                                TCG(tdx)%errLine = ' WARNING : '
                                TCG(tdx)%errLine(pos(4):) = ' ^ not used; extra dummy?'
                            end if
                        end if
                    !   else if (Reqd(1) is a named subject) then
                    !     REPLACE Reqd(1) with Subst(1..n)
                    !   end if
                    else ! if (TCG(tdx)%Reqd(1)>0) then
                        k = 0
                        do i=1,tCheckList%NSubjects
                            if (tCheckList%SubjectIdx(i)==TCG(tdx)%Reqd(1)) then
                                k = i
                                exit
                            end if
                        end do
                        if (k>0) then ! found exact position in curriculum
                            tCheckList%SubjectIdx(k) = TCG(tdx)%Subst(1)
                            i = tCheckList%NSubjects
                            do j = 2,TCG(tdx)%Subst(0)
                                tCheckList%NSubjects = i+j-1
                                tCheckList%SubjectTerm(i+j-1) = tCheckList%SubjectTerm(k)
                                tCheckList%SubjectIdx(i+j-1) = TCG(tdx)%Subst(j)
                            end do
                        else ! not found
                            TCG(tdx)%ErrorCode = 1
                            TCG(tdx)%errLine = ' WARNING : '
                            TCG(tdx)%errLine(pos(4):) = ' ^ not used; duplicate entry?'
                        end if
                    end if
                ! else {group substitution}
                else
                    !   do i=1,min(m,n)
                    !     REPLACE Reqd(i) with Susbt(i)
                    !   end do
                    do cdx=1,min( TCG(tdx)%Reqd(0), TCG(tdx)%Subst(0) )
                        k = 0
                        do i=1,tCheckList%NSubjects
                            if (tCheckList%SubjectIdx(i)==TCG(tdx)%Reqd(cdx)) then
                                k = i
                                exit
                            end if
                        end do
                        if (k>0) then ! found exact position in curriculum
                            tCheckList%SubjectIdx(k) = TCG(tdx)%Subst(cdx)
                        else ! not found
                            TCG(tdx)%ErrorCode = 1
                            TCG(tdx)%errLine = ' WARNING : '
                            TCG(tdx)%errLine(pos(4):) = ' ^ not used; duplicate entry?'
                        end if
                    end do
                    !   do i=min(m,n)+1,m
                    !     REMOVE Reqd(i)
                    !   end do
                    do cdx=min( TCG(tdx)%Reqd(0), TCG(tdx)%Subst(0) )+1, TCG(tdx)%Reqd(0)
                        k = 0
                        do i=1,tCheckList%NSubjects
                            if (tCheckList%SubjectIdx(i)==TCG(tdx)%Reqd(cdx)) then
                                k = i
                                exit
                            end if
                        end do
                        if (k>0) then ! found exact position in curriculum
                            tCheckList%SubjectIdx(k) = 0
                        end if
                    end do
                    !   do i=min(m,n)+1,n
                    !     ADD Subst(i) to Year,Term in curriculum
                    !   end do
                    do cdx=min( TCG(tdx)%Reqd(0), TCG(tdx)%Subst(0) )+1, TCG(tdx)%Subst(0)
                        i = tCheckList%NSubjects+1
                        tCheckList%NSubjects = i
                        tCheckList%SubjectTerm(i) = TCG(tdx)%Term
                        tCheckList%SubjectIdx(i) = TCG(tdx)%Subst(cdx)
                    end do
                ! end if

                end if

                TCG(tdx)%Code = 1

                !call html_comment('Required')
                !do cdx=1,TCG(tdx)%Reqd(0)
                !    call html_comment(Subject(TCG(tdx)%Reqd(cdx))%Name)
                !end do
                !call html_comment('Replacement')
                !do cdx=1,TCG(tdx)%Subst(0)
                !    call html_comment(Subject(TCG(tdx)%Subst(cdx))%Name)
                !end do
            end if
        end do loop_tcg

    end subroutine custom_read_substitutions

#endif
