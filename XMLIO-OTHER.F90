!======================================================================
!
!    HEEDS (Higher Education Enrollment Decision Support) - A program
!      to create enrollment scenarios for 'next term' in a university
!    Copyright (C) 2012-2015 Ricolindo L. Carino
!
!    This file is part of the HEEDS program.
!
!    HEEDS is free software: you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    (at your option) any later version.
!
!    HEEDS is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU General Public License for more details.
!
!    You should have received a copy of the GNU General Public License
!    along with this program (see the file COPYING.TXT). If not, see
!    <http://www.gnu.org/licenses/>.
!
!    Send inquiries about HEEDS to:
!      Ricolindo L Carino
!      E-mail: Ricolindo.Carino@AcademicForecasts.com
!      Address: 600 Cruise St., Starkville, MS 39759, U.S.A.
!
!======================================================================


    subroutine finalgrades_write(iYear, idxStudent)

        integer, intent (in) :: iYear
        integer, intent (in), optional :: idxStudent

        !logical :: pathExists

        integer :: idx, iStd, iTerm, first, last

        if (present(idxStudent)) then
            first = idxStudent
            last = first
        else
            first = 1
            last = NumStudents+NumAdditionalStudents
         end if

        do iStd=first,last
            if (.not. isAlphaNumeric(Student(iStd)%StdNo) ) cycle
            if (len_trim(Student(iStd)%StdNo)==0 ) cycle

            ! generate file name
            fileName = trim(dirDATA)//trim(itoa(iYear))//DIRSEP//'GRADES'//DIRSEP//trim(basefile_student(iStd))//dotXML

!            inquire(file=trim(fileName), exist=pathExists)
!            if (.not. pathExists) then
!                open(unit=unitXML, file=trim(fileName), status='new')
                open(unit=unitXML, file=trim(fileName))

                call xml_write_character(unitXML, 0, XML_DOC)
                call xml_write_character(unitXML, 0, ROOT_STUDENT_RECORD)
                call xml_write_character(unitXML, indent0, 'StdNo', Student(iStd)%StdNo)
                call xml_write_character(unitXML, indent0, 'Name', Student(iStd)%Name)
!
!            else
!                open(unit=unitXML, file=trim(fileName), status='old', position='append')
!                backspace(unitXML)
!            end if

            do iTerm=firstSemester,summerTerm
                do idx=1,Student(iStd)%Enlistment(iTerm)%lenSubject
                    if (Student(iStd)%Enlistment(iTerm)%Grade(idx)<=0) cycle
                    call xml_write_character(unitXML, indent0, txtGradeType(1), &
                        trim(itoa(iYear))//COMMA// &
                        trim(txtSemester(iTerm))//COMMA// &
                        trim(Subject(Student(iStd)%Enlistment(iTerm)%Subject(idx))%Name)//COMMA// &
                        txtGrade(pGrade(Student(iStd)%Enlistment(iTerm)%Grade(idx))) )
                end do
            end do

            call xml_write_character(unitXML, 0, FSLASH//ROOT_STUDENT_RECORD)
            close(unitXML)

            if (mod(iStd,1000)==0) write(*,*) iStd,  '/', NumStudents, ' done...'
        end do
        !write(*,*) NumStudents, ' done...'

    end subroutine finalgrades_write


    subroutine xml_write_student_grades(iStd)

        integer, intent (in) :: iStd

        integer :: idx

        if (isReadOnly) return

        open(unit=unitXML, file=trim(dirTRANSCRIPTS)//trim(basefile_student(iStd))//dotXML, status='unknown')
        call xml_write_character(unitXML, 0, XML_DOC)

        call xml_write_character(unitXML, 0, ROOT_STUDENT_RECORD)
        call xml_write_character(unitXML, 0, 'Comment', 'Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
            FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8) )

        call xml_write_character(unitXML, indent0, 'StdNo', Student(iStd)%StdNo)
        if (trim(Student(iStd)%Name)/='(Name)') &
            call xml_write_character(unitXML, indent0, 'Name', Student(iStd)%Name)
        call xml_write_character(unitXML, indent0, 'Curriculum', Curriculum(Student(iStd)%CurriculumIdx)%Code)

        do idx=1,lenTCG

            if (TCG(idx)%Code/=3 .or. TCG(idx)%Subject<=0 .or. TCG(idx)%Grade==0) cycle
            if (TCG(idx)%Year==currentYear .and. TCG(idx)%Term>=currentTerm) cycle

            call xml_write_character(unitXML, indent0, txtGradeType(1), &
                trim(itoa(TCG(idx)%Year))//COMMA// &
                trim(txtSemester(TCG(idx)%Term))//COMMA// &
                trim(Subject(TCG(idx)%Subject)%Name)//COMMA// &
                txtGrade(pGrade(TCG(idx)%Grade)) )
        end do

        call xml_write_character(unitXML, 0, FSLASH//ROOT_STUDENT_RECORD)
        close(unitXML)

    end subroutine xml_write_student_grades


    subroutine xml_write_student_advance_credits(iStd)

        integer, intent (in) :: iStd

        integer :: idx

        if (isReadOnly) return

        fileName = trim(dirADVANCECREDITS)//trim(basefile_student(iStd))//dotXML
        open(unit=unitXML, file=fileName, status='unknown')
        call xml_write_character(unitXML, 0, XML_DOC)

        call xml_write_character(unitXML, 0, ROOT_STUDENT_RECORD)
        call xml_write_character(unitXML, 0, 'Comment', 'Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
            FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8) )

        call xml_write_character(unitXML, indent0, 'StdNo', Student(iStd)%StdNo)
        if (trim(Student(iStd)%Name)/='(Name)') &
            call xml_write_character(unitXML, indent0, 'Name', Student(iStd)%Name)
        call xml_write_character(unitXML, indent0, 'Curriculum', Curriculum(Student(iStd)%CurriculumIdx)%Code)

        do idx=1,lenTCG
            if (TCG(idx)%Code/=2 .or. TCG(idx)%Grade==0) cycle ! not a ADVANCE/TRANSFER credit
            call xml_write_character(unitXML, indent0, txtGradeType(0), &
                trim(itoa(TCG(idx)%Year))//COMMA// &
                trim(txtSemester(TCG(idx)%Term))//COMMA// &
                trim(Subject(TCG(idx)%Subject)%Name)//COMMA// &
                txtGrade(pGrade(TCG(idx)%Grade)) )
        end do

        call xml_write_character(unitXML, 0, FSLASH//ROOT_STUDENT_RECORD)
        close(unitXML)

    end subroutine xml_write_student_advance_credits


    subroutine xml_write_student_completions(iStd)

        integer, intent (in) :: iStd

        integer :: idx

        if (isReadOnly) return

        open(unit=unitXML, file=trim(dirCOMPLETIONS)//trim(basefile_student(iStd))//dotXML, status='unknown')
        call xml_write_character(unitXML, 0, XML_DOC)

        call xml_write_character(unitXML, 0, ROOT_STUDENT_RECORD)
        call xml_write_character(unitXML, 0, 'Comment', 'Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
            FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8) )

        call xml_write_character(unitXML, indent0, 'StdNo', Student(iStd)%StdNo)
        if (trim(Student(iStd)%Name)/='(Name)') &
            call xml_write_character(unitXML, indent0, 'Name', Student(iStd)%Name)
        call xml_write_character(unitXML, indent0, 'Curriculum', Curriculum(Student(iStd)%CurriculumIdx)%Code)

        do idx=1,lenTCG

            if (TCG(idx)%Code/=5 .or. TCG(idx)%Grade==0) cycle ! not a COMPLETION

            call xml_write_character(unitXML, indent0, txtGradeType(3), &
                trim(itoa(TCG(idx)%Year))//COMMA// &
                trim(txtSemester(TCG(idx)%Term))//COMMA// &
                trim(Subject(TCG(idx)%Subject)%Name)//COMMA// &
                txtGrade(pGrade(TCG(idx)%Grade)) )
        end do

        call xml_write_character(unitXML, 0, FSLASH//ROOT_STUDENT_RECORD)
        close(unitXML)

    end subroutine xml_write_student_completions


    subroutine xml_write_substitutions(iStd)
        implicit none
        integer, intent (in) :: iStd

        integer :: crse_required, idx, k, l
        integer :: rank, iYear, iTerm, idxCURR

        if (isReadOnly) return


        open(unit=unitXML, file=trim(dirSUBSTITUTIONS)//trim(basefile_student(iStd))//dotXML, status='unknown')
        call xml_write_character(unitXML, 0, XML_DOC)
        call xml_write_character(unitXML, 0, ROOT_SUBSTITUTIONS)
        call xml_write_character(unitXML, 0, 'Comment', 'Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
            FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8) )

        idxCURR = Student(iStd)%CurriculumIdx
        call xml_write_character(unitXML, indent0, 'StdNo', Student(iStd)%StdNo)

        if (trim(Student(iStd)%Name)/='(Name)') &
            call xml_write_character(unitXML, indent0, 'Name', Student(iStd)%Name)

        if (Student(iStd)%CurriculumIdx/=0) &
            call xml_write_character(unitXML, indent0, 'Curriculum', Curriculum(idxCURR)%Code)

        l = 0 ! how many unspecified subjects?
        do k=1,Curriculum(idxCURR)%NSubjects
            crse_required = Curriculum(idxCURR)%SubjectIdx(k)
            if (crse_required < 0) l = l + 1
        end do

        if (l>0) then
            write(unitXML,AFORMAT) '    <comment>', &
                '        Substitutions for '//trim(Curriculum(idxCURR)%Code)
            do k=1,Curriculum(idxCURR)%NSubjects
                crse_required = Curriculum(idxCURR)%SubjectIdx(k)
                if (crse_required < 0) then
                    rank = Curriculum(idxCURR)%SubjectTerm(k)
                    call rank_to_year_term(rank, iYear, iTerm)
                    write(unitXML, aformat) indentation(:indent1)// &
                        trim(txtYear(iYear))//' Year, '// &
                        trim(txtSemester(iTerm))//' Term: '// &
                        Subject(crse_required)%Name
                end if
            end do
            write(unitXML,AFORMAT) '    </comment>'
        end if

        do idx=1,lenTCG

            if (TCG(idx)%Code/=1 .or. TCG(idx)%Reqd(0)==0) cycle

            call xml_write_character(unitXML, indent0, 'Substitution')
            if (TCG(idx)%Year>0 .and. TCG(idx)%Term>0) then
                call xml_write_character(unitXML, indent1, 'Year', txtYear(TCG(idx)%Year) )
                call xml_write_character(unitXML, indent1, 'Term', txtSemester(TCG(idx)%Term) )
            end if

            line = SPACE
            do k=1,TCG(idx)%Reqd(0)
                line = COMMA//trim(Subject(TCG(idx)%Reqd(k))%Name)//line
            end do
            call xml_write_character(unitXML, indent1, 'Required', line(2:))

            line = SPACE
            do k=1,TCG(idx)%Subst(0)
                line = COMMA//trim(Subject(TCG(idx)%Subst(k))%Name)//line
            end do
            call xml_write_character(unitXML, indent1, 'Replacement', line(2:))

            call xml_write_character(unitXML, indent0, '/Substitution')

        end do

        !write(unitXML,AFORMAT) '</'//ROOT_SUBSTITUTIONS//'>'
        call xml_write_character(unitXML, 0, FSLASH//ROOT_SUBSTITUTIONS)
        close(unitXML)

    end subroutine xml_write_substitutions


    subroutine xml_read_student_grades(iStd, dirGRADE, errNo)

        integer, intent (in) :: iStd
        character(len=*), intent (in) :: dirGRADE
        integer, intent (out) :: errNo

        character (len=MAX_LEN_SUBJECT_CODE) :: tSubject
        character (len=MAX_LEN_TEXT_GRADE) :: tGrade
        character (len=MAX_LEN_TEXT_SEMESTER) :: tTerm
        integer :: idx, grdType, gdx, cdx, iYear, iTerm, stat
        logical :: flag

        ! generate file name
        fileName = trim(dirGRADE)//trim(basefile_student(iStd))//dotXML

        ! open file, return on any error
        call xml_read_file(unitXML, ROOT_STUDENT_RECORD, fileName, errNo)
        if (errNo/=0) then ! not found
            !call html_comment('Error in reading '//filename)
            return
        end if
        !call html_comment('xml_read_student_grades('//trim(filename)//')')

        ! examine the file line by line
        do
            read(unitXML, AFORMAT, iostat=stat) line
            if (stat<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, stat)
            if (stat/=0) exit

            select case (trim(tag))

                case ('StdNo')
                    ! do nothing

                case ('Name')
                    ! do nothing

                case ('Gender')
                    ! do nothing

                case ('Curriculum')
                    ! do nothing

                case ('ResidenceStatus') ! ignore
                    ! do nothing

                case default ! grade

                    grdType = 0
                    do idx=0,3
                        if ( trim(tag)==trim(txtGradeType(idx)) ) then
                            grdType = idx+2
                            exit
                        end if
                    end do
                    if (grdType==0) cycle  !not a grade entry

                    lenTCG = lenTCG + 1
                    TCG(lenTCG)%Code    = grdType

                    TCG(lenTCG)%Used = .false.

                    call index_to_delimiters(COMMA, value, ndels, pos)

                    iYear = atoi(value(1:pos(2)-1)) ! year
                    TCG(lenTCG)%Year    = iYear

                    tTerm = value(pos(2)+1:pos(3)-1)
                    call upper_case(tTerm)
                    iTerm = index_to_term(tTerm) ! term
                    TCG(lenTCG)%Term    = iTerm

                    tGrade = value(pos(4)+1:pos(5)-1)
                    gdx = index_to_grade(tGrade) ! grade
                    ! force REGD  of more than 1 year ago to be DRP
                    if ((iYear+1)<currentYear .and. gdx==gdxREGD) gdx = gdxDRP
                    TCG(lenTCG)%Grade   = gdx

                    tSubject = value(pos(3)+1:pos(4)-1)
                    call upper_case(tSubject)
                    cdx = index_to_subject(tSubject) ! subject
                    TCG(lenTCG)%Subject = cdx

                    if (cdx==0 .or. gdx<=0) then ! discard
                        lenTCG = lenTCG - 1
                        call html_comment('Invalid subject and/or grade in '//trim(line) )
                        cycle
                    end if

                    if (grdType==3) then ! FINALGRADE

                        ! discard grades for current (or future) subjects in the record
                        if (iYear>currentYear .or. &
                            !(iYear==cTm1Year .and. iTerm==cTm1) .or. & ! previous term
                            (iYear==currentYear .and. iTerm>=currentTerm) ) then ! discard
                            lenTCG = lenTCG - 1
                            !call html_comment('Year-term is current or future in '//trim(line) )
                            cycle
                        end if

                    end if

                    if (tSubject(1:3)/='PE ') then
                    ! check for duplicates (same subject-grade) in case checklists were regenerated
                    ! without deleting the older versions
                    ! or same year-term-subject
                        flag = .false.
                        do idx=1,lenTCG-1
                            if ( TCG(idx)%Subject/=cdx ) cycle
                            if ( TCG(idx)%Year/=iYear ) cycle
                            if ( TCG(idx)%Term/=iTerm ) cycle
                            if ( TCG(idx)%Grade/=gdx ) cycle
                            flag = .true.
                            exit
                        end do
                        if (flag) then ! discard
                            lenTCG = lenTCG - 1
                            !call html_comment('Duplicate entry '//trim(line) )
                            cycle
                        end if
                    end if

            end select

        end do
        close(unitXML)

    end subroutine xml_read_student_grades


    subroutine xml_read_substitutions(iStd, errNo)

        integer, intent (in) :: iStd
        integer, intent (out) :: errNo

        character (len=MAX_LEN_TEXT_SEMESTER) :: tTerm
        character (len=MAX_LEN_TEXT_YEAR) :: tYear
        integer :: stat

        ! generate file name
        fileName = trim(dirSUBSTITUTIONS)//trim(basefile_student(iStd))//dotXML

        ! open file, return on any error
        call xml_read_file(unitXML, ROOT_SUBSTITUTIONS, fileName, errNo)
        if (errNo/=0) then
            !call html_comment('Error in reading '//filename)
            return
        end if

        !call html_comment('xml_read_substitutions('//trim(filename)//')')

        ! examine the file line by line
        do
            read(unitXML, AFORMAT, iostat=stat) line
            if (stat<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, stat)
            if (stat/=0) exit

            select case (trim(tag))

                case ('Substitution')
                    call check_array_bound (lenTCG+1, MAX_LEN_STUDENT_RECORD, &
                        'MAX_LEN_STUDENT_RECORD @ '//fileName)

                case ('Year') ! value is one of FIRST, SECOND, THIRD, FOURTH, ...
                    tYear = adjustl(value)
                    TCG(lenTCG+1)%Year = index_to_year(tYear)

                case ('Term') ! value is one of FIRST, SECOND, SUMMER
                    tTerm = adjustl(value)
                    TCG(lenTCG+1)%Term = index_to_term(tTerm)

                case ('Required') ! value is comma-separated list of subjects
                    call tokenize_subjects(value, ',', 5, &
                        TCG(lenTCG+1)%Reqd(0), TCG(lenTCG+1)%Reqd(1:), stat)

                case ('Replacement') ! value is comma-separated list of subjects
                    call tokenize_subjects(value, ',', 5, &
                        TCG(lenTCG+1)%Subst(0), TCG(lenTCG+1)%Subst(1:), stat)

                case ('/Substitution')

                    if (TCG(lenTCG+1)%Reqd(0)*TCG(lenTCG+1)%Subst(0)>0) then
                        lenTCG = lenTCG+1
                        TCG(lenTCG)%Code = 1
                        TCG(lenTCG)%Used = .false.
                    else
                        call html_comment('Invalid substitution entry in '//trim(filename))
                    end if

                case default

            end select

        end do
        close(unitXML)

    end subroutine xml_read_substitutions


    subroutine read_student_records (iStd)
        integer, intent (in) :: iStd

        integer :: ierr, i, j, k, iSubj, iYear

        ! student info
        call xml_read_student_info(iStd, ierr)

        ! record
        TCG = TYPE_STUDENT_RECORD (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.0, .false., SPACE, SPACE)
        lenTCG = 0

        ! retrieve record of substitutions
        call xml_read_substitutions(iStd, ierr)
        ! retrieve record of advanced/transfer credits
        call xml_read_student_grades(iStd, dirADVANCECREDITS, ierr)
        ! retrieve record of grades per year
        do iYear=baseYear,currentYear
            call xml_read_student_grades(iStd, trim(dirDATA)//trim(itoa(iYear))//DIRSEP//'GRADES'//DIRSEP, ierr)
        end do
        ! retrieve record of completions
        call xml_read_student_grades(iStd, dirCOMPLETIONS, ierr)

        ! match INCs with completion grades
        do i=lenTCG,1,-1
            if (TCG(i)%Grade/=gdxINC .and. TCG(i)%Grade/=gdxNFE) cycle ! not INC/NFE
            ! find completion, if any
            iSubj = TCG(i)%Subject
            k = 0
            do j=lenTCG,1,-1
                if ( TCG(j)%Code/=5) cycle ! not completion
                if ( TCG(j)%Used) cycle
                if ( TCG(j)%Subject/=iSubj ) cycle ! not the subject
                k = j
            end do
            if (k==0) cycle ! not found
            TCG(i)%ReExam = TCG(k)%Grade
            TCG(k)%Used = .true.
        end do

        ! compute when grades were received relative to baseYear
        do i=1,lenTCG
            if (TCG(i)%Code<2) cycle
            if (TCG(i)%Year==0 .or. TCG(i)%Term==-1) then
                TCG(i)%Year = baseYear
                TCG(i)%Term = 0
            end if
            TCG(i)%Taken = 3*(TCG(i)%Year - BaseYear + 1) + TCG(i)%Term
        end do

!        ! automatically convert INC to 70 if more than 3 terms have passed
!        now = 3*(CurrentYear - BaseYear + 1) + CurrentTerm
!        tGrade = '70  '
!        idx70 = index_to_grade(tGrade)
!        ! match INCs with completion grades
!        do i=lenTCG,1,-1
!            if (TCG(i)%Grade/=gdxINC .and. TCG(i)%Grade/=gdxNFE) cycle ! not INC/NFE
!            if (TCG(i)%ReExam/=0) cycle ! already completed
!            if (now-TCG(i)%Taken > 3) then ! taken more than 3 terms earlier
!                TCG(i)%Grade = idx70
!            end if
!        end do

        ! sort TCG; place 0-credit subjects last in each semester
        k = lenTCG + 1
        do i=1,lenTCG-1
            if (TCG(i)%Code<2) cycle
            do j=i+1,lenTCG
                if (TCG(j)%Code<2) cycle
                if (TCG(j)%Taken<TCG(i)%Taken) then
                    TCG(k) = TCG(i)
                    TCG(i) = TCG(j)
                    TCG(j) = TCG(k)
                else if (TCG(j)%Taken==TCG(i)%Taken) then
                    if (Subject(TCG(j)%Subject)%Units>Subject(TCG(i)%Subject)%Units) then
                        TCG(k) = TCG(i)
                        TCG(i) = TCG(j)
                        TCG(j) = TCG(k)
                    end if
                end if
            end do
        end do
        TCG(k) = TCG(k+1)

    end subroutine read_student_records


    subroutine xml_student_info(iStd, wrkStudent)

        integer, intent (in) :: iStd
        type (TYPE_STUDENT), intent(in), optional :: wrkStudent

        integer :: idx

        if (isReadOnly) return

        ! generate file name
        if (present(wrkStudent)) then
            idx = year_prefix(wrkStudent)
            fileName = trim(dirSTUDENTINFO)//trim(wrkStudent%StdNo(1:idx))//DIRSEP//trim(wrkStudent%StdNo)//dotXML
            call student_copy_to_info(wrkStudent)
        else
            fileName = trim(dirSTUDENTINFO)//trim(basefile_student(iStd))//dotXML
        end if

        ! write file
        open(unit=unitXML, file=fileName, iostat=idx)
        if (idx/=0) then
            call log_comment ('Not writable: '//fileName)
            return
        end if
        !write(*,*) trim(fileName)
        call xml_write_character(unitXML, 0, XML_DOC)

        !call html_comment('xml_student_info('//trim(filename)//')')

        call xml_write_character(unitXML, 0, ROOT_STUDENT_INFO)
        call xml_write_character(unitXML, 0, 'Comment',' Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
            FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8) )

        call xml_write_character(unitXML, indent0, 'Name', StudentInfo%Name)

        if (len_trim(StudentInfo%Email)/=0) &
           call xml_write_character(unitXML, indent0, 'Email', StudentInfo%Email)

        if (len_trim(StudentInfo%Father)/=0) &
           call xml_write_character(unitXML, indent0, 'Father', StudentInfo%Father)

        if (len_trim(StudentInfo%Mother)/=0) &
           call xml_write_character(unitXML, indent0, 'Mother', StudentInfo%Mother)

        if (len_trim(StudentInfo%Guardian)/=0) &
           call xml_write_character(unitXML, indent0, 'Guardian', StudentInfo%Guardian)

        if (len_trim(StudentInfo%Gender)/=0) &
            call xml_write_character(unitXML, indent0, 'Gender', StudentInfo%Gender)

        call xml_write_character(unitXML, indent0, 'Curriculum', Curriculum(StudentInfo%CurriculumIdx)%Code)

        if (len_trim(StudentInfo%Adviser)/=0) &
            call xml_write_character(unitXML, indent0, 'Adviser', StudentInfo%Adviser)

        call xml_write_integer(unitXML,   indent0, 'ResidenceStatus', StudentInfo%ResidenceStatus)

        if (len_trim(StudentInfo%BirthDate)/=0) &
            call xml_write_character(unitXML, indent0, 'BirthDate', StudentInfo%BirthDate)

        if (len_trim(StudentInfo%EntryDate)/=0) &
            call xml_write_character(unitXML, indent0, 'EntryDate', StudentInfo%EntryDate)

        if (len_trim(StudentInfo%GraduationDate)/=0) &
            call xml_write_character(unitXML, indent0, 'GraduationDate', StudentInfo%GraduationDate)

        if (len_trim(StudentInfo%BirthPlace)/=0) &
            call xml_write_character(unitXML, indent0, 'BirthPlace', StudentInfo%BirthPlace)

        if (len_trim(StudentInfo%BirthPlacePSGC)/=0) &
            call xml_write_character(unitXML, indent0, 'BirthPlacePSGC', StudentInfo%BirthPlacePSGC)

        if (len_trim(StudentInfo%HomeStreetAddress)/=0) &
            call xml_write_character(unitXML, indent0, 'HomeStreetAddress', StudentInfo%HomeStreetAddress)

        if (len_trim(StudentInfo%HomePSGC)/=0) &
            call xml_write_character(unitXML, indent0, 'HomePSGC', StudentInfo%HomePSGC)

        if (len_trim(StudentInfo%MotherTongue)/=0) &
            call xml_write_character(unitXML, indent0, 'MotherTongue', StudentInfo%MotherTongue)

        if (len_trim(StudentInfo%LastAttended)/=0) &
            call xml_write_character(unitXML, indent0, 'LastAttended', StudentInfo%LastAttended)

        if (len_trim(StudentInfo%TranscriptRemark)/=0) &
            call xml_write_character(unitXML, indent0, 'TranscriptRemark', StudentInfo%TranscriptRemark)

        if (len_trim(StudentInfo%TranscriptAdditionalRemark)/=0) &
            call xml_write_character(unitXML, indent0, 'TranscriptAdditionalRemark', StudentInfo%TranscriptAdditionalRemark)

        if (len_trim(StudentInfo%AdmissionData)/=0) &
            call xml_write_character(unitXML, indent0, 'AdmissionData', StudentInfo%AdmissionData)

        if (len_trim(StudentInfo%Scholarship)/=0) &
            call xml_write_character(unitXML, indent0, 'Scholarship', StudentInfo%Scholarship)

        call xml_write_character(unitXML, 0, FSLASH//ROOT_STUDENT_INFO)
        !write(unitXML,AFORMAT) '</'//ROOT_STUDENT_INFO//'>'
        close(unitXML)

    end subroutine xml_student_info


    subroutine xml_read_student_info(iStd, errNo, unitNo)

        integer, intent (in) :: iStd
        integer, intent (in), optional :: unitNo
        integer, intent (out) :: errNo

        integer :: idxCURR, ioUnit, stat
        character(len=MAX_LEN_CURRICULUM_CODE) :: tCurriculum

        call initialize_student_info()

        if (present(unitNo)) then
            ioUnit = unitNo
        else
            ioUnit = unitXML
        end if

        ! open file, return on any error
        fileName = trim(dirSTUDENTINFO)//trim(basefile_student(iStd))//dotXML
        call xml_read_file(ioUnit, ROOT_STUDENT_INFO, fileName, errNo)
        if (errNo/=0) then
            !call html_comment('Error in reading '//filename)
            return
        end if

        !call html_comment('xml_read_student_info('//trim(filename)//')')

        ! examine the file line by line
        do
            read(ioUnit, AFORMAT, iostat=stat) line
            if (stat<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, stat)
            if (stat/=0) exit

            value = adjustl(value)
            select case (trim(tag))

                case ('Name')
                    call upper_case(value)
                    StudentInfo%Name = value

                case ('Email')
                    StudentInfo%Email = value

                case ('Father')
                    StudentInfo%Father = value

                case ('Mother')
                    StudentInfo%Mother = value

                case ('Guardian')
                    StudentInfo%Guardian = value

                case ('Gender')
                    StudentInfo%Gender = value

                case ('Curriculum')
                    tCurriculum = value
                    idxCurr = index_to_curriculum(tCurriculum)
                    if (idxCurr<0) then
                        idxCurr = -idxCurr
                    else if (idxCurr==0) then
                        idxCurr = NumCurricula
                    end if
                    StudentInfo%CurriculumIdx = idxCurr

                case ('Adviser')
                    StudentInfo%Adviser = value

                case ('ResidenceStatus', 'ScholasticStatus')
                    StudentInfo%ResidenceStatus = max(0,atoi(value))

                case ('BirthDate')
                    StudentInfo%BirthDate = value

                case ('EntryDate')
                    StudentInfo%EntryDate = value

                case ('GraduationDate')
                    StudentInfo%GraduationDate = value

                case ('BirthPlace')
                    StudentInfo%BirthPlace = value

                case ('BirthPlacePSGC')
                    StudentInfo%BirthPlacePSGC = value

                case ('HomeStreetAddress', 'HomeAddress')
                    StudentInfo%HomeStreetAddress = value

                case ('HomePSGC')
                    StudentInfo%HomePSGC = value

                case ('MotherTongue')
                    StudentInfo%MotherTongue = value

                case ('LastAttended')
                    StudentInfo%LastAttended = value

                case ('AdmissionData')
                    StudentInfo%AdmissionData = value

                case ('Scholarship')
                    StudentInfo%Scholarship = value

                case ('TranscriptRemark')
                    StudentInfo%TranscriptRemark = value

                case ('TranscriptAdditionalRemark')
                    StudentInfo%TranscriptAdditionalRemark = value

                case default
                    ! do nothing

            end select

        end do
        close(ioUnit)

    end subroutine xml_read_student_info


    subroutine get_subject_areas()

        character (len=MAX_LEN_SUBJECT_CODE) :: token
        integer :: i, j, k

        NumSubjectAreas = 0
        SubjectArea = TYPE_SUBJECT_AREA (SPACE, 0, 0)
        do i=1,NumSubjects+NumAdditionalSubjects
            token = get_area(Subject(i)%Name)
            ! find token if it already exists
            k = 0
            do j=NumSubjectAreas,1,-1
                if (SubjectArea(j)%Code/=token) cycle
                k = j
                exit
            end do
            if (k==0) then ! not found
                call check_array_bound (NumSubjectAreas+1, MAX_ALL_SUBJECTS/3, 'NumSubjectAreas')
                NumSubjectAreas = NumSubjectAreas+1
                SubjectArea(NumSubjectAreas) = TYPE_SUBJECT_AREA(token, Department(Subject(i)%DeptIdx)%CollegeIdx, 1)
            else
                SubjectArea(k)%Count = SubjectArea(k)%Count + 1
            end if
        end do
    end subroutine get_subject_areas


    subroutine make_student_directories()

        integer :: iTmp, jTmp

        ! create student directories
        dirSUBSTITUTIONS    = trim(dirDATA)//'substitutions'//DIRSEP ! directory for input/UNEDITED checklists from Registrar
        dirTRANSCRIPTS      = trim(dirDATA)//'transcripts'//DIRSEP ! directory for raw transcripts
        dirADVANCECREDITS   = trim(dirDATA)//'advancecredits'//DIRSEP ! directory for advance/transfer credit records
        dirCOMPLETIONS      = trim(dirDATA)//'completions'//DIRSEP ! directory for completion records
        dirSTUDENTINFO      = trim(dirDATA)//'info'//DIRSEP ! directory for individual student info
        dirUPLOADS          = trim(dirDATA)//'uploads'//DIRSEP ! directory for uploads
        dirASSESSMENTS      = trim(dirDATA)//'assessments'//DIRSEP ! directory for individual student assesment
        dirDISCOUNTS        = trim(dirDATA)//'discounts'//DIRSEP ! directory for individual student discounts
        dirPAYMENTS         = trim(dirDATA)//'payments'//DIRSEP ! directory for individual student accounting transactions

        call collect_prefix_years()
        iTmp = 1
        do jTmp=2,len_trim(StdNoPrefix)
            if (StdNoPrefix(jTmp:jTmp)/=':') cycle
            if (StdNoPrefix(iTmp+1:jTmp-1)==SPACE) cycle

            call make_directory( trim(dirTRANSCRIPTS)//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirSUBSTITUTIONS)//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirADVANCECREDITS)//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirCOMPLETIONS)//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirSTUDENTINFO)//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirPICTURES)//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirASSESSMENTS)//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirDISCOUNTS)//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirPAYMENTS)//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirSTUDENTS)//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirDATA)//trim(itoa(currentYear))//DIRSEP//'GRADES'//DIRSEP//StdNoPrefix(iTmp+1:jTmp-1) )

            call make_directory( trim(dirLOG)//StdNoPrefix(iTmp+1:jTmp-1) )

            iTmp = jTmp
        end do

    end subroutine make_student_directories


    subroutine write_classes_blocks_csv (device, thisTerm, NumSections, Section, NumBlocks, Block )

        integer, intent (in) :: device, thisTerm, NumSections, NumBlocks
        type (TYPE_SECTION), intent(in) :: Section(0:)
        type (TYPE_BLOCK), intent(in) :: Block(0:)
        character(len=MAX_LEN_CLASS_ID) :: tClassId

        integer :: i, iBlk, iSect, iSubj, mdx, iStd, n_count

        write(device,AFORMAT) &
            '#', &
            '#  Schedule of Classes for '//txtSemester(thisTerm)//termQualifier(thisTerm), &
            '#', &
            '# Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '#', &
            '# Columns are : ', &
            '#   Subject - subject code', &
            '#   Section - section code, to differentiate section for the same subject', &
            '#   GradesIn - Date grades submitted', &
            '#   Owner - responsible unit', &
            '#   Seats - class capacity', &
            '#   Taken- no. of students in class', &
            '#   Time - begin time - end time of meeting', &
            '#   Day - days of meetings', &
            '#   Room - code for meeting room', &
            '#   Teacher - code for teacher of meeting', &
            '#', '#', &
            '"Subject","Section","GradesIn","Owner","Seats","Taken","Time","Day","Room","Teacher"'

        do iSect=1,NumSections
            iSubj = Section(iSect)%SubjectIdx
            if (iSubj==0) cycle
            tClassId = Section(iSect)%ClassId
            !write(*,*) Section(iSect)%ClassId, Section(iSect)%SubjectIdx

            ! collect students in section
            n_count = 0
            do i=1,NumStudents+NumAdditionalStudents
                iStd = StdRank(i)
                do mdx=1,Student(iStd)%Enlistment(thisTerm)%lenSubject
                    iBlk = Student(iStd)%Enlistment(thisTerm)%Section(mdx)
                    if (iBlk == iSect) then
                        n_count = n_count+1
                        exit
                    elseif (Student(iStd)%Enlistment(thisTerm)%Subject(mdx)==iSubj .and. isSubject_lecture_lab(iSubj)) then
                        iBlk = index(Section(iSect)%ClassId,DASH)
                        if (iBlk>0) then ! student is accommodated in a lab section
                            if (trim(tClassId)==Section(iSect)%ClassId(:iBlk-1)) then ! lab of lecture
                                n_count = n_count+1
                                exit
                            end if
                        end if
                    end if
                end do
            end do

            line = SPACE
            if (is_regular_schedule(iSect, thisTerm)) then

                line = COMMA//'"'//trim(Teacher(Section(iSect)%TeacherIdx(1))%TeacherId)//'"'//line
                line = COMMA//'"'//trim(Room(Section(iSect)%RoomIdx(1))%Code)//'"'//line
                line = COMMA//'"'//trim(text_days_of_section(Section(iSect)))//'"'//line
                line = COMMA//'"'//trim(text_time_period(Section(iSect)%bTimeIdx(1), Section(iSect)%eTimeIdx(1)))//'"'//line

            else ! class is "irregular": one entry for each meeting

                do mdx=Section(iSect)%NMeets,1,-1
                    line = COMMA//'"'//trim(Teacher(Section(iSect)%TeacherIdx(mdx))%TeacherId)//'"'//line
                    line = COMMA//'"'//trim(Room(Section(iSect)%RoomIdx(mdx))%Code)//'"'//line
                    line = COMMA//'"'//trim(txtDay(Section(iSect)%DayIdx(mdx)))//'"'//line
                    line = COMMA//'"'//trim(text_time_period(Section(iSect)%bTimeIdx(mdx), &
                        Section(iSect)%eTimeIdx(mdx)))//'"'//line
                end do

            end if

            line = COMMA//'"'//trim(itoa(n_count))//'"'//line
            line = COMMA//'"'//trim(itoa(Section(iSect)%Slots))//'"'//line
            line = COMMA//'"'//trim(Department(Section(iSect)%DeptIdx)%Code)//'"'//line
            line = COMMA//'"'//trim(Section(iSect)%GradeSubmissionDate)//'"'//line
            line = COMMA//'"'//trim(Section(iSect)%Code)//'"'//line
            line = '"'//trim(Subject(iSubj)%Name)//'"'//line

            write(device,AFORMAT) trim(line)

        end do


        write(device,AFORMAT) &
            SPACE, '#', &
            '#  Blocks for '//txtSemester(thisTerm)//termQualifier(thisTerm), &
            '#', &
            '# Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '#', &
            '# Columns are : ', &
            '#   Code - Block identifier', &
            '#   Curriculum - Curricular program for block', &
            '#   Description - Block description', &
            '#   Year - Year level in curriculum', &
            '#   Term - Term of the year in curriculum', &
            '#   Owner - Department that created (thus, can modify) block', &
            '#   Subject - Subject code', &
            '#   Section - Section code, if any', &
            '#', '#', &
            '"Code","Curriculum","Description","Year","Term","Owner","Subject",Section"'

        ! loop over blocks
        do iBlk=1,NumBlocks

            ! any classes assigned to this block?
            if (Block(iBlk)%NumClasses==0) cycle

            line = SPACE

            ! classes assigned to block
            do i=Block(iBlk)%NumClasses,1,-1
                iSect = Block(iBlk)%Section(i)
                if (iSect==0) then
                    line = COMMA//'"NONE"'//line
                else
                    line = COMMA//'"'//trim(Section(iSect)%Code)//'"'//line
                end if
                line = COMMA//'"'//trim(Subject(Block(iBlk)%Subject(i))%Name)//'"'//line
            end do
            line = COMMA//'"'//trim(Department(Block(iBlk)%DeptIdx)%Code)//'"'//line
            line = COMMA//'"'//trim(txtSemester(Block(iBlk)%Term))//'"'//line
            line = COMMA//'"'//trim(txtYear(Block(iBlk)%Year))//'"'//line
            line = COMMA//'"'//trim(Block(iBlk)%Name)//'"'//line
            line = COMMA//'"'//trim(Curriculum(Block(iBlk)%CurriculumIdx)%Code)//'"'//line
            line = '"'//trim(Block(iBlk)%BlockID)//'"'//line

            write(device,AFORMAT) trim(line)
        end do

    end subroutine write_classes_blocks_csv


    subroutine write_enlistment_csv(device, thisTerm)

        integer, intent (in) :: device, thisTerm

        integer :: i, iSect, iStd, lenRecord

        write(device,AFORMAT) &
            '#', &
            '#  Enlistment for '//txtSemester(thisTerm)//termQualifier(thisTerm), &
            '#', &
            '# Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '#', '#', &
            '"StdNo","Name","Curriculum","Subject","Section","Grade"'

        do iStd=1,NumStudents+NumAdditionalStudents
            ! skip student with no record
            lenRecord = max(Student(iStd)%Enlistment(thisTerm)%lenSubject, Student(iStd)%Enlistment(thisTerm)%NPriority + &
                Student(iStd)%Enlistment(thisTerm)%NAlternates+Student(iStd)%Enlistment(thisTerm)%NCurrent)
            if (lenRecord==0) cycle

            line = SPACE
            do i=lenRecord,1,-1
                iSect = Student(iStd)%Enlistment(thisTerm)%Section(i)
                if (iSect==0) cycle
                line = COMMA//'"'//trim(Subject(Section(thisTerm,iSect)%SubjectIdx)%Name)//'","'// &
                    trim(Section(thisTerm,iSect)%Code)//'","'// &
                    trim(txtGrade(pGrade(Student(iStd)%Enlistment(thisTerm)%Grade(i))))//'"'//line
            end do

            line = COMMA//'"'//trim(Curriculum(Student(iStd)%CurriculumIdx)%Code)//'"'//line
            line = COMMA//'"'//trim(Student(iStd)%Name)//'"'//line
            line = '"'//trim(Student(iStd)%StdNo)//'"'//line

            write(device,AFORMAT) trim(line)
        end do

    end subroutine write_enlistment_csv


    subroutine log_record_change(fName, mesg)

        character (len=*), intent (in) :: fName, mesg

        logical :: logExists

        if (isReadOnly) return

        inquire(file=fName, exist=logExists)
        if (.not. logExists) then
            open(unit=unitUSER, file=fName, status='new')
        else
            open(unit=unitUSER, file=fName, status='old', position='append')
        end if
        write(unitUSER,AFORMAT) SPACE, 'RECORD CHANGE BY: '// &
            trim(USERNAME)//' : '//REMOTE_ADDR//' : '//currentDate//DASH//currentTime, trim(mesg)
        close(unitUSER)

    end subroutine log_record_change


    subroutine log_student_record_change(iStd, mesg)

        integer, intent (in) :: iStd
        character (len=*), intent (in) :: mesg

        fileName = trim(dirLOG)//trim(basefile_student(iStd))//'.log'
        call log_record_change(fileName, mesg)

    end subroutine log_student_record_change


    subroutine log_teacher_record_change(iTeach, mesg)

        integer, intent (in) :: iTeach
        character (len=*), intent (in) :: mesg

        fileName = trim(dirLOG)//trim(College(Department(Teacher(iTeach)%DeptIdx)%CollegeIdx)%Code)//DIRSEP// &
            trim(Teacher(iTeach)%TeacherId)//'.log'
        call log_record_change(fileName, mesg)

    end subroutine log_teacher_record_change

