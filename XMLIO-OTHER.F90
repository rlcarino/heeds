!======================================================================
!
!    HEEDS (Higher Education Enrollment Decision Support) - A program
!      to create enrollment scenarios for 'next term' in a university
!    Copyright (C) 2012-2014 Ricolindo L. Carino
!
!    This file is part of the HEEDS program.
!
!    HEEDS is free software: you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    (at your option) any later version.
!
!    HEEDS is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU General Public License for more details.
!
!    You should have received a copy of the GNU General Public License
!    along with this program (see the file COPYING.TXT). If not, see
!    <http://www.gnu.org/licenses/>.
!
!    Send inquiries about HEEDS to:
!      Ricolindo L Carino
!      E-mail: Ricolindo.Carino@AcademicForecasts.com
!      Address: 600 Cruise St., Starkville, MS 39759, U.S.A.
!
!======================================================================

    subroutine xml_write_student_grades(std)

        integer, intent (in) :: std

        integer :: idx

        ! generate file name
        idx = year_prefix(Student(std))
        fileName = trim(dirTRANSCRIPTS)//trim(Student(std)%StdNo(1:idx))//DIRSEP//trim(Student(std)%StdNo)//'.XML'
        call move_to_backup(fileName)
        call html_comment('xml_write_student_grades('//trim(fileName)//')')

        ! write file
        open(unit=unitXML, file=fileName, status='unknown')
        write(unitXML,AFORMAT) XML_DOC

        write(unitXML,AFORMAT) '<'//XML_ROOT_STUDENT_RECORD//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
            FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        StdNo - Student number', &
            '        Name - Student name', &
            '        Curriculum - Curriculum code', &
            '        '//txtGradeType(1)//' - YEAR,TERM,SUBJECT,GRADE', &
            '    </comment>'

        call xml_write_character(unitXML, indent0, 'StdNo', Student(std)%StdNo)
        if (trim(Student(std)%Name)/='(Name)') &
            call xml_write_character(unitXML, indent0, 'Name', Student(std)%Name)
        call xml_write_character(unitXML, indent0, 'Curriculum', Curriculum(Student(std)%CurriculumIdx)%Code)

        do idx=1,lenTCG

            if (TCG(idx)%Code/=3 .or. TCG(idx)%Subject<=0 .or. TCG(idx)%Grade==0) cycle
            if (TCG(idx)%Year==currentYear .and. TCG(idx)%Term==currentTerm) cycle

            call xml_write_character(unitXML, indent0, txtGradeType(1), &
                trim(itoa(TCG(idx)%Year))//COMMA// &
                trim(txtSemester(TCG(idx)%Term))//COMMA// &
                trim(Subject(TCG(idx)%Subject)%Name)//COMMA// &
                txtGrade(pGrade(TCG(idx)%Grade)) )
        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_STUDENT_RECORD//'>'
        close(unitXML)

    end subroutine xml_write_student_grades


    subroutine xml_write_student_advance_credits(std)

        integer, intent (in) :: std

        integer :: idx

        ! generate file name
        idx = year_prefix(Student(std))
        fileName = trim(dirADVANCECREDITS)//trim(Student(std)%StdNo(1:idx))//DIRSEP//trim(Student(std)%StdNo)//'.XML'

        call move_to_backup(fileName)
        call html_comment('xml_write_student_advance_credits('//trim(fileName)//')')

        ! write file
        open(unit=unitXML, file=fileName, status='unknown')
        write(unitXML,AFORMAT) XML_DOC

        write(unitXML,AFORMAT) '<'//XML_ROOT_STUDENT_RECORD//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
            FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        StdNo - Student number', &
            '        Name - Student name', &
            '        '//txtGradeType(0)//' - YEAR,TERM,SUBJECT,GRADE', &
            '    </comment>'

        call xml_write_character(unitXML, indent0, 'StdNo', Student(std)%StdNo)
        if (trim(Student(std)%Name)/='(Name)') &
            call xml_write_character(unitXML, indent0, 'Name', Student(std)%Name)
        call xml_write_character(unitXML, indent0, 'Curriculum', Curriculum(Student(std)%CurriculumIdx)%Code)

        do idx=1,lenTCG
            if (TCG(idx)%Code/=2 .or. TCG(idx)%Grade==0) cycle ! not a ADVANCE/TRANSFER credit
            call xml_write_character(unitXML, indent0, txtGradeType(0), &
                trim(itoa(TCG(idx)%Year))//COMMA// &
                trim(txtSemester(TCG(idx)%Term))//COMMA// &
                trim(Subject(TCG(idx)%Subject)%Name)//COMMA// &
                txtGrade(pGrade(TCG(idx)%Grade)) )
        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_STUDENT_RECORD//'>'
        close(unitXML)

    end subroutine xml_write_student_advance_credits


    subroutine xml_write_student_completions(std)

        integer, intent (in) :: std

        integer :: idx

        ! generate file name
        idx = year_prefix(Student(std))
        fileName = trim(dirCOMPLETIONS)//trim(Student(std)%StdNo(1:idx))//DIRSEP//trim(Student(std)%StdNo)//'.XML'

        call move_to_backup(fileName)
        call html_comment('xml_write_student_completions('//trim(fileName)//')')

        ! write file
        open(unit=unitXML, file=fileName, status='unknown')
        write(unitXML,AFORMAT) XML_DOC

        write(unitXML,AFORMAT) '<'//XML_ROOT_STUDENT_RECORD//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
            FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        StdNo - Student number', &
            '        Name - Student name', &
            '        '//txtGradeType(3)//' - YEAR,TERM,SUBJECT,GRADE', &
            '    </comment>'

        call xml_write_character(unitXML, indent0, 'StdNo', Student(std)%StdNo)
        if (trim(Student(std)%Name)/='(Name)') &
            call xml_write_character(unitXML, indent0, 'Name', Student(std)%Name)
        call xml_write_character(unitXML, indent0, 'Curriculum', Curriculum(Student(std)%CurriculumIdx)%Code)

        do idx=1,lenTCG

            if (TCG(idx)%Code/=5 .or. TCG(idx)%Grade==0) cycle ! not a COMPLETION

            call xml_write_character(unitXML, indent0, txtGradeType(3), &
                trim(itoa(TCG(idx)%Year))//COMMA// &
                trim(txtSemester(TCG(idx)%Term))//COMMA// &
                trim(Subject(TCG(idx)%Subject)%Name)//COMMA// &
                txtGrade(pGrade(TCG(idx)%Grade)) )
        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_STUDENT_RECORD//'>'
        close(unitXML)

    end subroutine xml_write_student_completions


    subroutine xml_write_substitutions(std)
        implicit none
        integer, intent (in) :: std

        integer :: crse_required, idx, k, l
        integer :: rank, Year, Term, idxCURR

        ! generate file name
        idx = year_prefix(Student(std))
        fileName = trim(dirSUBSTITUTIONS)//trim(Student(std)%StdNo(1:idx))//DIRSEP//trim(Student(std)%StdNo)//'.XML'

        call move_to_backup(fileName)
        call html_comment('xml_write_substitutions('//trim(filename)//')')

        ! write file
        open(unit=unitXML, file=fileName, status='unknown')
        write(unitXML,AFORMAT) XML_DOC

        write(unitXML,AFORMAT) '<'//XML_ROOT_SUBSTITUTIONS//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        StdNo - Student number', &
            '        Name - Student name', &
            '        Curriculum - Curriculum code', &
            '        Substitution - REQUIRED SUBJECT(S),REPLACEMENT SUBJECT(S)', &
            '    </comment>'

        idxCURR = Student(std)%CurriculumIdx
        call xml_write_character(unitXML, indent0, 'StdNo', Student(std)%StdNo)

        if (trim(Student(std)%Name)/='(Name)') &
            call xml_write_character(unitXML, indent0, 'Name', Student(std)%Name)

        if (Student(std)%CurriculumIdx/=0) &
            call xml_write_character(unitXML, indent0, 'Curriculum', Curriculum(idxCURR)%Code)

        l = 0 ! how many unspecified subjects?
        do k=1,Curriculum(idxCURR)%NSubjects
            crse_required = Curriculum(idxCURR)%SubjectIdx(k)
            if (crse_required < 0) l = l + 1
        end do

        if (l>0) then
            write(unitXML,AFORMAT) '    <comment>', &
                '        Substitutions for '//trim(Curriculum(idxCURR)%Code)
            do k=1,Curriculum(idxCURR)%NSubjects
                crse_required = Curriculum(idxCURR)%SubjectIdx(k)
                if (crse_required < 0) then
                    rank = Curriculum(idxCURR)%SubjectTerm(k)
                    call rank_to_year_term(rank, Year, Term)
                    write(unitXML, aformat) indentation(:indent1)// &
                        trim(txtYear(Year))//' Year, '// &
                        trim(txtSemester(Term))//' Term: '// &
                        Subject(crse_required)%Name
                end if
            end do
            write(unitXML,AFORMAT) '    </comment>'
        end if

        do idx=1,lenTCG

            if (TCG(idx)%Code/=1 .or. TCG(idx)%Reqd(0)==0) cycle

            call xml_write_character(unitXML, indent0, 'Substitution')
            if (TCG(idx)%Year>0 .and. TCG(idx)%Term>0) then
                ! call rank_to_year_term(TCG(idx)%Year, Year, Term)
                call xml_write_character(unitXML, indent1, 'Year', txtYear(TCG(idx)%Year) )
                call xml_write_character(unitXML, indent1, 'Term', txtSemester(TCG(idx)%Term) )
            end if

            line = SPACE
            do k=1,TCG(idx)%Reqd(0)
                line = COMMA//trim(Subject(TCG(idx)%Reqd(k))%Name)//line
            end do
            call xml_write_character(unitXML, indent1, 'Required', line(2:))

            line = SPACE
            do k=1,TCG(idx)%Subst(0)
                line = COMMA//trim(Subject(TCG(idx)%Subst(k))%Name)//line
            end do
            call xml_write_character(unitXML, indent1, 'Replacement', line(2:))

            call xml_write_character(unitXML, indent0, '/Substitution')

        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_SUBSTITUTIONS//'>'
        close(unitXML)

    end subroutine xml_write_substitutions


    subroutine xml_read_student_grades(std, dirGRADE, errNo)

        integer, intent (in) :: std
        character(len=*), intent (in) :: dirGRADE
        integer, intent (out) :: errNo

        character (len=MAX_LEN_SUBJECT_CODE) :: tSubject
        character (len=MAX_LEN_TEXT_GRADE) :: tGrade
        character (len=MAX_LEN_TEXT_SEMESTER) :: tTerm
        integer :: idx, grdType, gdx, cdx, iYear, iTerm
        logical :: flag

        ! generate file name
        idx = year_prefix(Student(std))
        fileName = trim(dirGRADE)//trim(Student(std)%StdNo(1:idx))//DIRSEP//trim(Student(std)%StdNo)//'.XML'

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_STUDENT_RECORD, fileName, errNo)
        if (errNo/=0) return

        call html_comment('xml_read_student_grades('//trim(filename)//')')

        ! examine the file line by line
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('StdNo')
                    ! do nothing

                case ('Name')
                    ! do nothing

                case ('Gender')
                    ! do nothing

                case ('Curriculum')
                    ! do nothing

                case ('Country')
                    ! do nothing

                case ('Classification') ! ignore
                    ! do nothing

                case default ! grade

                    grdType = 0
                    do idx=0,3
                        if ( trim(tag)==trim(txtGradeType(idx)) ) then
                            grdType = idx+2
                            exit
                        end if
                    end do
                    if (grdType==0) cycle  !not a grade entry

                    lenTCG = lenTCG + 1
                    TCG(lenTCG)%Code    = grdType

                    TCG(lenTCG)%Used = .false.

                    call index_to_delimiters(COMMA, value, ndels, pos)

                    iYear = atoi(value(1:pos(2)-1)) ! year
                    TCG(lenTCG)%Year    = iYear

                    tTerm = value(pos(2)+1:pos(3)-1)
                    call upper_case(tTerm)
                    iTerm = index_to_term(tTerm) ! term
                    TCG(lenTCG)%Term    = iTerm

                    tGrade = value(pos(4)+1:pos(5)-1)
                    gdx = index_to_grade(tGrade) ! grade
                    TCG(lenTCG)%Grade   = gdx

                    tSubject = value(pos(3)+1:pos(4)-1)
                    cdx = index_to_subject(tSubject) ! subject
                    TCG(lenTCG)%Subject = cdx

                    if (cdx==0 .or. gdx<=0) then ! discard
                        lenTCG = lenTCG - 1
                        call html_comment('Invalid subject and/or grade in '//trim(line) )
                        cycle
                    end if

                    ! discard grades for current (or future) subjects in the record
                    if (grdType==3) then ! FINALGRADE
                        if (iYear>currentYear .or. &
                            (iYear==cTm1Year .and. iTerm==cTm1) .or. & ! previous term
                            (iYear==currentYear .and. iTerm>=currentTerm) ) then ! discard
                            lenTCG = lenTCG - 1
                            !call html_comment('Year-term is current or future in '//trim(line) )
                            cycle
                        end if
                    end if

                    if (tSubject(1:3)/='PE ') then
                    ! check for duplicates (same subject-grade) in case checklists were regenerated
                    ! without deleting the older versions
                    ! or same year-term-subject
                        flag = .false.
                        do idx=1,lenTCG-1
                            if ( TCG(idx)%Subject/=cdx ) cycle
                            if ( TCG(idx)%Grade==gdx .or. &
                                (TCG(idx)%Year==iYear .and. TCG(idx)%Term==iTerm) ) then
                                flag = .true.
                                exit
                            end if
                        end do
                        if (flag) then ! discard
                            lenTCG = lenTCG - 1
                            !call html_comment('Duplicate entry '//trim(line) )
                            cycle
                        end if
                    end if

            end select

        end do
        close(unitXML)

    end subroutine xml_read_student_grades


    subroutine xml_read_substitutions(std, errNo)

        integer, intent (in) :: std
        integer, intent (out) :: errNo

        character (len=MAX_LEN_TEXT_SEMESTER) :: tTerm
        character (len=MAX_LEN_TEXT_YEAR) :: tYear
        integer :: idx

        ! generate file name
        idx = year_prefix(Student(std))
        fileName = trim(dirSUBSTITUTIONS)//trim(Student(std)%StdNo(1:idx))//DIRSEP//trim(Student(std)%StdNo)//'.XML'

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_SUBSTITUTIONS, fileName, errNo)
        if (errNo/=0) return

        call html_comment('xml_read_substitutions('//trim(filename)//')')

        ! examine the file line by line
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('Substitution')
                    call check_array_bound (lenTCG+1, MAX_LEN_STUDENT_RECORD, &
                        'MAX_LEN_STUDENT_RECORD @ '//fileName)

                case ('Year') ! value is one of FIRST, SECOND, THIRD, FOURTH, ...
                    tYear = adjustl(value)
                    TCG(lenTCG+1)%Year = index_to_year(tYear)

                case ('Term') ! value is one of FIRST, SECOND, SUMMER
                    tTerm = adjustl(value)
                    TCG(lenTCG+1)%Term = index_to_term(tTerm)

                case ('Required') ! value is comma-separated list of subjects
                    call tokenize_subjects(value, ',', 5, &
                        TCG(lenTCG+1)%Reqd(0), TCG(lenTCG+1)%Reqd(1:), eof)

                case ('Replacement') ! value is comma-separated list of subjects
                    call tokenize_subjects(value, ',', 5, &
                        TCG(lenTCG+1)%Subst(0), TCG(lenTCG+1)%Subst(1:), eof)

                case ('/Substitution')

                    if (TCG(lenTCG+1)%Reqd(0)*TCG(lenTCG+1)%Subst(0)>0) then
                        lenTCG = lenTCG+1
                        TCG(lenTCG)%Code = 1
                        TCG(lenTCG)%Used = .false.
                    else
                        call html_comment('Invalid substitution entry in '//trim(filename))
                    end if

                case default

            end select

        end do
        close(unitXML)

    end subroutine xml_read_substitutions


    subroutine read_student_records (std)
        integer, intent (in) :: std

        integer :: ierr, i, j, k, crse, grd

        ! student info
        call xml_read_student_info(std, ierr)

        ! record
        TCG = TYPE_STUDENT_RECORD (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.0, .false., SPACE, SPACE)
        lenTCG = 0

#if defined REGIST
        ! retrieve record of substitutions
        call xml_read_substitutions(std, ierr)
        ! retrieve record of grades
        call xml_read_student_grades(std, dirTRANSCRIPTS, ierr)
#else
        ! retrieve record of substitutions
        call xml_read_substitutions(std, ierr)
        ! retrieve record of advanced/transfer credits
        call xml_read_student_grades(std, dirADVANCECREDITS, ierr)
        ! retrieve record of grades per semester
        call xml_read_student_grades(std, dirTRANSCRIPTS, ierr)
        ! retrieve record of completions
        call xml_read_student_grades(std, dirCOMPLETIONS, ierr)
#endif

        ! add subjects previous term
        !call html_comment('Previous term: '//txtSemester(cTm1))
        !call html_comment('# subjects='//itoa(Enlistment(cTm1,std)%NPriority+Enlistment(cTm1,std)%NAlternates+ &
        !    Enlistment(cTm1,std)%NCurrent) )

        do i=1,Enlistment(cTm1,std)%NPriority+Enlistment(cTm1,std)%NAlternates+Enlistment(cTm1,std)%NCurrent

            grd = Enlistment(cTm1,std)%Grade(i)
            if (grd==0) cycle
            crse = Enlistment(cTm1,std)%Subject(i)
            !call html_comment(itoa(i)//Subject(crse)%Name//txtGrade(pGrade(grd)) )

            ! update if already included
            k = 0
            do j=1,lenTCG
                if ( TCG(j)%Subject/=crse ) cycle
                if ( TCG(j)%Year==cTm1Year .and. TCG(j)%Term==cTm1) then
                    k = j
                    exit
                end if
            end do
            if (k==0) then ! not found; add
                k = lenTCG+1
                lenTCG = k
                !call html_comment('Enlisted previous term: '//itoa(lenTCG)//Subject(crse)%Name//txtGrade(pGrade(grd)) )
            end if

            TCG(k)%Code    = 3           ! FINALGRADE
            TCG(k)%Used    = .false.

            TCG(k)%Year    = cTm1Year ! year
            TCG(k)%Term    = cTm1 ! term
            TCG(k)%Subject = crse
            TCG(k)%Grade   = grd

            ! convert REGD to PASS during enlistment
            if (isPeriodOne .and. grd==gdxREGD) then
                TCG(k)%Grade = gdxPASS
                call html_comment('Converted to '//txtGrade(pGrade(gdxPASS)) )
            end if

        end do

        ! add enlisted subjects
        if (.not. isPeriodOne) then
            do i=1,Enlistment(currentTerm,std)%NPriority+Enlistment(currentTerm,std)%NAlternates+ &
                Enlistment(currentTerm,std)%NCurrent

                grd = Enlistment(currentTerm,std)%Grade(i)
                if (grd==0) cycle
                crse = Enlistment(currentTerm,std)%Subject(i)

                ! update if already included
                k = 0
                do j=1,lenTCG
                    if ( TCG(j)%Subject/=crse ) cycle
                    if ( TCG(j)%Year==currentYear .and. TCG(j)%Term==currentTerm) then
                        k = j
                        exit
                    end if
                end do
                if (k==0) then ! not found
                    k = lenTCG+1
                    lenTCG = k
                    !call html_comment('Enlisted current term: '//itoa(lenTCG)//Subject(crse)%Name//txtGrade(pGrade(grd)) )
                end if

                TCG(k)%Code    = 3           ! FINALGRADE
                TCG(k)%Used    = .false.

                TCG(k)%Year    = currentYear ! year
                TCG(k)%Term    = currentTerm ! term
                TCG(k)%Subject = crse
                TCG(k)%Grade   = grd

            end do
        end if

        ! match INCs with completion grades
        do i=1,lenTCG
            if (TCG(i)%Grade/=gdxINC .and. TCG(i)%Grade/=gdxNFE) cycle ! not INC/NFE
            ! find completion, if any
            crse = TCG(i)%Subject
            k = 0
            do j=1,lenTCG
                if ( TCG(j)%Code/=5) cycle ! not completion
                if ( TCG(j)%Subject/=crse ) cycle ! not the subject
                k = j
            end do
            if (k==0) cycle ! not found
            TCG(i)%ReExam = TCG(k)%Grade
            TCG(k)%Used = .true.
        end do

        ! compute when grades were received relative to baseYear
        do i=1,lenTCG
            if (TCG(i)%Code<2) cycle
            if (TCG(i)%Year==0 .or. TCG(i)%Term==-1) then
                TCG(i)%Year = baseYear
                TCG(i)%Term = 0
            end if
            TCG(i)%Taken = 3*(TCG(i)%Year - BaseYear + 1) + TCG(i)%Term
        end do

        ! sort TCG; place 0-credit subjects last in each semester
        k = lenTCG + 1
        do i=1,lenTCG-1
            if (TCG(i)%Code<2) cycle
            do j=i+1,lenTCG
                if (TCG(j)%Code<2) cycle
                if (TCG(j)%Taken<TCG(i)%Taken) then
                    TCG(k) = TCG(i)
                    TCG(i) = TCG(j)
                    TCG(j) = TCG(k)
                else if (TCG(j)%Taken==TCG(i)%Taken) then
                    if (Subject(TCG(j)%Subject)%Units>Subject(TCG(i)%Subject)%Units) then
                        TCG(k) = TCG(i)
                        TCG(i) = TCG(j)
                        TCG(j) = TCG(k)
                    end if
                end if
            end do
        end do
        TCG(k) = TCG(k+1)

    end subroutine read_student_records


    subroutine xml_student_info(std, wrkStudent)

        integer, intent (in) :: std
        type (TYPE_STUDENT), intent(in), optional :: wrkStudent

        integer :: idx

        ! generate file name
        if (present(wrkStudent)) then
            idx = year_prefix(wrkStudent)
            fileName = trim(dirSTUDENTINFO)//trim(wrkStudent%StdNo(1:idx))//DIRSEP//trim(wrkStudent%StdNo)//'.XML'
            call student_copy_to_info(wrkStudent)
        else
            idx = year_prefix(Student(std))
            fileName = trim(dirSTUDENTINFO)//trim(Student(std)%StdNo(1:idx))//DIRSEP//trim(Student(std)%StdNo)//'.XML'
        end if

        ! write file
        open(unit=unitXML, file=fileName)
        write(unitXML,AFORMAT) XML_DOC

        call html_comment('xml_student_info('//trim(filename)//')')

        write(unitXML,AFORMAT) '<'//XML_ROOT_STUDENT_INFO//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        StdNo - Student number', &
            '        Name - Student name', &
            '        Gender - M=male, F=female', &
            '        Curriculum - Curriculum code', &
            '        Adviser - TeacherId of adviser', &
            '        Country - Country index; 1=Philippines', &
            '        Classification - Year level', &
            '        BirthDate - Birth date', &
            '        BirthPlace - Birth place', &
            '        HomeAddress - Home address', &
            '        EntryDate - Entry date', &
            '        GraduationDate - Graduation date', &
            '        LastAttended - Last school attended', &
            '        AdmissionData - Admission data', &
            '        Scholarship - Scholarship code', &
            '    </comment>'

        call xml_write_character(unitXML, indent0, 'StdNo', StudentInfo%StdNo)

        call xml_write_character(unitXML, indent0, 'Name', StudentInfo%Name)

        call xml_write_character(unitXML, indent0, 'Gender', StudentInfo%Gender)

        call xml_write_character(unitXML, indent0, 'Curriculum', Curriculum(StudentInfo%CurriculumIdx)%Code)

        if (len_trim(StudentInfo%Adviser)/=0) &
            call xml_write_character(unitXML, indent0, 'Adviser', StudentInfo%Adviser)

        if (StudentInfo%CountryIdx/=1) &
            call xml_write_integer(unitXML,   indent0, 'Country', StudentInfo%CountryIdx)

        if (StudentInfo%Classification/=0) &
            call xml_write_integer(unitXML,   indent0, 'Classification', StudentInfo%Classification)

        if (len_trim(StudentInfo%BirthDate)/=0) &
            call xml_write_character(unitXML, indent0, 'BirthDate', StudentInfo%BirthDate)

        if (len_trim(StudentInfo%EntryDate)/=0) &
            call xml_write_character(unitXML, indent0, 'EntryDate', StudentInfo%EntryDate)

        if (len_trim(StudentInfo%GraduationDate)/=0) &
            call xml_write_character(unitXML, indent0, 'GraduationDate', StudentInfo%GraduationDate)

        if (len_trim(StudentInfo%BirthPlace)/=0) &
            call xml_write_character(unitXML, indent0, 'BirthPlace', StudentInfo%BirthPlace)

        if (len_trim(StudentInfo%HomeAddress)/=0) &
            call xml_write_character(unitXML, indent0, 'HomeAddress', StudentInfo%HomeAddress)

        if (len_trim(StudentInfo%LastAttended)/=0) &
            call xml_write_character(unitXML, indent0, 'LastAttended', StudentInfo%LastAttended)

        if (len_trim(StudentInfo%AdmissionData)/=0) &
            call xml_write_character(unitXML, indent0, 'AdmissionData', StudentInfo%AdmissionData)

        if (len_trim(StudentInfo%Scholarship)/=0) &
            call xml_write_character(unitXML, indent0, 'Scholarship', StudentInfo%Scholarship)

        write(unitXML,AFORMAT) '</'//XML_ROOT_STUDENT_INFO//'>'
        close(unitXML)

    end subroutine xml_student_info


    subroutine xml_read_student_info(std, errNo)

        integer, intent (in) :: std
        integer, intent (out) :: errNo

        integer :: idx, idxCURR
        character(len=MAX_LEN_CURRICULUM_CODE) :: tCurriculum

        ! generate file name
        idx = year_prefix(Student(std))
        fileName = trim(dirSTUDENTINFO)//trim(Student(std)%StdNo(1:idx))//DIRSEP//trim(Student(std)%StdNo)//'.XML'

        call initialize_student_info()

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_STUDENT_INFO, fileName, errNo)
        if (errNo/=0) return

        call html_comment('xml_read_student_info('//trim(filename)//')')

        ! examine the file line by line
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            value = adjustl(value)
            select case (trim(tag))

                case ('StdNo')
                    StudentInfo%StdNo = value

                case ('Name')
                    call upper_case(value)
                    StudentInfo%Name = value

                case ('Gender')
                    StudentInfo%Gender = value

                case ('Curriculum')
                    tCurriculum = value
                    idxCurr = index_to_curriculum(tCurriculum)
                    if (idxCurr<0) then
                        idxCurr = -idxCurr
                    else if (idxCurr==0) then
                        idxCurr = NumCurricula
                    end if
                    StudentInfo%CurriculumIdx = idxCurr

                case ('Adviser')
                    StudentInfo%Adviser = value

                case ('Country')
                    StudentInfo%CountryIdx = atoi(value)

                case ('Classification')
                    StudentInfo%Classification = atoi(value)

                case ('BirthDate')
                    StudentInfo%BirthDate = value

                case ('EntryDate')
                    StudentInfo%EntryDate = value

                case ('GraduationDate')
                    StudentInfo%GraduationDate = value

                case ('BirthPlace')
                    StudentInfo%BirthPlace = value

                case ('HomeAddress')
                    StudentInfo%HomeAddress = value

                case ('LastAttended')
                    StudentInfo%LastAttended = value

                case ('AdmissionData')
                    StudentInfo%AdmissionData = value

                case ('Scholarship')
                    StudentInfo%Scholarship = value

                case default
                    ! do nothing

            end select

        end do
        close(unitXML)

    end subroutine xml_read_student_info


    subroutine get_subject_areas()

        character (len=MAX_LEN_SUBJECT_CODE) :: token
        integer :: i, j, k

        NumSubjectAreas = 0
        SubjectArea = TYPE_SUBJECT_AREA (SPACE, 0, 0)
        do i=1,NumSubjects+NumAdditionalSubjects
            token = get_area(Subject(i)%Name)
            ! find token if it already exists
            k = 0
            do j=NumSubjectAreas,1,-1
                if (SubjectArea(j)%Code/=token) cycle
                k = j
                exit
            end do
            if (k==0) then ! not found
                call check_array_bound (NumSubjectAreas+1, MAX_ALL_SUBJECTS/3, 'NumSubjectAreas')
                NumSubjectAreas = NumSubjectAreas+1
                SubjectArea(NumSubjectAreas) = TYPE_SUBJECT_AREA(token, Department(Subject(i)%DeptIdx)%CollegeIdx, 1)
            else
                SubjectArea(k)%Count = SubjectArea(k)%Count + 1
            end if
        end do
    end subroutine get_subject_areas


    subroutine make_student_directories()

        integer :: iTmp, jTmp

        ! create student directories
        dirSUBSTITUTIONS    = trim(dirDATA)//'substitutions'//DIRSEP ! directory for input/UNEDITED checklists from Registrar
        dirTRANSCRIPTS      = trim(dirDATA)//'transcripts'//DIRSEP ! directory for raw transcripts
        dirADVANCECREDITS   = trim(dirDATA)//'advancecredits'//DIRSEP ! directory for advance/transfer credit records
        dirCOMPLETIONS      = trim(dirDATA)//'completions'//DIRSEP ! directory for completion records
        dirSTUDENTINFO      = trim(dirDATA)//'info'//DIRSEP ! directory for individual student info

        call make_directory( dirTRANSCRIPTS )
        call make_directory( dirSUBSTITUTIONS )
        call make_directory( dirADVANCECREDITS )
        call make_directory( dirCOMPLETIONS )
        call make_directory( dirSTUDENTINFO )

        call make_directory( trim(dirBACKUP)//'transcripts' )
        call make_directory( trim(dirBACKUP)//'substitutions' )
        call make_directory( trim(dirBACKUP)//'advancecredits' )
        call make_directory( trim(dirBACKUP)//'completions' )
        call make_directory( trim(dirBACKUP)//'info' )

        call collect_prefix_years()
        iTmp = 1
        do jTmp=2,len_trim(StdNoPrefix)
            if (StdNoPrefix(jTmp:jTmp)/=':') cycle

            call make_directory( trim(dirTRANSCRIPTS)//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirSUBSTITUTIONS)//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirADVANCECREDITS)//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirCOMPLETIONS)//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirSTUDENTINFO)//StdNoPrefix(iTmp+1:jTmp-1) )

            call make_directory( trim(dirBACKUP)//'transcripts'//DIRSEP//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirBACKUP)//'substitutions'//DIRSEP//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirBACKUP)//'advancecredits'//DIRSEP//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirBACKUP)//'completions'//DIRSEP//StdNoPrefix(iTmp+1:jTmp-1) )
            call make_directory( trim(dirBACKUP)//'info'//DIRSEP//StdNoPrefix(iTmp+1:jTmp-1) )

            call make_directory( trim(dirLOG)//StdNoPrefix(iTmp+1:jTmp-1) )

            iTmp = jTmp
        end do

    end subroutine make_student_directories


    subroutine write_classes_blocks_csv (device, Term, NumSections, Section, NumBlocks, Block )

        integer, intent (in) :: device, Term, NumSections, NumBlocks
        type (TYPE_SECTION), intent(in) :: Section(0:)
        type (TYPE_BLOCK), intent(in) :: Block(0:)

        integer :: i, blk, sect, subj, mdx

        write(device,AFORMAT) &
            '#', &
            '#  Schedule of Classes for '//txtSemester(Term)//termQualifier(Term), &
            '#', &
            '# Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '#', &
            '# Columns are : ', &
            '#   Subject - subject code', &
            '#   Section - section code, to differentiate section for the same subject', &
            '#   GradesIn - Date grades submitted', &
            '#   Owner - responsible department', &
            '#   Seats - class capacity', &
            '#   Time - begin time - end time of meeting', &
            '#   Day - days of meetings', &
            '#   Room - code for meeting room', &
            '#   Teacher - code for teacher of meeting', &
            '#', '#', &
            '"Subject","Section","GradesIn","Owner","Seats","Time","Day","Room","Teacher"'

        do sect=1,NumSections
            subj = Section(sect)%SubjectIdx
            if (subj==0) cycle
            !write(*,*) Section(sect)%ClassId, Section(sect)%SubjectIdx

            line = SPACE
            if (is_regular_schedule(sect, Section)) then

                line = COMMA//'"'//trim(Teacher(Section(sect)%TeacherIdx(1))%TeacherId)//'"'//line
                line = COMMA//'"'//trim(Room(Section(sect)%RoomIdx(1))%Code)//'"'//line
                line = COMMA//'"'//trim(text_days_of_section(Section(sect)))//'"'//line
                line = COMMA//'"'//trim(text_time_period(Section(sect)%bTimeIdx(1), Section(sect)%eTimeIdx(1)))//'"'//line

            else ! class is "irregular": one entry for each meeting

                do mdx=Section(sect)%NMeets,1,-1
                    line = COMMA//'"'//trim(Teacher(Section(sect)%TeacherIdx(mdx))%TeacherId)//'"'//line
                    line = COMMA//'"'//trim(Room(Section(sect)%RoomIdx(mdx))%Code)//'"'//line
                    line = COMMA//'"'//trim(txtDay(Section(sect)%DayIdx(mdx)))//'"'//line
                    line = COMMA//'"'//trim(text_time_period(Section(sect)%bTimeIdx(mdx), Section(sect)%eTimeIdx(mdx)))//'"'//line
                end do

            end if

            line = COMMA//'"'//trim(itoa(Section(sect)%Slots))//'"'//line
            line = COMMA//'"'//trim(Department(Section(sect)%DeptIdx)%Code)//'"'//line
            line = COMMA//'"'//trim(Section(sect)%GradeSubmissionDate)//'"'//line
            line = COMMA//'"'//trim(Section(sect)%Code)//'"'//line
            line = '"'//trim(Subject(subj)%Name)//'"'//line

            write(device,AFORMAT) trim(line)

        end do


        write(device,AFORMAT) &
            SPACE, '#', &
            '#  Blocks for '//txtSemester(Term)//termQualifier(Term), &
            '#', &
            '# Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '#', &
            '# Columns are : ', &
            '#   Code - Block identifier', &
            '#   Curriculum - Curricular program for block', &
            '#   Description - Block description', &
            '#   Year - Year level in curriculum', &
            '#   Term - Term of the year in curriculum', &
            '#   Owner - Department that created (thus, can modify) block', &
            '#   Subject - Subject code', &
            '#   Section - Section code, if any', &
            '#', '#', &
            '"Code","Curriculum","Description","Year","Term","Owner","Subject",Section"'

        ! loop over blocks
        do blk=1,NumBlocks

            ! any classes assigned to this block?
            if (Block(blk)%NumClasses==0) cycle

            line = SPACE

            ! classes assigned to block
            do i=Block(blk)%NumClasses,1,-1
                sect = Block(blk)%Section(i)
                if (sect==0) then
                    line = COMMA//'"NONE"'//line
                else
                    line = COMMA//'"'//trim(Section(sect)%Code)//'"'//line
                end if
                line = COMMA//'"'//trim(Subject(Block(blk)%Subject(i))%Name)//'"'//line
            end do
            line = COMMA//'"'//trim(Department(Block(blk)%DeptIdx)%Code)//'"'//line
            line = COMMA//'"'//trim(txtSemester(Block(blk)%Term))//'"'//line
            line = COMMA//'"'//trim(txtYear(Block(blk)%Year))//'"'//line
            line = COMMA//'"'//trim(Block(blk)%Name)//'"'//line
            line = COMMA//'"'//trim(Curriculum(Block(blk)%CurriculumIdx)%Code)//'"'//line
            line = '"'//trim(Block(blk)%BlockID)//'"'//line

            write(device,AFORMAT) trim(line)
        end do

    end subroutine write_classes_blocks_csv


    subroutine write_enlistment_csv(device, Term, eList, Section)

        integer, intent (in) :: device, Term
        type (TYPE_PRE_ENLISTMENT), intent(in) :: eList(0:)
        type (TYPE_SECTION), intent(in) :: Section(0:)

        integer :: i, sect, std, lenRecord

        write(device,AFORMAT) &
            '#', &
            '#  Enlistment for '//txtSemester(Term)//termQualifier(Term), &
            '#', &
            '# Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '#', '#', &
            '"StdNo","Name","Curriculum","Subject","Section","Grade"'

        do std=1,NumStudents+NumAdditionalStudents
            ! skip student with no record
            lenRecord = max(eList(std)%lenSubject, eList(std)%NPriority+eList(std)%NAlternates+eList(std)%NCurrent)
            if (lenRecord==0) cycle

            line = SPACE
            do i=lenRecord,1,-1
                sect = eList(std)%Section(i)
                if (sect==0) cycle
                line = COMMA//'"'//trim(Subject(Section(sect)%SubjectIdx)%Name)//'","'// &
                    & trim(Section(sect)%Code)//'","'//trim(txtGrade(pGrade(eList(std)%Grade(i))))//'"'//line
            end do

            line = COMMA//'"'//trim(Curriculum(Student(std)%CurriculumIdx)%Code)//'"'//line
            line = COMMA//'"'//trim(Student(std)%Name)//'"'//line
            line = '"'//trim(Student(std)%StdNo)//'"'//line

            write(device,AFORMAT) trim(line)
        end do

    end subroutine write_enlistment_csv


    subroutine log_record_change(fName, mesg)

        character (len=*), intent (in) :: fName, mesg

        logical :: logExists

        inquire(file=fName, exist=logExists)
        if (.not. logExists) then
            open(unit=unitUSER, file=fName, status='new')
        else
            open(unit=unitUSER, file=fName, status='old', position='append')
        end if
        write(unitUSER,AFORMAT) SPACE, 'RECORD CHANGE BY: '// &
            trim(USERNAME)//' : '//REMOTE_ADDR//' : '//currentDate//DASH//currentTime, trim(mesg)
        close(unitUSER)

    end subroutine log_record_change


    subroutine log_student_record_change(std, mesg)

        integer, intent (in) :: std
        character (len=*), intent (in) :: mesg

        integer :: idx

        idx = year_prefix(Student(std))
        fileName = trim(dirLOG)//trim(Student(std)%StdNo(1:idx))//DIRSEP//trim(Student(std)%StdNo)//'.log'
        call log_record_change(fileName, mesg)

    end subroutine log_student_record_change


    subroutine log_teacher_record_change(fac, mesg)

        integer, intent (in) :: fac
        character (len=*), intent (in) :: mesg

        fileName = trim(dirLOG)//trim(College(Department(Teacher(fac)%DeptIdx)%CollegeIdx)%Code)//DIRSEP// &
            trim(Teacher(fac)%TeacherId)//'.log'
        call log_record_change(fileName, mesg)

    end subroutine log_teacher_record_change

