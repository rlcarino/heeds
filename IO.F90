!======================================================================
!
!    HEEDS (Higher Education Enrollment Decision Support) - A program
!      to create enrollment scenarios for 'next term' in a university
!    Copyright (C) 2012, 2013 Ricolindo L. Carino
!
!    This file is part of the HEEDS program.
!
!    HEEDS is free software: you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    (at your option) any later version.
!
!    HEEDS is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU General Public License for more details.
!
!    You should have received a copy of the GNU General Public License
!    along with this program (see the file COPYING.TXT). If not, see
!    <http://www.gnu.org/licenses/>.
!
!    Send inquiries about HEEDS to:
!      Ricolindo L Carino
!      E-mail: Ricolindo.Carino@AcademicForecasts.com
!      Address: 600 Cruise St., Starkville, MS 39759, U.S.A.
!
!======================================================================


module IO

    use UNIVERSITY

    implicit none

    ! private tokens
    character (len=MAX_LEN_FILE_PATH), private :: fileName
    character (len=MAX_LEN_XML_LINE), private :: line, value
    character (len=MAX_LEN_XML_TAG), private :: tag
    integer, private :: eof, ndels, pos(30)


contains


!===========================================================
! routines for University-level data
!===========================================================



    subroutine read_university(path, errNo)

        character(len=*), intent(in) :: path
        integer, intent (out) :: errNo

        errNo = -1 ! assume not there
        if (hasCATALOG) then
            call xml_read_university(trim(path)//'CATALOG.XML', errNo) ! try the consolidated file
        end if
        if (errNo/=0) then
            call xml_read_university(trim(path)//'UNIVERSITY.XML', errNo) ! try the XML file
        end if

    end subroutine read_university



    subroutine xml_read_university(pathToFile, errNo)

        character(len=*), intent(in) :: pathToFile
        integer, intent (out) :: errNo

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_UNIVERSITY, pathToFile, errNo)
        if (errNo/=0) return

        ! examine the file line by line
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('/'//XML_ROOT_UNIVERSITY)
                    exit

                case ('NAME')
                    UniversityName = adjustl(value)

                case ('ADDRESS')
                    UniversityAddress = adjustl(value)

                case ('BASEYEAR')
                    baseYear = atoi(value)

                case ('PRESIDENT')
                    UniversityPresident = adjustl(value)

                case ('DEANOFINSTRUCTION')
                    DeanOfInstruction = adjustl(value)

                case ('VPACADEMICAFFAIRS')
                    VPAcademicAffairs = adjustl(value)

                case ('DEANOFCAMPUS')
                    DeanOfCampus = adjustl(value)

                case ('ADMINISTRATION')
                    ADMINISTRATION = adjustl(value)

                case ('REGISTRAR')
                    REGISTRAR = adjustl(value)

                case default ! do nothing

            end select

        end do

        close(unitXML)
        call log_comment('From '//pathTofile, trim(UniversityName)//' @ '//UniversityAddress)

    end subroutine xml_read_university



    subroutine xml_write_university(pathToFile)

        character(len=*), intent(in) :: pathToFile

        ! training only?
        if (noWrites) return

        open(unit=unitXML, file=pathToFile, status='unknown')
        write(unitXML,AFORMAT) XML_DOC

        call xml_university(unitXML)

        close(unitXML)

    end subroutine xml_write_university



    subroutine xml_university(unitXML)

        integer, intent(in) :: unitXML

        write(unitXML,AFORMAT) '<'//XML_ROOT_UNIVERSITY//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '    </comment>'
        call xml_write_character(unitXML, indent0, 'NAME', UniversityName)
        call xml_write_character(unitXML, indent0, 'ADDRESS', UniversityAddress)
        call xml_write_character(unitXML, indent0, 'PRESIDENT', UniversityPresident)
        call xml_write_character(unitXML, indent0, 'DEANOFINSTRUCTION', DeanOfInstruction)
        call xml_write_character(unitXML, indent0, 'VPACADEMICAFFAIRS', VPAcademicAffairs)
        call xml_write_character(unitXML, indent0, 'DEANOFCAMPUS', DeanOfCampus)
        call xml_write_integer  (unitXML, indent0, 'BASEYEAR', baseYear)
        call xml_write_character(unitXML, indent0, 'ADMINISTRATION', ADMINISTRATION)
        call xml_write_character(unitXML, indent0, 'REGISTRAR', REGISTRAR)
        write(unitXML,AFORMAT) '</'//XML_ROOT_UNIVERSITY//'>'

    end subroutine xml_university


!===========================================================
! routines for College()
!===========================================================


    subroutine read_colleges(path, errNo)

        character(len=*), intent(in) :: path
        integer, intent (out) :: errNo

        NumColleges = 0
        call initialize_college (College(0))
        College(1:) = College(0)

        errNo = -1 ! assume not there
        if (hasCATALOG) then
            call xml_read_colleges(trim(path)//'CATALOG.XML', errNo) ! try the consolidated file
        end if
        if (errNo/=0) then
            call xml_read_colleges(trim(path)//'COLLEGES.XML', errNo) ! try the XML file
            if (errNo/=0) return ! cannot proceed
        end if

        ! add 'administrative' college for data that does not fit in the 'academic' colleges
        NumColleges = NumColleges + 1
        call initialize_college (College(NumColleges), &
            ADMINISTRATION, UniversityCode//' Administration', UniversityPresident)

    end subroutine read_colleges



    subroutine xml_read_colleges(pathToFile, errNo)

        character(len=*), intent(in) :: pathToFile
        integer, intent (out) :: errNo

        type(TYPE_COLLEGE) :: wrkCollege

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_COLLEGES, pathToFile, errNo)
        if (errNo/=0) return

        ! examine the file line by line
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('/'//XML_ROOT_COLLEGES)
                    exit

                case ('College') ! initialize temporary college data
                    call initialize_college (wrkCollege)

                case ('Code')
                    wrkCollege%Code = adjustl(value)

                case ('Name')
                    wrkCollege%Name = adjustl(value)

                case ('Dean')
                    wrkCollege%Dean = adjustl(value)

                case ('/College') ! add temporary college data to College()
                    if (index(wrkCollege%Code,trim(ADMINISTRATION))>0) cycle ! add later
                    NumColleges = NumColleges + 1
                    call check_array_bound (NumColleges, MAX_ALL_COLLEGES, 'MAX_ALL_COLLEGES')
                    College(NumColleges) = wrkCollege

                case default ! do nothing

            end select

        end do

        close(unitXML)
        call log_comment (itoa(NumColleges)//' colleges in '//pathTofile)

    end subroutine xml_read_colleges



    subroutine xml_write_colleges(pathToFile)

        character(len=*), intent(in) :: pathToFile

        ! training only?
        if (noWrites) return

        open(unit=unitXML, file=pathToFile, status='unknown')
        write(unitXML,AFORMAT) XML_DOC

        call xml_colleges(unitXML)

        close(unitXML)

    end subroutine xml_write_colleges



    subroutine xml_colleges(unitXML)

        integer, intent(in) :: unitXML

        integer :: ldx

        write(unitXML,AFORMAT) '<'//XML_ROOT_COLLEGES//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        Code - college code', &
            '        Name - long name of college', &
            '        Dean - signatory for college (Firstname MI Lastname, PhD)', &
            '    </comment>'

        do ldx = 1,NumColleges-1 ! exclude ADMINISTRATION
            call xml_write_character(unitXML, indent0, 'College')
            call xml_write_character(unitXML, indent1, 'Code', College(ldx)%Code)
            call xml_write_character(unitXML, indent1, 'Name', College(ldx)%Name)
            call xml_write_character(unitXML, indent1, 'Dean', College(ldx)%Dean)
            call xml_write_character(unitXML, indent0, '/College')
        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_COLLEGES//'>'

    end subroutine xml_colleges


!===========================================================
! routines for Department()
!===========================================================



    subroutine read_departments(path, errNo)

        character(len=*), intent(in) :: path
        integer, intent (out) :: errNo

        call initialize_department (Department(0))
        Department(2:) = Department(0)
        Department(0)%Code = 'ERROR'
        Department(0)%Name = '(ERROR)'
        Department(1)%Code = '(dummy)'
        Department(1)%Name = '(dummy)'
        NumDepartments = 1
        ScheduleCount = 0

        errNo = -1 ! assume not there
        if (hasCATALOG) then
            call xml_read_departments(trim(path)//'CATALOG.XML', errNo) ! try the consolidated file
        end if
        if (errNo/=0) then
            call xml_read_departments(trim(path)//'DEPARTMENTS.XML', errNo) ! try the XML file
            if (errNo/=0) return ! cannot proceed
        end if

        ! add REGISTAR as 'administrative' department for data that does not fit in the 'academic' departments
        NumDepartments = NumDepartments + 1
        call initialize_department (Department(NumDepartments), &
            REGISTRAR, trim(UniversityCode)//' Registrar', '#', NumColleges)

    end subroutine read_departments



    subroutine xml_read_departments(pathToFile, errNo)

        character(len=*), intent(in) :: pathToFile
        integer, intent (out) :: errNo

        integer :: j
        type(typeDEPARTMENT) :: wrkDepartment
        character (len=MAX_LEN_COLLEGE_CODE) :: tColl

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_DEPARTMENTS, pathToFile, errNo)
        if (errNo/=0) return

        ! examine the file line by line
        do

            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('/'//XML_ROOT_DEPARTMENTS)
                    exit

                case ('Department') ! initialize temporary department data
                    call initialize_department (wrkDepartment)

                case ('Code')
                    wrkDepartment%Code = adjustl(value)

                case ('Name')
                    wrkDepartment%Name = adjustl(value)

                case ('College')
                    tColl = adjustl(value)
                    j = index_to_college(tColl)
                    if (j==0) j = NumColleges ! use ADMINISTRATION for invalid college code
                    wrkDepartment%CollegeIdx = j

                case ('SectionPrefix')
                    wrkDepartment%SectionPrefix = adjustl(value)

                case ('/Department') ! add temporary department data to Department()
                    if (index(wrkDepartment%Code,trim(REGISTRAR))>0) cycle ! add at the end
                    NumDepartments = NumDepartments + 1
                    call check_array_bound (NumDepartments, MAX_ALL_DEPARTMENTS, 'MAX_ALL_DEPARTMENTS')
                    Department(NumDepartments) = wrkDepartment

                case default
                   ! do nothing

            end select

        end do

        close(unitXML)
        call log_comment (itoa(NumDepartments)//' departments in '//pathToFile)

    end subroutine xml_read_departments



    subroutine xml_write_departments(pathToFile)

        character(len=*), intent(in) :: pathToFile

        ! training only?
        if (noWrites) return

        open(unit=unitXML, file=pathToFile, status='unknown')
        write(unitXML,AFORMAT) XML_DOC

        call xml_departments(unitXML)

        close(unitXML)

    end subroutine xml_write_departments



    subroutine xml_departments(unitXML)

        integer, intent(in) :: unitXML
        integer :: ldx

        write(unitXML,AFORMAT) '<'//XML_ROOT_DEPARTMENTS//'>', &
        '    <comment>', &
        '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                    FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
        '        Code - department code', &
        '        Name - long name of department', &
        '        College - mother unit of the department', &
        '        SectionPrefix - prefix of codes for classes in this department', &
        '    </comment>'

        do ldx = 2,NumDepartments-1
            call xml_write_character(unitXML, indent0, 'Department')
            call xml_write_character(unitXML, indent1, 'Code', Department(ldx)%Code)
            call xml_write_character(unitXML, indent1, 'Name', Department(ldx)%Name)
            call xml_write_character(unitXML, indent1, 'College', College(Department(ldx)%CollegeIdx)%Code)
            if (Department(ldx)%SectionPrefix/=SPACE) &
                call xml_write_character(unitXML, indent1, 'SectionPrefix', Department(ldx)%SectionPrefix)
            call xml_write_character(unitXML, indent0, '/Department')
        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_DEPARTMENTS//'>'

    end subroutine xml_departments


!===========================================================
! routines for rooms
!===========================================================


    subroutine read_rooms(path, errNo)

        character(len=*), intent(in) :: path
        integer, intent (out) :: errNo
        integer :: iDept

        NumRooms = 0
        NumAdditionalRooms = 0
        call initialize_room (Room(0))
        Room = Room(0)
        Room(0)%Code = 'TBA' ! for 'Room not found!'

        errNo = -1 ! assume not there
        if (hasCATALOG) then
            call xml_read_rooms(trim(path)//'CATALOG.XML', errNo) ! try the consolidated file
        end if
        if (errNo/=0) then
            call xml_read_rooms(trim(path)//'ROOMS.XML', errNo) ! try the XML file
        end if
        if (NumRooms==0) then ! something still wrong
            do iDept=2,NumDepartments-1 ! create rooms for each department
                NumRooms = NumRooms+1
                call initialize_room(Room(NumRooms), trim(Department(iDept)%Code)//' Room', &
                    iDept, 0, 0)
            end do
            errNo = 0
        end if

    end subroutine read_rooms



    subroutine xml_read_rooms(pathToFile, errNo)

        character(len=*), intent(in) :: pathToFile
        integer, intent (out) :: errNo

        integer :: j
        type(TYPE_ROOM) :: wrkRoom
        character (len=MAX_LEN_DEPARTMENT_CODE) :: tDept

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_ROOMS, pathToFile, errNo)
        if (errNo/=0) return

        ! examine the file line by line
        do

            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('/'//XML_ROOT_ROOMS)
                    exit

                case ('Room') ! initialize temporary room data
                    call initialize_room (wrkRoom)

                case ('Code')
                    wrkRoom%Code = adjustl(value)

                case ('Department')
                    tDept = adjustl(value)
                    j = index_to_dept(tDept)
                    if (j==0) j = NumDepartments ! use REGISTRAR if tDept not in list of departments
                    wrkRoom%DeptIdx = j

                case ('Cluster')
                    wrkRoom%Cluster = atoi(value)

                case ('MaxCapacity')
                    wrkRoom%MaxCapacity = atoi(value)

                case ('/Room') ! add temporary room data to Room()
                    if (trim(wrkRoom%Code)==SPACE) cycle
                    NumRooms = NumRooms + 1
                    call check_array_bound (NumRooms, MAX_ALL_ROOMS, 'MAX_ALL_ROOMS')
                    Room(NumRooms) = wrkRoom

                    Department(wrkRoom%DeptIdx)%hasInfo = .true.

                case default
                ! do nothing

            end select

        end do
        close(unitXML)

        !call sort_rooms()
        call log_comment (itoa(NumRooms)//' rooms in '//pathToFile)

    end subroutine xml_read_rooms



    subroutine xml_write_rooms(pathToFile)

        character(len=*), intent(in) :: pathToFile

        ! training only?
        if (noWrites) return

        open(unit=unitXML, file=pathToFile, status='unknown')
        write(unitXML,AFORMAT) XML_DOC

        call xml_rooms(unitXML)

        close(unitXML)

    end subroutine xml_write_rooms



    subroutine xml_rooms(unitXML)

        integer, intent(in) :: unitXML
        integer :: ldx

        write(unitXML,AFORMAT) '<'//XML_ROOT_ROOMS//'>', &
        '    <comment>', &
        '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                    FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
        '        Code - room code', &
        '        Department - responsible department', &
        '        Cluster - rooms with the same cluster are "within walking distance" of each other', &
        '        MaxCapacity- maximum seating capacity', &
        '    </comment>'

        do ldx = 1,NumRooms+NumAdditionalRooms
            if (trim(Room(ldx)%Code)==SPACE) cycle
            call xml_write_character(unitXML, indent0, 'Room')
            call xml_write_character(unitXML, indent1, 'Code', Room(ldx)%Code)
            call xml_write_character(unitXML, indent1, 'Department', Department(Room(ldx)%DeptIdx)%Code)
            call xml_write_integer(unitXML, indent1, 'Cluster', Room(ldx)%Cluster)
            call xml_write_integer(unitXML, indent1, 'MaxCapacity', Room(ldx)%MaxCapacity)
            call xml_write_character(unitXML, indent0, '/Room')
        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_ROOMS//'>'

    end subroutine xml_rooms



!===========================================================
! routines for teachers
!===========================================================



    subroutine read_teachers(path, errNo)

        character(len=*), intent(in) :: path
        integer, intent (out) :: errNo
        integer :: k

        NumTeachers = 0
        NumAdditionalTeachers = 0

        call initialize_teacher(Teacher(0))
        Teacher = Teacher(0)
        Teacher(0)%TeacherId = 'TBA'
        Teacher(0)%Name = '(Teacher to be assigned)'

        errNo = -1 ! assume not there
        if (hasCATALOG) then
            call xml_read_teachers(trim(path)//'CATALOG.XML', errNo) ! try the consolidated file
        end if
        if (errNo/=0) then
            call xml_read_teachers(trim(path)//'TEACHERS.XML', errNo) ! try the XML file
        end if
        if (NumTeachers==0) then ! create scheduler roles
            do k=2,NumDepartments
                NumTeachers = NumTeachers+1
                Teacher(NumTeachers)%TeacherID = Department(k)%Code
                Teacher(NumTeachers)%DeptIdx = NumDepartments
                Teacher(NumTeachers)%Role = Department(k)%Code
                Teacher(NumTeachers)%Name = trim(Department(k)%Code)//' Scheduler'
                Teacher(NumTeachers)%MaxLoad = 0
                Teacher(NumTeachers)%Specialization = 'Scheduling'
                call set_password(Teacher(NumTeachers)%Password)
            end do
        end if

        call sort_alphabetical_teachers()

        ! the Guest account
        Teacher(NumTeachers+1)%TeacherID = GUEST
        k = index_to_teacher(Teacher(NumTeachers+1)%TeacherID)
        if (k==0) then ! not found
            k = NumTeachers+1
            NumTeachers = k
            Teacher(k)%Name = 'Guest Account'
            Teacher(k)%DeptIdx = NumDepartments
            Teacher(k)%Role = GUEST
            call set_password(Teacher(k)%Password, GUEST)
        end if

    end subroutine read_teachers


    subroutine xml_read_teachers(pathToFile, errNo)

        character(len=*), intent(in) :: pathToFile
        integer, intent (out) :: errNo

        integer :: i, j
        type(TYPE_TEACHER) :: wrkTeacher
        character (len=MAX_LEN_DEPARTMENT_CODE) :: tDept
        character (len=MAX_LEN_STEP_IN_RANK) :: tStep
        character (len=MAX_LEN_ACADEMIC_RANK) :: tRank

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_TEACHERS, pathToFile, errNo)
        if (errNo/=0) return

        ! examine the file line by line
        do

            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('/'//XML_ROOT_TEACHERS)
                    exit

                case ('Teacher') ! initialize temporary teacher data
                    call initialize_teacher(wrkTeacher)

                case ('TeacherId')
                    wrkTeacher%TeacherId = adjustl(value)

                case ('Name')
                    call upper_case(value)
                    wrkTeacher%Name = adjustl(value)

                case ('Department')
                    tDept = adjustl(value)
                    j = index_to_dept(tDept)
                    if (j==0) j = NumDepartments ! use REGISTRAR for invalid department code
                    wrkTeacher%DeptIdx = j

                ! read additional info here in case file has the old format
                case ('MaxLoad')
                    wrkTeacher%MaxLoad = atoi(value)

                case ('Rank')
                    tRank = adjustl(value)
                    j = 0
                    do i=1,4
                        if (tRank/=AcademicRank(i)) cycle
                        j = i
                        exit
                    end do
                    wrkTeacher%Rank = j

                case ('Step')
                    tStep = adjustl(value)
                    j = 0
                    do i=1,12
                        if (tStep/=RankStep(i)) cycle
                        j = i
                        exit
                    end do
                    wrkTeacher%Step = j

                case ('Bachelor')
                    wrkTeacher%Bachelor = adjustl(value)

                case ('Master')
                    wrkTeacher%Master = adjustl(value)

                case ('Doctorate')
                    wrkTeacher%Doctorate = adjustl(value)

                case ('Specialization')
                    wrkTeacher%Specialization = adjustl(value)

                case ('Password')
                    wrkTeacher%Password = adjustl(value)

                case ('Role')
                    wrkTeacher%Role = adjustl(value)

                case ('/Teacher') ! add/merge temporary teacher data to Teacher()
                    if (len_trim(wrkTeacher%TeacherId)==0) cycle
                    if (len_trim(wrkTeacher%Name)==0) cycle
                    if (len_trim(wrkTeacher%Password)==0) call set_password(wrkTeacher%Password)
                    ! teacher encountered previously?
                    i = 0
                    do j=1,NumTeachers
                        if (wrkTeacher%TeacherId/=Teacher(j)%TeacherId) cycle
                        i = j
                        exit
                    end do
                    if (i/=0) then ! overwrite existing record
                        call log_comment ('Duplicate record for '//trim(wrkTeacher%TeacherId)//'; updated.')
                        Teacher(i) = wrkTeacher
                    else
                        NumTeachers = NumTeachers + 1
                        call check_array_bound (NumTeachers, MAX_ALL_TEACHERS, 'MAX_ALL_TEACHERS')
                        Teacher(NumTeachers) = wrkTeacher
                        if (wrkTeacher%TeacherID/=wrkTeacher%Role) Department(wrkTeacher%DeptIdx)%hasInfo = .true.
                    end if

                case default
                    ! do nothing
            end select

        end do

        close(unitXML)
        call log_comment (itoa(NumTeachers)//' teachers in '//pathTofile)

        call sort_teachers()

    end subroutine xml_read_teachers



    subroutine xml_write_teachers(pathToFile)

        character(len=*), intent(in) :: pathToFile

        ! training only?
        if (noWrites) return

        open(unit=unitXML, file=pathToFile, status='unknown')
        write(unitXML,AFORMAT) XML_DOC

        call xml_teachers(unitXML)

        close(unitXML)

    end subroutine xml_write_teachers



    subroutine xml_teachers(unitXML)

        integer, intent(in) :: unitXML

        integer :: ldx

        write(unitXML,AFORMAT) '<'//XML_ROOT_TEACHERS//'>', &
        '    <comment>', &
        '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                    FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
        '        TeacherId - teacher code', &
        '        Name - name of teacher', &
        '        Department - responsible department', &
        '    </comment>'

        do ldx = 1,NumTeachers+NumAdditionalTeachers
            if (trim(Teacher(ldx)%TeacherId)==SPACE) cycle
           if (len_trim(Teacher(ldx)%Password)==0) call set_password(Teacher(ldx)%Password)

            call xml_write_character(unitXML, indent0, 'Teacher')
            call xml_write_character(unitXML, indent1, 'TeacherId', Teacher(ldx)%TeacherId)
            call xml_write_character(unitXML, indent1, 'Name', Teacher(ldx)%Name)
            call xml_write_character(unitXML, indent1, 'Department', Department(Teacher(ldx)%DeptIdx)%Code)
            if (Teacher(ldx)%MaxLoad>0) &
                call xml_write_integer(unitXML, indent1, 'MaxLoad', Teacher(ldx)%MaxLoad)
            if (Teacher(ldx)%Rank>0) &
                call xml_write_character(unitXML, indent1, 'Rank', AcademicRank(Teacher(ldx)%Rank))
            if (Teacher(ldx)%Step>0) &
                call xml_write_character(unitXML, indent1, 'Step', RankStep(Teacher(ldx)%Step))
            if (Teacher(ldx)%Bachelor/=SPACE) &
                call xml_write_character(unitXML, indent1, 'Bachelor', Teacher(ldx)%Bachelor)
            if (Teacher(ldx)%Master/=SPACE) &
                call xml_write_character(unitXML, indent1, 'Master', Teacher(ldx)%Master)
            if (Teacher(ldx)%Doctorate/=SPACE)  &
                call xml_write_character(unitXML, indent1, 'Doctorate', Teacher(ldx)%Doctorate)
            if (Teacher(ldx)%Specialization/=SPACE)  &
                call xml_write_character(unitXML, indent1, 'Specialization', Teacher(ldx)%Specialization)
            call xml_write_character(unitXML, indent1, 'Password', Teacher(ldx)%Password)
            if (Teacher(ldx)%Role/=SPACE)  &
                call xml_write_character(unitXML, indent1, 'Role', Teacher(ldx)%Role)
            call xml_write_character(unitXML, indent0, '/Teacher')

        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_TEACHERS//'>'

    end subroutine xml_teachers


!===========================================================
! routines for subjects
!===========================================================



    subroutine get_subject_areas()

        character (len=MAX_LEN_SUBJECT_CODE) :: token
        integer :: i, j, k

        NumSubjectAreas = 0
        SubjectArea = TYPE_SUBJECT_AREA (SPACE, 0, 0)
        do i=1,NumSubjects+NumAdditionalSubjects
            token = Subject(i)%Name
            j = index(token, SPACE)
            token(j:) = SPACE
            ! find token if it already exists
            k = 0
            do j=NumSubjectAreas,1,-1
                if (SubjectArea(j)%Code/=token) cycle
                k = j
                exit
            end do
            if (k==0) then ! not found
                call check_array_bound (NumSubjectAreas+1, MAX_ALL_SUBJECTS/3, 'NumSubjectAreas')
                NumSubjectAreas = NumSubjectAreas+1
                SubjectArea(NumSubjectAreas) = TYPE_SUBJECT_AREA(token, Department(Subject(i)%DeptIdx)%CollegeIdx, 1)
            else
                SubjectArea(k)%Count = SubjectArea(k)%Count + 1
            end if
        end do
    end subroutine get_subject_areas


    subroutine read_subjects(path, errNo)

        character(len=*), intent(in) :: path
        integer, intent (out) :: errNo

        NumDummySubjects = -1
        NumSubjects = 0
        NumAdditionalSubjects = 0
        NumRenames = 0
        Renamed = 0

        call initialize_subject (Subject(0))
        Subject = Subject(0)
        Subject(-1)%Name = '(dummy)'
        Subject(-1)%Title = '(dummy)'
        INDEX_TO_NONE = -1 ! fix after reading in all subject codes

        errNo = -1 ! assume not there
        if (hasCATALOG) then
            call xml_read_subjects(trim(path)//'CATALOG.XML', errNo) ! try the consolidated file
        end if
        if (errNo/=0) then
            call xml_read_subjects(trim(path)//'SUBJECTS.XML', errNo) ! try the XML file
            if (errNo/=0) return ! something still wrong
        end if

        ! subject areas
        call get_subject_areas()

        ! fail rates
        call xml_read_failrates(trim(path)//'FAILRATES.XML', eof) ! try the XML file

    end subroutine read_subjects



    subroutine xml_read_subjects(pathToFile, errNo)

        character(len=*), intent(in) :: pathToFile
        integer, intent (out) :: errNo

        integer :: i, j, k, l
        type(TYPE_SUBJECT) :: wrkSubject
        character (len=MAX_LEN_DEPARTMENT_CODE) :: tDept
        character (len=MAX_LEN_SUBJECT_CODE) :: token

        ! open file for basic info on subjects, return on any error
        call xml_read_file(unitXML, XML_ROOT_SUBJECTS, pathToFile, errNo)
        if (errNo/=0) return

        ! read subject code & responsible department
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('/'//XML_ROOT_SUBJECTS)
                    exit

                case ('Subject') ! initialize temporary subject data
                    call initialize_subject (wrkSubject)

                case ('Code')
                    wrkSubject%Name = adjustl(value)

                case ('Department')
                    tDept = adjustl(value)
                    j = index_to_dept(tDept)
                    if (j/=0) wrkSubject%DeptIdx = j

                case ('/Subject') ! add temporary subject data to Subject()
                    ! no subject code ?
                    if (trim(wrkSubject%Name)==SPACE) cycle
                    ! duplicate subject ?
                    i = index_to_subject(wrkSubject%Name)
                    if (i/=0) cycle ! duplicate

                    ! not a dummy subject
                    Department(wrkSubject%DeptIdx)%hasInfo = .true.

                    if (wrkSubject%DeptIdx>1) then
                        NumSubjects = NumSubjects + 1
                        call check_array_bound (NumSubjects, MAX_ALL_SUBJECTS, 'MAX_ALL_SUBJECTS')
                        i = NumSubjects
                        do while (wrkSubject%Name<Subject(i-1)%Name)
                            Subject(i)%Name = Subject(i-1)%Name
                            i = i-1
                        end do
                        Subject(i)%Name = wrkSubject%Name

                    elseif (wrkSubject%DeptIdx==1) then ! dummy subject
                        NumDummySubjects = NumDummySubjects-1
                        Subject(NumDummySubjects)%Name = wrkSubject%Name

                    end if

                case default
                ! do nothing

            end select

        end do
        close(unitXML)

        call log_comment (itoa(NumSubjects)//' subjects in '//pathTofile)

        ! fix INDEX_TO_NONE
        token = 'NONE'
        INDEX_TO_NONE = index_to_subject(token)
        Subject(:)%Prerequisite(1) = INDEX_TO_NONE
        Subject(:)%Corequisite(1) = INDEX_TO_NONE
        Subject(:)%Concurrent(1) = INDEX_TO_NONE
        Subject(:)%ConcPrerequisite(1) = INDEX_TO_NONE

        ! read the rest of subject basic info
        call xml_read_file(unitETC, XML_ROOT_SUBJECTS, pathToFile, eof)
        do
            read(unitETC, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('/'//XML_ROOT_SUBJECTS)
                    exit

                case ('Subject') ! initialize temporary subject data
                    call initialize_subject (wrkSubject)

                case ('Code')
                    wrkSubject%Name = adjustl(value)

                case ('Title')
                    wrkSubject%Title = adjustl(value)

                case ('Department')
                    tDept = adjustl(value)
                    wrkSubject%DeptIdx = index_to_dept(tDept)

                case ('Units')
                    wrkSubject%Units = atof(value)

                case ('Enrollment')
                    call index_to_delimiters(COMMA, value, ndels, pos)
                    do k=1,6,2 !  1st term, 2nd term, summer
                        l = (k+1)/2
                        i = atoi(value(pos(k)+1:pos(k+1)-1)) ! pass
                        j = atoi(value(pos(k+1)+1:pos(k+2)-1)) ! fail
                        wrkSubject%GrandTotal(1,l) = i
                        wrkSubject%GrandTotal(2,l) = j
                        wrkSubject%Failrate(l) = (1.0*j)/max(1,i+j)
                    end do

                case ('TermOffered')
                    wrkSubject%TermOffered = 0
                    if (index(value, '1')>0) wrkSubject%TermOffered = wrkSubject%TermOffered+1
                    if (index(value, '2')>0) wrkSubject%TermOffered = wrkSubject%TermOffered+2
                    if (index(value, 'S')>0) wrkSubject%TermOffered = wrkSubject%TermOffered+4

                case ('LectHours')
                    wrkSubject%LectHours = atof(value)

                case ('MinLectSize')
                    wrkSubject%MinLectSize = atoi(value)

                case ('MaxLectSize')
                    wrkSubject%MaxLectSize = atoi(value)

                case ('LabHours')
                    wrkSubject%LabHours = atof(value)

                case ('MinLabSize')
                    wrkSubject%MinLabSize = atoi(value)

                case ('MaxLabSize')
                    wrkSubject%MaxLabSize = atoi(value)

                ! read the additional info also, in case the file has the old format
                case ('LabFee')
                    wrkSubject%LabFee = atof(value)

                case ('Tuition')
                    wrkSubject%Tuition = atof(value)

                case ('LectLoad')
                    wrkSubject%LectLoad = atof(value)

                case ('LabLoad')
                    wrkSubject%LabLoad = atof(value)

                case ('Prerequisite')
                    call tokenize_subjects(value, '+', MAX_ALL_SUBJECT_PREREQ, &
                        wrkSubject%lenPreq, wrkSubject%Prerequisite, eof)
                    if (eof>0) exit

                case ('Corequisite')
                    call tokenize_subjects(value, '+', MAX_ALL_SUBJECT_COREQ, &
                        wrkSubject%lenCoreq, wrkSubject%Corequisite, eof)
                    if (eof>0) exit
                    if (wrkSubject%lenCoreq>0 .and. Subject(wrkSubject%Corequisite(1))%Name/='NONE') then
                        call log_comment(trim(wrkSubject%Name)//' has co-requisite '// &
                            Subject(wrkSubject%Corequisite(1))%Name ) ! , j=1,wrkSubject%lenCoreq)
                    end if

                case ('ConcurrentWith')
                    call tokenize_subjects(value, '+', MAX_ALL_SUBJECT_CONCURRENT, wrkSubject%lenConc, wrkSubject%Concurrent, eof)
                    if (eof>0) exit
                    if (wrkSubject%lenConc>0 .and. Subject(wrkSubject%Concurrent(1))%Name/='NONE') then
                        call log_comment(trim(wrkSubject%Name)//' is concurrent with '// &
                            Subject(wrkSubject%Concurrent(1))%Name ) !, j=1,wrkSubject%lenConc)
                    end if

                case ('ConcurrentPrerequisite')
                    call tokenize_subjects(value, '+', MAX_ALL_SUBJECT_CONCPREQ, wrkSubject%lenConcPreq, &
                    wrkSubject%ConcPrerequisite, eof)
                    if (eof>0) exit
                    if (wrkSubject%lenConcPreq>0 .and. Subject(wrkSubject%ConcPrerequisite(1))%Name/='NONE') then
                        call log_comment(trim(wrkSubject%Name)//' has pre-req that can be concurrent : '// &
                           Subject(wrkSubject%ConcPrerequisite(1))%Name) ! , j=1,wrkSubject%lenConcPreq)
                    end if

                case ('/Subject') ! add temporary subject data to Subject()
                    i = index_to_subject(wrkSubject%Name)
                    !wrkSubject%TermOffered = 7 ! HARDCODE
                    Subject(i) = wrkSubject

                case default
                    ! do nothing

            end select

        end do

        close(unitETC)

    end subroutine xml_read_subjects



    subroutine xml_write_subjects(pathToFile)

        character(len=*), intent(in) :: pathToFile

        ! training only?
        if (noWrites) return

        open(unit=unitXML, file=pathToFile, status='unknown')
        write(unitXML,AFORMAT) XML_DOC

        call xml_subjects(unitXML)

        close(unitXML)

    end subroutine xml_write_subjects



    subroutine xml_subjects(unitXML)

        integer, intent(in) :: unitXML
        integer :: subj, i, j
        character(len=255) :: mesg1, mesg2, mesg3, mesg4

        write(unitXML,AFORMAT) '<'//XML_ROOT_SUBJECTS//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        Code - subject identifier', &
            '        Title - subject title', &
            '        Department - responsible department', &
            '        Units - credit to the student', &
            '        Enrollment - #(Pass 1st),#(Fail 1st),#(Pass 2nd),#(Fail 2nd),#(Pass Sum.),#(Fail Sum.)', &
            '            where: #(Pass) = #(Grade>=75) + #(Grade<=3.0); #(Fail) = not Pass', &
            '        TermOffered - 1 for first semester, 2 for second semester, S for summer; or combinations of 1, 2, and S', &
            '        LectHours - no. of lecture hours; 0 if the subject is lab-only', &
            '        MinLectSize - minimum size to open lecture class; 0 if the subject is lab-only', &
            '        MaxLectSize - maximum size to create another lecture class; 0 if the subject is lab-only', &
            '        LabHours - laboratory/recitation/computation class hours; 0 if the subject is lecture-only', &
            '        MinLabSize - minimum size to open lab class; 0 if the subject is lecture-only', &
            '        MaxLabSize - maximum size to create another lab class; 0 if the subject is lecture-only', &
            '        DisplayUnits - how the number of units will be displayed (i.e., 3, 2.0, (1.5) )', &
            '        Tuition - how much a student will pay if he takes the subject', &
            '        LabFee - how much (in addn to Tuition) a student will pay for laboratory fee', &
            '        LectLoad - workload credit to teacher of lecture class', &
            '        LabLoad - workload credit to teacher of laboratory/recitation/computation class', &
            '        Prerequisite - subject prerequisite in prefix format, tokens being separated by "+"', &
            '          possible values are', &
            '            1. NONE', &
            '            2. COI', &
            '            3. Student classification (FRESHMAN, SOPHOMORE, JUNIOR, SENIOR)', &
            '            4. year level in curriculum (FIRST,SECOND,THIRD,FOURTH,FIFTH,GRADUATING)', &
            '            5. subject code - another subject', &
            '            6. OR+2+5, OR+3+5, OR+4+5', &
            '            7. OR+5+5, AND+5+5', &
            '            8. OR+6+6, OR+6+7, OR+7+7, AND+7+7', &
            '        Corequisite - subject co-requisite', &
            '        Concurrent - subject to be concurrently registered', &
            '        ConcurrentPrerequisite - prerequisite that can be registered concurrently', &
            '    </comment>'

        do subj=NumDummySubjects,NumSubjects+NumAdditionalSubjects
            if (subj==-1 .or. subj==0) cycle

            ! prerequisite
            i = Subject(subj)%Prerequisite(1)
            mesg1 = Subject(i)%Name
            do j=2,Subject(subj)%lenPreq
                i = Subject(subj)%Prerequisite(j)
                mesg1 = trim(mesg1)//'+'//Subject(i)%Name
            end do
            ! corequisite
            i = Subject(subj)%Corequisite(1)
            mesg2 = Subject(i)%Name
            do j=2,Subject(subj)%lenCoreq
                i = Subject(subj)%Corequisite(j)
                mesg2 = trim(mesg2)//'+'//Subject(i)%Name
            end do
            ! concurrent
            i = Subject(subj)%Concurrent(1)
            mesg3 = Subject(i)%Name
            do j=2,Subject(subj)%lenConc
                i = Subject(subj)%Concurrent(j)
                mesg3 = trim(mesg3)//'+'//Subject(i)%Name
            end do
            ! prerequisite that can be taken concurrently
            i = Subject(subj)%ConcPrerequisite(1)
            mesg4 = Subject(i)%Name
            do j=2,Subject(subj)%lenConcPreq
                i = Subject(subj)%ConcPrerequisite(j)
                mesg4 = trim(mesg4)//'+'//Subject(i)%Name
            end do

            call xml_write_character(unitXML, indent0, 'Subject')
            call xml_write_character(unitXML, indent1, 'Code', Subject(subj)%Name)
            call xml_write_character(unitXML, indent1, 'Title', Subject(subj)%Title)
            call xml_write_character(unitXML, indent1, 'Department', Department(Subject(subj)%DeptIdx)%Code)
            call xml_write_character(unitXML, indent1, 'TermOffered', text_term_offered(Subject(subj)%TermOffered))
            if (Subject(subj)%Units/=0.0) call xml_write_float(unitXML, indent1, 'Units', Subject(subj)%Units,2)
            if (Subject(subj)%Units>0.0) call xml_write_character(unitXML, indent1, 'DisplayUnits', ftoa(Subject(subj)%Units,2))
            call xml_write_character(unitXML, indent1, 'Enrollment', &
                trim(itoa(Subject(subj)%GrandTotal(1,1)))//COMMA// &
                trim(itoa(Subject(subj)%GrandTotal(2,1)))//COMMA// &
                trim(itoa(Subject(subj)%GrandTotal(1,2)))//COMMA// &
                trim(itoa(Subject(subj)%GrandTotal(2,2)))//COMMA// &
                trim(itoa(Subject(subj)%GrandTotal(1,3)))//COMMA// &
                trim(itoa(Subject(subj)%GrandTotal(2,3))) )
            if (Subject(subj)%Tuition/=0.0) call xml_write_float(unitXML, indent1, 'Tuition', Subject(subj)%Tuition,2)
            if (Subject(subj)%LabFee/=0.0) call xml_write_float(unitXML, indent1, 'LabFee', Subject(subj)%LabFee,2)
            if (Subject(subj)%LectHours/=0.0) call xml_write_float(unitXML, indent1, 'LectHours', Subject(subj)%LectHours,2)
            if (Subject(subj)%MinLectSize/=0) call xml_write_integer(unitXML, indent1, 'MinLectSize', Subject(subj)%MinLectSize)
            if (Subject(subj)%MaxLectSize/=0) call xml_write_integer(unitXML, indent1, 'MaxLectSize', Subject(subj)%MaxLectSize)
            if (Subject(subj)%LectLoad/=0.0) call xml_write_float(unitXML, indent1, 'LectLoad', Subject(subj)%LectLoad,2)
            if (Subject(subj)%LabHours/=0.0) call xml_write_float(unitXML, indent1, 'LabHours', Subject(subj)%LabHours,2)
            if (Subject(subj)%MinLabSize/=0) call xml_write_integer(unitXML, indent1, 'MinLabSize', Subject(subj)%MinLabSize)
            if (Subject(subj)%MaxLabSize/=0) call xml_write_integer(unitXML, indent1, 'MaxLabSize', Subject(subj)%MaxLabSize)
            if (Subject(subj)%LabLoad/=0.0) call xml_write_float(unitXML, indent1, 'LabLoad', Subject(subj)%LabLoad,2)
            if (trim(mesg1)/='NONE') call xml_write_character(unitXML, indent1, 'Prerequisite', mesg1)
            if (trim(mesg2)/='NONE') call xml_write_character(unitXML, indent1, 'Corequisite', mesg2)
            if (trim(mesg3)/='NONE') call xml_write_character(unitXML, indent1, 'ConcurrentWith', mesg3)
            if (trim(mesg4)/='NONE') call xml_write_character(unitXML, indent1, 'ConcurrentPrerequisite', mesg4)

            call xml_write_character(unitXML, indent0, '/Subject')

        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_SUBJECTS//'>'

    end subroutine xml_subjects



    subroutine xml_read_failrates(pathToFile, eof)

        character(len=*), intent(in) :: pathToFile
        integer, intent (out) :: eof

        integer :: cdx, i, j, k, l
        character (len=MAX_LEN_SUBJECT_CODE) :: token

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_FAILRATES, pathToFile, eof)
        if (eof/=0) return
        call log_comment('Reading fail rates from '//pathToFile)

        ! read line by line
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('/'//XML_ROOT_FAILRATES)
                    exit

                case ('Failrate')
                    call index_to_delimiters(COMMA, value, ndels, pos)
                    if (ndels<7) cycle ! not enough data on line
                    token = value(:pos(2)-1)
                    cdx = index_to_subject(token)
                    l = 2 ! start with 2nd token
                    do k=1,3 !  1st term, 2nd term, summer
                        i = atoi(value(pos(l)+1:pos(l+1)-1))
                        j = atoi(value(pos(l+1)+1:pos(l+2)-1))
                        Subject(cdx)%GrandTotal(1,k) = j-i
                        Subject(cdx)%GrandTotal(2,k) = i
                        Subject(cdx)%Failrate(k) = (1.0*i)/max(1,j)
                        ! write(*,*), txtSemester(k), i, j, Enrollment(cdx,k)
                        l = l+2
                    end do

                case default
                ! do nothing

            end select

        end do
        close(unitXML)

    end subroutine xml_read_failrates


!===========================================================
! routines for curricula
!===========================================================


    subroutine read_curricula(path, errNo)

        character(len=*), intent(in) :: path
        integer, intent(out) :: errNo

        !integer :: i, j

        ! initialize
        NumCurricula = 0
        Curriculum = TYPE_CURRICULUM (.true., SPACE, SPACE, SPACE, SPACE, 0, 0, 0, 0, 0)
        NumSubst = 0
        SubstIdx = 0
        Substitution = 0

        errNo = -1 ! assume not there
        if (hasCATALOG) then
            call xml_read_curricula(trim(path)//'CATALOG.XML', errNo) ! try the consolidated file
        end if
        if (errNo/=0) then
            call xml_read_curricula(trim(path)//'CURRICULA.XML', errNo) ! try the XML file
            if (errNo/=0) return ! something still wrong
            call xml_read_equivalencies(path, errNo)
        else
            call xml_read_equivalencies(path, errNo)
        end if
!        write(*,*) 'EQUIVALENCIES'
!        do i=1,NumSubst
!            if (Substitution(SubstIdx(i))<=NumCurricula) then
!                write(*,*) trim(Curriculum(Substitution(SubstIdx(i)))%Code)//' : ', &
!                    (trim(Subject(Substitution(j))%Name)//SPACE, &
!                    j=SubstIdx(i)+1, SubstIdx(i+1)-1)
!            else
!                write(*,*) 'All curricula  ', &
!                    (trim(Subject(Substitution(j))%Name)//SPACE, &
!                    j=SubstIdx(i)+1, SubstIdx(i+1)-1)
!            end if
!        end do

        ! add OTHER
        NumCurricula = NumCurricula + 1
        Curriculum(NumCurricula)%Code = 'OTHER'
        Curriculum(NumCurricula)%CollegeIdx = NumColleges
        Curriculum(NumCurricula)%Title = 'Change curriculum'
        Curriculum(NumCurricula)%Specialization = SPACE
        Curriculum(NumCurricula)%Remark = SPACE
        Curriculum(NumCurricula)%NSubjects = 0
        Curriculum(NumCurricula)%Active = .true.

        call make_curriculum_groups()

    end subroutine read_curricula



    subroutine xml_read_curricula(pathToFile, errNo)

        character(len=*), intent(in) :: pathToFile
        integer, intent (out) :: errNo

        type(TYPE_CURRICULUM) :: tmpCurriculum

        integer :: i, j, k, idxterm, year, term, ierr
        character (len=MAX_LEN_SUBJECT_CODE) :: token
        character (len=MAX_LEN_COLLEGE_CODE) :: tCollege
        character (len=MAX_LEN_TEXT_SEMESTER) :: strTerm
        character (len=MAX_LEN_TEXT_YEAR) :: strYear
        integer :: nLoad, loadArray(MAX_SUBJECTS_PER_TERM)

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_CURRICULA, pathToFile, errNo)
        if (errNo/=0) return

        ! examine the file line by line
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('/'//XML_ROOT_CURRICULA)
                    exit

                case ('Curriculum') ! initialize temporary curriculum data
                    tmpCurriculum = Curriculum(0)

                case ('Code')
                    tmpCurriculum%Code = adjustl(value)

                case ('Title')
                    tmpCurriculum%Title = adjustl(value)

                case ('Specialization')
                    tmpCurriculum%Specialization = adjustl(value)

                case ('Remark')
                    tmpCurriculum%Remark = adjustl(value)

                case ('Status') ! value is ACTIVE or INACTIVE
                    tmpCurriculum%Active = trim(value)=='ACTIVE'

                case ('College') ! value is a college code
                    tCollege = value
                    tmpCurriculum%CollegeIdx = index_to_college(tCollege)

                case ('Load') ! value is empty
                    nLoad = 0
                    loadArray = 0
                    year = -1
                    term = -1

                case ('Year') ! value is one of FIRST, SECOND, THIRD, FOURTH, ...
                    strYear = adjustl(value)
                    call upper_case(strYear)
                    year = index_to_year(strYear)

                case ('Term') ! value is one of FIRST, SECOND, SUMMER
                    strTerm = adjustl(value)
                    call upper_case(strTerm)
                    term = index_to_term(strTerm)

                case ('Subjects') ! value is comma-separated list of subjects
                    call tokenize_subjects(value, ',', MAX_SUBJECTS_PER_TERM, nLoad, loadArray, ierr)

                case ('/Load') ! value is empty
                    if (year>0 .and. term>0) then ! ok
                        ! collect subjects
                        idxTerm = (year-1)*3 + term
                        tmpCurriculum%NumTerms = idxTerm
                        do k = 1,nLoad
                            if (INDEX_TO_NONE==loadArray(k)) cycle
                            token = Subject(loadArray(k))%Name
                            i = index_to_new_subject(loadArray(k))
                            !if (i/=loadArray(k)) &
                            !    call log_comment (tCurriculum//token//' renamed '//Subject(i)%Name)
                            if ( is_offered(i,term) ) then
                                j = tmpCurriculum%NSubjects+1
                                tmpCurriculum%NSubjects = j
                                tmpCurriculum%SubjectIdx(j) = i
                                tmpCurriculum%SubjectTerm(j) = idxTerm
                            else
                                call log_comment (token//': subject not offered during '//strTerm//' Term')
                            !return
                            end if
                        end do
                    end if
                    nLoad = 0
                    loadArray = 0
                    year = -1
                    term = -1

                case ('/Curriculum') ! add temporary curriculum data to Curriculum()
                    if (trim(tmpCurriculum%Code)=='OTHER') cycle ! ignore OTHER
                    if (trim(tmpCurriculum%Code)==SPACE) cycle ! ignore
                    NumCurricula = NumCurricula + 1
                    call check_array_bound (NumCurricula, MAX_ALL_CURRICULA, 'MAX_ALL_CURRICULA')
                    Curriculum(NumCurricula) = tmpCurriculum
                    College(tmpCurriculum%CollegeIdx)%hasInfo = .true.

                    ! if active curriculum, check that prerequisites are taken before successor subjects
                    if (tmpCurriculum%Active) then
                        nLoad = tmpCurriculum%NSubjects
                    else
                        nLoad = 0
                        !write(*,*) 'Not active: '//tmpCurriculum%Code
                    end if
                    do k = 1, nLoad
                        i = tmpCurriculum%SubjectIdx(k)
                        if (.not. is_prerequisite_satisfiable_in_curriculum(i,NumCurricula)) then
                            token = Subject(i)%Name
                            call rank_to_year_term (tmpCurriculum%SubjectTerm(k), year, term)
                            strYear = txtYear(year)
                            strTerm = txtSemester(term)
                            call log_comment (trim(tmpCurriculum%Code)//', '// &
                                trim(strYear)//' year, '//trim(strTerm)//' term, '//trim(token)// &
                                ': preq '//trim(text_prerequisite_in_curriculum(i))//' not specified earlier!')
                        end if
                    end do
                case default
                    ! do nothing
            end select

        end do

        close(unitXML)

        ! sort
        do i=1,NumCurricula-1
            do j=i+1,NumCurricula
                if (Curriculum(i)%Code>Curriculum(j)%Code) then
                    tmpCurriculum = Curriculum(i)
                    Curriculum(i) = Curriculum(j)
                    Curriculum(j) = tmpCurriculum
                end if
            end do
        end do

        call log_comment (itoa(NumCurricula)//' curricula in '//pathToFile)

    end subroutine xml_read_curricula



    subroutine xml_write_curricula(pathToFile)

        character(len=*), intent(in) :: pathToFile

        ! training only?
        if (noWrites) return

        open(unit=unitXML, file=pathToFile, status='unknown')
        write(unitXML,AFORMAT) XML_DOC

        call xml_curricula(unitXML)

        close(unitXML)

    end subroutine xml_write_curricula



    subroutine xml_curricula(unitXML)

        integer, intent(in) :: unitXML
        integer :: idxCOLL, idxCURR, idx, tdx, Year, Term
        character(len=255) :: mesg
        character(len=MAX_LEN_CURRICULUM_CODE) :: tCurriculum

        write(unitXML,AFORMAT) '<'//XML_ROOT_CURRICULA//'>', &
        '    <comment>', &
        '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                    FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
        '        Code - code for the curriculum', &
        '        Title - long name of curriculum', &
        '        Specialization - curriculum option/major area', &
        '        Remark - other info on the curriculum', &
        '        College - responsible college', &
        '        Status - to indicate status of curriculum: ACTIVE or INACTIVE', &
        '        Load, Year, Term, Subjects - Subjects to be taken during (Year, Term)', &
        '            where Year is one of FIRST, SECOND, THIRD, FOURTH, FIFTH', &
        '            and   Term is one of FIRST, SECOND, SUMMER', &
        '        Substitution - to indicate allowed automatic substitutions in this curriculum', &
        '            subjects in this list which are required in the curriculum will', &
        '            be considered "passed" if the rest of the subjects in the list have passing grades;', &
        '            i.e., MATH 11 and MATH 14 can be substituted by MATH I and MATH 17', &
        '    </comment>'

        do idxCURR=1,NumCurricula-1

            idxCOLL = Curriculum(idxCURR)%CollegeIdx

            tCurriculum = Curriculum(idxCURR)%Code
            if (trim(tCurriculum)==SPACE) cycle
            call xml_write_character(unitXML, indent0, 'Curriculum')
            call xml_write_character(unitXML, indent1, 'Code', tCurriculum)
            call xml_write_character(unitXML, indent1, 'Title', Curriculum(idxCURR)%Title)

            if (Curriculum(idxCURR)%Specialization/=SPACE) then
                call xml_write_character(unitXML, indent1, 'Specialization', Curriculum(idxCURR)%Specialization)
            end if

            if (Curriculum(idxCURR)%Remark/=SPACE) then
                call xml_write_character(unitXML, indent1, 'Remark', Curriculum(idxCURR)%Remark)
            end if

            if (Curriculum(idxCURR)%Active) then
                mesg = 'ACTIVE'
            else
                mesg = 'INACTIVE'
            end if
            call xml_write_character(unitXML, indent1, 'Status', mesg)

            call xml_write_character(unitXML, indent1, 'College', College(idxCOLL)%Code)

            do tdx=1,Curriculum(idxCURR)%NumTerms
                call rank_to_year_term(tdx, Year, Term)
                mesg = SPACE
                do idx=1,Curriculum(idxCURR)%NSubjects
                    if (INDEX_TO_NONE==Curriculum(idxCURR)%SubjectIdx(idx)) cycle
                    if (Curriculum(idxCURR)%SubjectTerm(idx) == tdx) then
                        mesg = trim(mesg)//COMMA//Subject(Curriculum(idxCURR)%SubjectIdx(idx))%Name
                    end if
                end do
                if (mesg==SPACE) cycle
                call xml_write_character(unitXML, indent1, 'Load')
                call xml_write_character(unitXML, indent2, 'Year', txtYear(Year))
                call xml_write_character(unitXML, indent2, 'Term', txtSemester(Term))
                call xml_write_character(unitXML, indent2, 'Subjects', mesg(2:))
                call xml_write_character(unitXML, indent1, '/Load')
            end do
            do tdx=1,NumSubst
                if (Substitution(SubstIdx(tdx))==idxCURR) then
                    mesg = SPACE
                    do idx=SubstIdx(tdx)+1, SubstIdx(tdx+1)-1
                        mesg = trim(mesg)//COMMA//Subject(Substitution(idx))%Name
                    end do
                    call xml_write_character(unitXML, indent1, 'Substitution', mesg(2:))
                end if
            end do

            call xml_write_character(unitXML, indent0, '/Curriculum')

        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_CURRICULA//'>'

    end subroutine xml_curricula



    subroutine xml_read_equivalencies(path, errNo)

        character(len=*), intent(in) :: path
        integer, intent (out) :: errNo

        character (len=MAX_LEN_CURRICULUM_CODE) :: tCurriculum
        integer :: idxCURR

        integer :: i, ptrS
        integer :: nLoad, loadArray(MAX_SUBJECTS_PER_TERM)

        ptrS = 0 ! substitutions

        ! open CURRICULUM file, return on any error
        fileName = trim(path)//'CATALOG.XML'
        call xml_read_file(unitXML, XML_ROOT_CURRICULA, fileName, errNo)
        if (errNo/=0) then
            fileName = trim(path)//'CURRICULA.XML'
            call xml_read_file(unitXML, XML_ROOT_CURRICULA, fileName, errNo)
        end if
        if (errNo==0) then
            ! examine the file line by line
            do
                read(unitXML, AFORMAT, iostat=eof) line
                if (eof<0) exit
                if (trim(line)=='</'//XML_ROOT_CURRICULA//'>') exit

                ! get tag and value if any
                call xml_parse_line(line, tag, value, eof)
                if (eof/=0) exit

                select case (trim(tag))

                    case ('Code')
                        tCurriculum = adjustl(value)
                        idxCURR = index_to_curriculum(tCurriculum)

                    case ('Substitution') ! value is comma-separated list of subjects
                        call tokenize_subjects(value, ',', MAX_SUBJECTS_PER_TERM, nLoad, loadArray, errNo)
                        NumSubst = NumSubst + 1
                        ptrS = ptrS+1
                        SubstIdx(NumSubst) = ptrS
                        Substitution(ptrS) = idxCURR
                        do i=1,nLoad
                            ptrS = ptrS+1
                            Substitution(ptrS) = loadArray(i)
                        end do
                    case default
                        ! do nothing
                end select
            end do
            close(unitXML)
        end if

        ! open EQUIVALENCIES file, return on any error
        fileName = trim(path)//'CATALOG.XML'
        call xml_read_file(unitXML, XML_ROOT_EQUIVALENCIES, fileName, errNo)
        if (errNo/=0) then
            fileName = trim(path)//'EQUIVALENCIES.XML'
            call xml_read_file(unitXML, XML_ROOT_EQUIVALENCIES, fileName, errNo)
        end if
        if (errNo==0) then
            ! examine the file line by line
            do
                read(unitXML, AFORMAT, iostat=eof) line
                if (eof<0) exit

                ! get tag and value if any
                call xml_parse_line(line, tag, value, eof)
                if (eof/=0) exit

                select case (trim(tag))

                    case ('/'//XML_ROOT_EQUIVALENCIES)
                        exit

                    case ('Equivalence') ! value is comma-separated list of subjects
                        call tokenize_subjects(value, ',', MAX_SUBJECTS_PER_TERM, nLoad, loadArray, errNo)
                        NumSubst = NumSubst + 1
                        ptrS = ptrS+1
                        SubstIdx(NumSubst) = ptrS
                        Substitution(ptrS) = NumCurricula+2 ! Curriculum(NumCurricula+1) is OTHER
                        do i=1,nLoad
                            ptrS = ptrS+1
                            Substitution(ptrS) = loadArray(i)
                        end do
                    case default
                        ! do nothing
                end select
            end do
            SubstIdx(NumSubst+1) = ptrS+1
            close(unitXML)
        end if

    end subroutine xml_read_equivalencies



    subroutine xml_write_equivalencies(pathToFile)

        character(len=*), intent(in) :: pathToFile

        ! training only?
        if (noWrites) return

        open(unit=unitXML, file=pathToFile, status='unknown')
        write(unitXML,AFORMAT) XML_DOC

        call xml_equivalencies(unitXML)

        close(unitXML)

    end subroutine xml_write_equivalencies



    subroutine xml_equivalencies(unitXML)

        integer, intent(in) :: unitXML
        integer :: idx, tdx
        character(len=255) :: mesg

        write(unitXML,AFORMAT) '<'//XML_ROOT_EQUIVALENCIES//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        Equivalence - to indicate allowed automatic substitutions in all curricula', &
            '            Subjects in a list which are required in a curriculum will', &
            '            be considered "passed" if the rest of the subjects in the list have earned credits', &
            '    </comment>'
        do tdx=1,NumSubst
            if (Substitution(SubstIdx(tdx))>NumCurricula-1) then
                mesg = SPACE
                do idx=SubstIdx(tdx)+1, SubstIdx(tdx+1)-1
                    mesg = trim(mesg)//COMMA//Subject(Substitution(idx))%Name
                end do
                call xml_write_character(unitXML, indent0, 'Equivalence', mesg(2:))
            end if
        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_EQUIVALENCIES//'>'

    end subroutine xml_equivalencies



!===========================================================
! routines for sections
!===========================================================


    subroutine read_classes(path, NumSections, Section, Offering, errNo)

        character(len=*), intent(in) :: path
        type (TYPE_SECTION), intent(in out) :: Section(0:)
        integer, intent (in out) :: NumSections
        type (TYPE_OFFERED_SUBJECTS), intent (in out), dimension (MAX_ALL_DUMMY_SUBJECTS:MAX_ALL_SUBJECTS) :: Offering
        integer, intent (out) :: errNo

        integer :: ierr

        errNo = 0 ! 0 is OK; there might be no classes entered yet

        fileName = trim(path)//'CLASSES.XML'
        call xml_read_classes(fileName, NumSections, Section, ierr)

        ! sort & summarize
        call offerings_sort(NumSections, Section)
        call offerings_summarize(NumSections, Section, Offering, 0)

    end subroutine read_classes


    subroutine xml_read_classes(fName, NumSections, Section, errNo)

        character(len=*), intent(in) :: fName
        type (TYPE_SECTION), intent(in out) :: Section(0:)
        integer, intent (in out) :: NumSections
        integer, intent (out) :: errNo

        integer :: i, j, k
        character(len=MAX_LEN_XML_LINE) :: value
        character(len=MAX_LEN_XML_TAG) :: tag
        type(TYPE_SECTION) :: wrkSection
        integer :: btime, dayidx(6), etime, ndays, iidx, pDASH
        integer :: subj, rmidx, tidx
        character (len = 1) :: ch
        character (len=5) :: strBTime, strETime
        character (len=MAX_LEN_DEPARTMENT_CODE) :: tDept
        character (len=MAX_LEN_SUBJECT_CODE) :: tSubject
        character (len=MAX_LEN_CLASS_ID) :: token
        character (len=MAX_LEN_ROOM_CODE) :: tRoom
        character (len=MAX_LEN_TEACHER_CODE) :: tTeacher
        logical :: flag

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_SECTIONS, fName, errNo)
        if (errNo/=0) then
            call log_comment ('ierr='//itoa(errNo)//' when opening '//fName)
            return
        end if

        ! examine the file line by line
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('/'//XML_ROOT_SECTIONS)
                    exit

                case ('Section') ! initialize temporary section data
                    call initialize_section(wrkSection)

                case ('Subject') ! subject code
                    tSubject = adjustl(value)
                    subj = index_to_subject(tSubject)
                    if (subj<=0) then
                        errNo = 141
                        call log_comment (trim(value)//' : subject not in catalog')
                        return
                    end if
                    wrkSection%SubjectIdx = subj

                case ('Class') ! section code
                    wrkSection%Code = adjustl(value)

                case ('Owner') ! available seats in class
                    tDept = adjustl(value)
                    iidx = index_to_dept (tDept)
                    if (iidx==0) iidx = NumDepartments ! Registrar
                    wrkSection%DeptIdx = iidx

                case ('Seats') ! available seats in class
                    wrkSection%Slots = atoi(value)

                case ('Meeting') ! a meeting
                   ! do nothing for now

                case ('Time') ! begin, end times
                    j = index(value, '-')
                    if (j==0) then ! assume TBA
                        btime = 0
                        etime = 0
                    else
                        strBTime = value(1:j-1)
                        strETime = value(j+1:)
                        btime = index_to_time(strBTime)
                        etime = index_to_time(strETime)
                        if (etime<btime) then ! begin time is later than end time; assume evening class
                            etime = etime+48
                            call log_comment (trim(value)//' - assuming '//strETime//' is evening...')
                        end if
                    end if

                case ('Day') !   days
                    ndays = 0
                    dayidx = 0
                    k = len_trim(value)
                    if (value(:k)/='TBA') then
                        pDASH = -1
                        do i=1,k
                            ch = value(i:i)
                            iidx = 0
                            if (ch=='M') then
                                iidx = 1
                            else if (ch=='-') then
                                pDASH = i
                            else if (ch=='T') then
                                if (value(i+1:i+1)=='h' .or. value(i+1:i+1)=='H') then
                                    iidx = 4
                                else
                                    iidx = 2
                                end if
                            else if (ch=='W') then
                                iidx = 3
                            else if (ch=='F') then
                                iidx = 5
                            else if (ch=='S') then
                                iidx = 6
                            end if
                            if (iidx>0) then
                                ndays = ndays+1
                                if (ndays>6) then
                                    call log_comment('Too many days: '//trim(value))
                                    ndays = 1 ! force to be TBA
                                    dayidx = 0
                                    btime = 0
                                    etime = 0
                                    exit
                                end if
                                dayidx(ndays) = iidx
                                if (pDASH==i-1) then
                                    do j=dayidx(ndays-1)+1,iidx
                                        dayidx(ndays) = j
                                        ndays = ndays+1
                                    end do
                                    ndays = ndays-1
                                end if
                            end if
                        end do
                    else
                        ndays = 1 ! count TBA day-time as 1 meeting
                    end if

                case ('Room') ! room
                    tRoom = adjustl(value)
                    if (tRoom=='TBA') then
                        rmidx = 0
                    else
                        rmidx = index_to_room (tRoom)
                        if (rmidx==0) then
                            call log_comment (trim(value)//' - '//trim(tRoom)//' room is not valid; using TBA')
                        end if
                    end if

                case ('Teacher') ! teacher
                    tTeacher = adjustl(value)
                    if (tTeacher=='TBA') then
                        tidx = 0
                    else
                        tidx = index_to_teacher (tTeacher)
                        if (tidx==0) then
                            call log_comment (trim(value)//' - '//trim(tTeacher)//' teacher is not valid; using TBA')
                        end if
                    end if

                case ('/Meeting') ! transfer to list of meetings
                    k = wrkSection%NMeets
                    wrkSection%DayIdx(k+1:k+ndays) = dayidx(1:ndays)
                    wrkSection%bTimeIdx(k+1:k+ndays) = btime
                    wrkSection%eTimeIdx(k+1:k+ndays) = etime
                    wrkSection%RoomIdx(k+1:k+ndays) = rmidx
                    wrkSection%TeacherIdx(k+1:k+ndays) = tidx
                    wrkSection%NMeets = wrkSection%NMeets + ndays

                case ('/Section') ! make ClassId, then add to list of sections
                    token = trim(Subject(wrkSection%SubjectIdx)%Name)//SPACE//wrkSection%Code
                    wrkSection%ClassId = token
                    flag = .true.
                    do i=1,NumSections
                        if (Section(i)%ClassId .ne. wrkSection%ClassId) cycle
                        flag = .false.
                        exit
                    end do
                    if (flag) then
                        NumSections = NumSections + 1
                        call check_array_bound (NumSections, MAX_ALL_SECTIONS, 'MAX_ALL_SECTIONS')
                        Section(NumSections) = wrkSection
                    else
                        call log_comment ('In '//trim(fName)//' : '//trim(wrkSection%ClassId)// &
                            ' owned by '//trim(tDept)//' - duplicate class; ignored.')
                    end if

                case default
                    ! do nothing

            end select
        end do

        close(unitXML)
        call log_comment (itoa(NumSections)//' sections after reading '//fName)

    end subroutine xml_read_classes



    subroutine xml_write_sections(path, NumSections, Section, iDept)

        character(len=*), intent(in) :: path
        type (TYPE_SECTION), intent(in) :: Section(0:)
        integer, intent (in) :: NumSections
        integer, intent (in) :: iDept

        ! training only?
        if (noWrites) return

        ! all sections, or only the sections for given department?
        if (iDept>0) then
            fileName = trim(path)//'CLASSES-'//trim(Department(iDept)%Code)//'.XML'
        else
            fileName = trim(path)//'CLASSES.XML'
        end if

        call html_comment('xml_write_sections('//trim(fileName)//')')

        open(unit=unitXML, file=fileName, status='unknown')
        write(unitXML,AFORMAT) XML_DOC

        call xml_sections(unitXML, NumSections, Section, iDept)

        close(unitXML)

    end subroutine xml_write_sections



    subroutine xml_sections(unitXML, NumSections, Section, iDept)

        type (TYPE_SECTION), intent(in) :: Section(0:)
        integer, intent (in) :: unitXML, NumSections, iDept

        integer :: sdx, mdx, subj

        write(unitXML,AFORMAT) '<'//XML_ROOT_SECTIONS//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        Subject - subject code', &
            '        Class - class code, to differentiate classes for the same subject', &
            '        Owner - responsible department', &
            '        Slots - class capacity', &
            '        BlockID - block code, if class is assigned to a blocked section', &
            '        Meeting - a class meeting', &
            '        Time - begin time - end time of meeting', &
            '        Days - days of meetings', &
            '        Room - code for meeting room', &
            '        Teacher - code for teacher of meeting', &
            '    </comment>'

        do sdx=1,NumSections
            subj = Section(sdx)%SubjectIdx
            if (subj==0) cycle
            !write(*,*) Section(sdx)%ClassId, Section(sdx)%SubjectIdx

            ! subject belongs to given department?
            if (iDept>0 .and. Section(sdx)%DeptIdx/=iDept) cycle

            if (is_regular_schedule(sdx, Section)) then

                ! class is "regular": single entry for all meetings
                call xml_write_character(unitXML, indent0, 'Section')
                call xml_write_character(unitXML, indent1, 'Subject', Subject(subj)%Name)
                call xml_write_character(unitXML, indent1, 'Class', Section(sdx)%Code)
                call xml_write_character(unitXML, indent1, 'Owner', Department(Section(sdx)%DeptIdx)%Code)
                call xml_write_integer(unitXML,   indent1, 'Seats', Section(sdx)%Slots)
!                if (len_trim(Section(sdx)%BlockID)>0) &
!                    call xml_write_character(unitXML, indent1, 'BlockID', Section(sdx)%BlockID)
                call xml_write_character(unitXML, indent1, 'Meeting')
                call xml_write_character(unitXML, indent2, 'Time', text_time_period(Section(sdx)%bTimeIdx(1), &
                    Section(sdx)%eTimeIdx(1)))
                call xml_write_character(unitXML, indent2, 'Day', text_days_of_section(sdx, NumSections, Section))
                call xml_write_character(unitXML, indent2, 'Room', Room(Section(sdx)%RoomIdx(1))%Code)
                call xml_write_character(unitXML, indent2, 'Teacher', Teacher(Section(sdx)%TeacherIdx(1))%TeacherId)
                call xml_write_character(unitXML, indent1, '/Meeting')
                call xml_write_character(unitXML, indent0, '/Section')

            else ! class is "irregular": one entry for each meeting
                call xml_write_character(unitXML, indent0, 'Section')
                call xml_write_character(unitXML, indent1, 'Subject', Subject(subj)%Name)
                call xml_write_character(unitXML, indent1, 'Class', Section(sdx)%Code)
                call xml_write_character(unitXML, indent1, 'Owner', Department(Section(sdx)%DeptIdx)%Code)
                call xml_write_integer(unitXML,   indent1, 'Seats', Section(sdx)%Slots)
                do mdx=1,Section(sdx)%NMeets
                    call xml_write_character(unitXML, indent1, 'Meeting')
                    call xml_write_character(unitXML, indent2, 'Time', text_time_period(Section(sdx)%bTimeIdx(mdx), &
                        Section(sdx)%eTimeIdx(mdx)))
                    call xml_write_character(unitXML, indent2, 'Day', txtDay(Section(sdx)%DayIdx(mdx)))
                    call xml_write_character(unitXML, indent2, 'Room', Room(Section(sdx)%RoomIdx(mdx))%Code)
                    call xml_write_character(unitXML, indent2, 'Teacher', Teacher(Section(sdx)%TeacherIdx(mdx))%TeacherId)
                    call xml_write_character(unitXML, indent1, '/Meeting')
                end do
                call xml_write_character(unitXML, indent0, '/Section')
            end if

        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_SECTIONS//'>'

    end subroutine xml_sections


!===========================================================
! routines for blocks
!===========================================================


    subroutine read_blocks(path, NumBlocks, Block, NumSections, Section, errNo)

        character(len=*), intent(in) :: path
        integer, intent (in) :: NumSections
        type (TYPE_SECTION), intent(in) :: Section(0:)
        integer, intent (out) :: NumBlocks
        type (TYPE_BLOCK), intent(out) :: Block(0:)
        integer, intent (out) :: errNo

        integer :: blk, ierr, numEntries

        errNo = 0 ! no blocks is OK; none may be defined yet
        fileName = trim(path)//'BLOCKS.XML'
        call xml_read_blocks(fileName, NumBlocks, Block, NumSections, Section, ierr)

        ! compress block array
        numEntries = 0
        do blk=1,NumBlocks
            !write(*,*) blk, Block(blk)%BlockID, Block(blk)%CurriculumIdx
            if (Block(blk)%CurriculumIdx/=0) then
                numEntries = numEntries+1
                Block(numEntries) = Block(blk)
                !write(*,*) 'Adding ', mainEntries, Block(blk)%BlockID
            end if
        end do
        NumBlocks = numEntries

        call sort_alphabetical_blocks(NumBlocks, Block)

    end subroutine read_blocks



    subroutine xml_read_blocks(fName, NumBlocks, Block, NumSections, Section, errNo)

        character(len=*), intent(in) :: fName ! YEAR/TERM/BLOCKS(-CURR)
        integer, intent (in) :: NumSections
        type (TYPE_SECTION), intent(in) :: Section(0:)
        integer, intent (out) :: NumBlocks
        type (TYPE_BLOCK), intent(out) :: Block(0:)
        integer, intent (out) :: errNo

        type (TYPE_BLOCK) :: wrkBlock
        character (len=MAX_LEN_CURRICULUM_CODE) :: tCurriculum
        character (len=MAX_LEN_DEPARTMENT_CODE) :: tDepartment
        character (len=MAX_LEN_SUBJECT_CODE) :: tSubject
        character (len=MAX_LEN_CLASS_ID) :: tSection
        character (len=MAX_LEN_XML_LINE) :: value
        character (len=MAX_LEN_XML_TAG) :: tag
        logical :: flag
        integer :: i, idxCurr, idxSubj, idxSect, loc

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_BLOCKS, fName, errNo)
        if (errNo/=0) then
            call log_comment ('ierr='//itoa(errNo)//' when opening '//fName)
            return
        end if

        ! examine the file line by line
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit
            select case (trim(tag))

                case ('/'//XML_ROOT_BLOCKS)
                    exit

                case ('Block')
                    call initialize_block(wrkBlock)

                case ('Code')
                    wrkBlock%BlockID = adjustl(value)

                case ('Description')
                    wrkBlock%Name = adjustl(value)

                case ('Curriculum')
                    tCurriculum = adjustl(value)
                    idxCurr = index_to_curriculum(tCurriculum)
                    if (idxCurr<0) then
                        idxCurr = -idxCurr
                    else if (idxCurr==0) then
                        idxCurr =NumCurricula
                    end if
                    wrkBlock%CurriculumIdx = idxCurr

                case ('Year')
                    wrkBlock%Year = atoi(value)

                case ('Term')
                    wrkBlock%Term = atoi(value)
                    if (wrkBlock%Term==0) wrkBlock%Term = 3

                case ('Owner')
                    tDepartment = adjustl(value)
                    wrkBlock%DeptIdx = index_to_dept(tDepartment)
                    if (wrkBlock%DeptIdx==0) wrkBlock%DeptIdx = NumDepartments

                case ('Subject')
                    tSubject = adjustl(value)
                    idxSubj = index_to_subject(tSubject)
                    if (idxSubj==0) cycle

                    ! check if duplicate
                    loc = 0 ! not found
                    do i=1,wrkBlock%NumClasses
                        if (wrkBlock%Subject(i)==idxSubj) then
                            loc = i
                            exit
                        end if
                    end do
                    if (loc==0) then ! not a duplicate
                        wrkBlock%NumClasses = wrkBlock%NumClasses + 1
                        wrkBlock%Subject(wrkBlock%NumClasses) = idxSubj
                    else
                        call log_comment ('In '//trim(fName)//' : '//trim(WrkBlock%BlockID)// &
                            ' duplicate subject '//trim(tSubject)//'; ignored.')
                    end if

                case ('Section')
                    tSection = adjustl(value)
                    idxSect = index_to_section(tSection, NumSections, Section)
                    if (idxSect==0) cycle ! section does not exist

                    idxSubj = Section(idxSect)%SubjectIdx
                    ! check if duplicate
                    loc = 0 ! not found
                    do i=1,wrkBlock%NumClasses
                        if (wrkBlock%Subject(i)==idxSubj) then
                            loc = i
                            exit
                        end if
                    end do
                    if (loc==0) then ! not a duplicate
                        loc = wrkBlock%NumClasses + 1
                        wrkBlock%NumClasses = loc
                        wrkBlock%Subject(loc) = idxSubj
                        wrkBlock%Section(loc) = idxSect
                    elseif (wrkBlock%Section(loc)==0) then ! duplicate subject and prior entry had no section
                        wrkBlock%Section(loc) = idxSect
                    else ! duplicate subject and prior entry had a section
                        call log_comment ('In '//trim(fName)//' : '//trim(WrkBlock%BlockID)// &
                            ' using section '//trim(tSection)//' instead of earlier entry '// &
                            Section(wrkBlock%Section(loc))%ClassID)
                        wrkBlock%Section(loc) = idxSect
                    end if

                case ('/Block')
                    flag = .true.
                    do idxCurr=1,NumBlocks
                        if (wrkBlock%BlockID/=Block(idxCurr)%BlockID) cycle
                        flag = .false.
                        exit
                    end do
                    if (flag) then
                        NumBlocks = NumBlocks + 1
                        call check_array_bound (NumBlocks, MAX_ALL_BLOCKS, 'MAX_ALL_BLOCKS')
                        Block(NumBlocks) = wrkBlock
                    else
                        call log_comment ('In '//trim(fName)//' : '//trim(WrkBlock%BlockID)// &
                            ' owned by '//trim(tDepartment)//' - duplicate block; ignored.')
                    end if

                case default
                    ! do nothing
            end select
        end do
        close(unitXML)
        call log_comment (itoa(NumBlocks)//' blocks after reading '//fName)

    end subroutine xml_read_blocks



    subroutine xml_write_blocks(path, NumBlocks, Block, Section, iDept)

        integer, intent (in) :: iDept, NumBlocks
        character(len=*), intent(in) :: path
        type (TYPE_BLOCK), intent(in) :: Block(0:)
        type (TYPE_SECTION), intent(in) :: Section(0:)

        ! training only?
        if (noWrites) return

        ! generate file name
        if (iDept>0) then
            fileName = trim(path)//'BLOCKS-'//trim(Department(iDept)%Code)//'.XML'
        else
            fileName = trim(path)//'BLOCKS.XML'
        end if

        call html_comment('xml_write_blocks('//trim(fileName)//')')

        open(unit=unitXML, file=fileName, status='unknown')
        write(unitXML,AFORMAT) XML_DOC

        call xml_blocks(unitXML, NumBlocks, Block, Section, iDept)

        close(unitXML)

    end subroutine xml_write_blocks



    subroutine xml_blocks(unitXML, NumBlocks, Block, Section, iDept)

        integer, intent (in) :: unitXML, iDept, NumBlocks
        type (TYPE_BLOCK), intent(in) :: Block(0:)
        type (TYPE_SECTION), intent(in) :: Section(0:)

        integer :: blk, sect, i

        write(unitXML,AFORMAT) '<'//XML_ROOT_BLOCKS//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        Code - Block identifier', &
            '        Curriculum - Curricular program for block', &
            '        Description - Block description', &
            '        Year - Year level in curriculum', &
            '        Term - Term of the year in curriculum', &
            '        Owner - Department that created (thus, can modify) block', &
            '        Section - Section already assigned to a subject', &
            '        Subject - Subject not yet assigned a section', &
            '    </comment>'

        ! loop over blocks
        do blk=1,NumBlocks

            ! block was created / is modifiable by given department?
            if (iDept>0 .and. Block(blk)%DeptIdx/=iDept) cycle

            ! any classes assigned to this block?
            if (Block(blk)%NumClasses==0) cycle

            ! block info start
            call xml_write_character(unitXML, indent0, 'Block')
            call xml_write_character(unitXML, indent1, 'Code', Block(blk)%BlockID)
            call xml_write_character(unitXML, indent1, 'Description', Block(blk)%Name)
            call xml_write_character(unitXML, indent1, 'Curriculum', Curriculum(Block(blk)%CurriculumIdx)%Code)
            call xml_write_integer(unitXML,   indent1, 'Year', Block(blk)%Year)
            call xml_write_integer(unitXML,   indent1, 'Term', Block(blk)%Term)
            call xml_write_character(unitXML, indent1, 'Owner', Department(Block(blk)%DeptIdx)%Code)

            ! write classes assigned to block
            do i=1,Block(blk)%NumClasses
                sect = Block(blk)%Section(i)
                if (sect==0) then
                    call xml_write_character(unitXML, indent2, 'Subject', Subject(Block(blk)%Subject(i))%Name)
                else
                    call xml_write_character(unitXML, indent2, 'Section', Section(sect)%ClassId)
                end if
            end do

            ! block info end
            call xml_write_character(unitXML, indent0, '/Block')
        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_BLOCKS//'>'

    end subroutine xml_blocks



    subroutine xml_write_catalog(pathToFile)

        character (len=*), intent(in) :: pathToFile

        open(unit=unitXML, file=pathToFile, status='unknown')
        write(unitXML,AFORMAT) XML_DOC

        call xml_catalog(unitXML)

        close(unitXML)

    end subroutine xml_write_catalog



    subroutine xml_catalog(unitXML)

        integer, intent(in) :: unitXML

        call xml_university(unitXML)
        call xml_colleges(unitXML)
        call xml_departments(unitXML)
        call xml_rooms(unitXML)
        call xml_teachers(unitXML)
        call xml_subjects(unitXML)
        call xml_curricula(unitXML)
        call xml_equivalencies(unitXML)

    end subroutine xml_catalog



    subroutine xml_cleanup()

        character (len=MAX_LEN_FILE_PATH) :: dataSource
        logical :: pathExists

        ! create CATALOG.XML
        call xml_write_catalog(trim(pathToYear)//'CATALOG.XML')

        ! move update files to backup
        call move_to_backup(trim(pathToYear)//'UNIVERSITY.XML')
        call move_to_backup(trim(pathToYear)//'COLLEGES.XML')
        call move_to_backup(trim(pathToYear)//'DEPARTMENTS.XML')
        call move_to_backup(trim(pathToYear)//'ROOMS.XML')
        call move_to_backup(trim(pathToYear)//'TEACHERS.XML')
        call move_to_backup(trim(pathToYear)//'SUBJECTS.XML')
        call move_to_backup(trim(pathToYear)//'CURRICULA.XML')
        call move_to_backup(trim(pathToYear)//'EQUIVALENCIES.XML')

        dataSource = trim(pathToYear)//'FAILRATES.XML'
        inquire(file=trim(dataSource), exist=pathExists)
        if (pathExists) call move_to_backup(dataSource)

    end subroutine xml_cleanup


end module IO
