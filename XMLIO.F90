!======================================================================
!
!    HEEDS (Higher Education Enrollment Decision Support) - A program
!      to create enrollment scenarios for 'next term' in a university
!    Copyright (C) 2012-2014 Ricolindo L. Carino
!
!    This file is part of the HEEDS program.
!
!    HEEDS is free software: you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    (at your option) any later version.
!
!    HEEDS is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU General Public License for more details.
!
!    You should have received a copy of the GNU General Public License
!    along with this program (see the file COPYING.TXT). If not, see
!    <http://www.gnu.org/licenses/>.
!
!    Send inquiries about HEEDS to:
!      Ricolindo L Carino
!      E-mail: Ricolindo.Carino@AcademicForecasts.com
!      Address: 600 Cruise St., Starkville, MS 39759, U.S.A.
!
!======================================================================


module XMLIO

    use UNIVERSITY

    implicit none

    ! private tokens
    character (len=MAX_LEN_FILE_PATH), private :: fileName, dirPath
    character (len=MAX_LEN_XML_LINE), private :: line, value
    character (len=MAX_LEN_XML_TAG), private :: tag
    integer, private :: eof, ndels, pos(30)

contains

#include "XMLIO-OTHER.F90"

!===========================================================
! routines for University-level data
!===========================================================


    subroutine xml_read_university(pathToFile, errNo)

        character(len=*), intent(in) :: pathToFile
        integer, intent (out) :: errNo

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_UNIVERSITY, pathToFile, errNo)
        if (errNo/=0) return

        ! examine the file line by line
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('/'//XML_ROOT_UNIVERSITY)
                    exit

                case ('NAME')
                    UniversityName = adjustl(value)

                case ('ADDRESS')
                    UniversityAddress = adjustl(value)

                case ('WEB')
                     UniversityWeb = adjustl(value)

                case ('PHONE')
                     UniversityPhone = adjustl(value)

                case ('BASEYEAR')
                    baseYear = atoi(value)

                case ('PRESIDENT')
                    UniversityPresident = adjustl(value)

                case ('DEANOFINSTRUCTION')
                    DeanOfInstruction = adjustl(value)

                case ('VPACADEMICAFFAIRS')
                    VPAcademicAffairs = adjustl(value)

                case ('DEANOFCAMPUS')
                    DeanOfCampus = adjustl(value)

                case ('THEREGISTRAR')
                    TheRegistrar = adjustl(value)

                case default ! do nothing

            end select

        end do

        close(unitXML)
        call log_comment('From '//pathTofile, trim(UniversityName)//' @ '//UniversityAddress)

    end subroutine xml_read_university



    subroutine xml_write_university(pathToFile)

        character(len=*), intent(in) :: pathToFile

        call log_comment('xml_write_university('//trim(pathToFile)//')')

        open(unit=unitXML, file=pathToFile)
        write(unitXML,AFORMAT) XML_DOC

        call xml_university(unitXML)

        close(unitXML)

    end subroutine xml_write_university



    subroutine xml_university(unitXML)

        integer, intent(in) :: unitXML

        write(unitXML,AFORMAT) '<'//XML_ROOT_UNIVERSITY//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '    </comment>'
        call xml_write_character(unitXML, indent0, 'NAME', UniversityName)
        call xml_write_character(unitXML, indent0, 'ADDRESS', UniversityAddress)
        call xml_write_character(unitXML, indent0, 'WEB', UniversityWeb)
        call xml_write_character(unitXML, indent0, 'PHONE', UniversityPhone)
        call xml_write_character(unitXML, indent0, 'PRESIDENT', UniversityPresident)
        call xml_write_character(unitXML, indent0, 'DEANOFINSTRUCTION', DeanOfInstruction)
        call xml_write_character(unitXML, indent0, 'VPACADEMICAFFAIRS', VPAcademicAffairs)
        call xml_write_character(unitXML, indent0, 'DEANOFCAMPUS', DeanOfCampus)
        call xml_write_character(unitXML, indent0, 'THEREGISTRAR', TheRegistrar)
        call xml_write_integer  (unitXML, indent0, 'BASEYEAR', baseYear)
        write(unitXML,AFORMAT) '</'//XML_ROOT_UNIVERSITY//'>'

    end subroutine xml_university


!===========================================================
! routines for College()
!===========================================================


   subroutine xml_read_colleges(pathToFile, errNo)

        character(len=*), intent(in) :: pathToFile
        integer, intent (out) :: errNo

        type(TYPE_COLLEGE) :: wrkCollege

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_COLLEGES, pathToFile, errNo)
        if (errNo/=0) return

        ! examine the file line by line
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('/'//XML_ROOT_COLLEGES)
                    exit

                case ('College') ! initialize temporary college data
                    call initialize_college (wrkCollege)

                case ('Code')
                    wrkCollege%Code = adjustl(value)

                case ('Name')
                    wrkCollege%Name = adjustl(value)

                case ('Dean')
                    wrkCollege%Dean = adjustl(value)

                case ('/College') ! add temporary college data to College()
                    if (index(wrkCollege%Code,trim(SYSAD))>0) cycle ! add later
                    NumColleges = NumColleges + 1
                    call check_array_bound (NumColleges, MAX_ALL_COLLEGES, 'MAX_ALL_COLLEGES')
                    College(NumColleges) = wrkCollege

                case default ! do nothing

            end select

        end do

        ! add 'administrative' college for data that does not fit in the 'academic' colleges
        NumColleges = NumColleges + 1
        call check_array_bound (NumColleges, MAX_ALL_COLLEGES, 'MAX_ALL_COLLEGES')
        call initialize_college (College(NumColleges), &
            SYSAD, UniversityCode//' Administration', SYSAD)

        close(unitXML)
        call log_comment (itoa(NumColleges)//' colleges in '//pathTofile)

    end subroutine xml_read_colleges



    subroutine xml_write_colleges(pathToFile)

        character(len=*), intent(in) :: pathToFile

        call move_to_backup(pathToFile)
        call log_comment('xml_write_colleges('//trim(pathToFile)//')')

        open(unit=unitXML, file=pathToFile)
        write(unitXML,AFORMAT) XML_DOC

        call xml_colleges(unitXML)

        close(unitXML)

    end subroutine xml_write_colleges



    subroutine xml_colleges(unitXML)

        integer, intent(in) :: unitXML

        integer :: ldx

        write(unitXML,AFORMAT) '<'//XML_ROOT_COLLEGES//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        Code - college code', &
            '        Name - long name of college', &
            '        Dean - signatory for college (Firstname MI Lastname, PhD)', &
            '    </comment>'

        do ldx = 1,NumColleges-1 ! exclude SYSAD
            call xml_write_character(unitXML, indent0, 'College')
            call xml_write_character(unitXML, indent1, 'Code', College(ldx)%Code)
            call xml_write_character(unitXML, indent1, 'Name', College(ldx)%Name)
            call xml_write_character(unitXML, indent1, 'Dean', College(ldx)%Dean)
            call xml_write_character(unitXML, indent0, '/College')
        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_COLLEGES//'>'

    end subroutine xml_colleges


!===========================================================
! routines for Department()
!===========================================================


    subroutine xml_read_departments(pathToFile, errNo)

        character(len=*), intent(in) :: pathToFile
        integer, intent (out) :: errNo

        integer :: j
        type(typeDEPARTMENT) :: wrkDepartment
        character (len=MAX_LEN_COLLEGE_CODE) :: tColl

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_DEPARTMENTS, pathToFile, errNo)
        if (errNo/=0) return

        ! examine the file line by line
        do

            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('/'//XML_ROOT_DEPARTMENTS)
                    exit

                case ('Department') ! initialize temporary department data
                    call initialize_department (wrkDepartment)

                case ('Code')
                    wrkDepartment%Code = adjustl(value)

                case ('Name')
                    wrkDepartment%Name = adjustl(value)

                case ('College')
                    tColl = adjustl(value)
                    j = index_to_college(tColl)
                    if (j==0) j = NumColleges ! use SYSAD for invalid college code
                    wrkDepartment%CollegeIdx = j

                case ('SectionPrefix')
                    wrkDepartment%SectionPrefix = adjustl(value)

                case ('/Department') ! add temporary department data to Department()
                    if (index(wrkDepartment%Code,trim(SYSAD))>0) cycle ! add at the end
                    NumDepartments = NumDepartments + 1
                    call check_array_bound (NumDepartments, MAX_ALL_DEPARTMENTS, 'MAX_ALL_DEPARTMENTS')
                    Department(NumDepartments) = wrkDepartment

                case default
                   ! do nothing

            end select

        end do

        close(unitXML)
        call log_comment (itoa(NumDepartments)//' departments in '//pathToFile)

        ! add REGISTAR as 'administrative' department for data that does not fit in the 'academic' departments
        NumDepartments = NumDepartments + 1
        call check_array_bound (NumDepartments, MAX_ALL_DEPARTMENTS, 'MAX_ALL_DEPARTMENTS')
        call initialize_department (Department(NumDepartments), &
            SYSAD, UniversityCode//' Registrar', TheRegistrar, 'Z', NumColleges)

    end subroutine xml_read_departments



    subroutine xml_write_departments(pathToFile)

        character(len=*), intent(in) :: pathToFile


        call move_to_backup(pathToFile)
        call log_comment('xml_write_departments('//trim(pathToFile)//')')

        open(unit=unitXML, file=pathToFile)
        write(unitXML,AFORMAT) XML_DOC

        call xml_departments(unitXML)

        close(unitXML)

    end subroutine xml_write_departments



    subroutine xml_departments(unitXML)

        integer, intent(in) :: unitXML
        integer :: ldx

        write(unitXML,AFORMAT) '<'//XML_ROOT_DEPARTMENTS//'>', &
        '    <comment>', &
        '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                    FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
        '        Code - department code', &
        '        Name - long name of department', &
        '        College - mother unit of the department', &
        '        SectionPrefix - prefix of codes for classes in this department', &
        '    </comment>'

        do ldx = 2,NumDepartments-1
            call xml_write_character(unitXML, indent0, 'Department')
            call xml_write_character(unitXML, indent1, 'Code', Department(ldx)%Code)
            call xml_write_character(unitXML, indent1, 'Name', Department(ldx)%Name)
            call xml_write_character(unitXML, indent1, 'College', College(Department(ldx)%CollegeIdx)%Code)
            if (Department(ldx)%SectionPrefix/=SPACE) &
                call xml_write_character(unitXML, indent1, 'SectionPrefix', Department(ldx)%SectionPrefix)
            call xml_write_character(unitXML, indent0, '/Department')
        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_DEPARTMENTS//'>'

    end subroutine xml_departments


!===========================================================
! routines for rooms
!===========================================================


    subroutine xml_read_rooms(pathToFile, errNo)

        character(len=*), intent(in) :: pathToFile
        integer, intent (out) :: errNo

        integer :: j
        type(TYPE_ROOM) :: wrkRoom
        character (len=MAX_LEN_DEPARTMENT_CODE) :: tDept

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_ROOMS, pathToFile, errNo)
        if (errNo/=0) return

        ! examine the file line by line
        do

            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('/'//XML_ROOT_ROOMS)
                    exit

                case ('Room') ! initialize temporary room data
                    call initialize_room (wrkRoom)

                case ('Code')
                    wrkRoom%Code = adjustl(value)

                case ('Department')
                    tDept = adjustl(value)
                    j = index_to_dept(tDept)
                    if (j==0) j = NumDepartments ! use SYSAD if tDept not in list of departments
                    wrkRoom%DeptIdx = j

                case ('Cluster')
                    wrkRoom%Cluster = atoi(value)

                case ('MaxCapacity')
                    wrkRoom%MaxCapacity = atoi(value)

                case ('/Room') ! add temporary room data to Room()
                    if (trim(wrkRoom%Code)==SPACE) cycle
                    NumRooms = NumRooms + 1
                    call check_array_bound (NumRooms, MAX_ALL_ROOMS, 'MAX_ALL_ROOMS')
                    Room(NumRooms) = wrkRoom

                    Department(wrkRoom%DeptIdx)%hasInfo = .true.

                case default
                ! do nothing

            end select

        end do
        close(unitXML)

        !call sort_rooms()
        call log_comment (itoa(NumRooms)//' rooms in '//pathToFile)

    end subroutine xml_read_rooms



    subroutine xml_write_rooms(pathToFile)

        character(len=*), intent(in) :: pathToFile

        call move_to_backup(pathToFile)
        call log_comment('xml_write_rooms('//trim(pathToFile)//')')

        open(unit=unitXML, file=pathToFile)
        write(unitXML,AFORMAT) XML_DOC

        call xml_rooms(unitXML)

        close(unitXML)

    end subroutine xml_write_rooms



    subroutine xml_rooms(unitXML)

        integer, intent(in) :: unitXML
        integer :: ldx

        write(unitXML,AFORMAT) '<'//XML_ROOT_ROOMS//'>', &
        '    <comment>', &
        '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                    FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
        '        Code - room code', &
        '        Department - responsible department', &
        '        Cluster - rooms with the same cluster are "within walking distance" of each other', &
        '        MaxCapacity- maximum seating capacity', &
        '    </comment>'

        do ldx = 1,NumRooms+NumAdditionalRooms
            if (trim(Room(ldx)%Code)==SPACE) cycle
            call xml_write_character(unitXML, indent0, 'Room')
            call xml_write_character(unitXML, indent1, 'Code', Room(ldx)%Code)
            call xml_write_character(unitXML, indent1, 'Department', Department(Room(ldx)%DeptIdx)%Code)
            call xml_write_integer(unitXML, indent1, 'Cluster', Room(ldx)%Cluster)
            call xml_write_integer(unitXML, indent1, 'MaxCapacity', Room(ldx)%MaxCapacity)
            call xml_write_character(unitXML, indent0, '/Room')
        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_ROOMS//'>'

    end subroutine xml_rooms



!===========================================================
! routines for teachers
!===========================================================


    subroutine xml_read_teachers(pathToFile, errNo)

        character(len=*), intent(in) :: pathToFile
        integer, intent (out) :: errNo

        integer :: i, j
        type(TYPE_TEACHER) :: wrkTeacher
        character (len=MAX_LEN_DEPARTMENT_CODE) :: tDept
        character (len=MAX_LEN_STEP_IN_RANK) :: tStep
        character (len=MAX_LEN_ACADEMIC_RANK) :: tRank

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_TEACHERS, pathToFile, errNo)
        if (errNo/=0) return

        ! examine the file line by line
        do

            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('/'//XML_ROOT_TEACHERS)
                    exit

                case ('Teacher') ! initialize temporary teacher data
                    call initialize_teacher(wrkTeacher)

                case ('TeacherId')
                    wrkTeacher%TeacherId = adjustl(value)

                case ('Name')
                    wrkTeacher%Name = adjustl(value)
                    call upper_case(wrkTeacher%Name)

                case ('Department')
                    tDept = adjustl(value)
                    j = index_to_dept(tDept)
                    if (j==0) j = NumDepartments ! use SYSAD for invalid department code
                    wrkTeacher%DeptIdx = j

                ! read additional info here in case file has the old format
                case ('MaxLoad')
                    wrkTeacher%MaxLoad = atoi(value)

                case ('Rank')
                    tRank = adjustl(value)
                    j = 0
                    do i=1,4
                        if (tRank/=AcademicRank(i)) cycle
                        j = i
                        exit
                    end do
                    wrkTeacher%Rank = j

                case ('Step')
                    tStep = adjustl(value)
                    j = 0
                    do i=1,12
                        if (tStep/=RankStep(i)) cycle
                        j = i
                        exit
                    end do
                    wrkTeacher%Step = j

                case ('Bachelor')
                    wrkTeacher%Bachelor = adjustl(value)

                case ('Master')
                    wrkTeacher%Master = adjustl(value)

                case ('Doctorate')
                    wrkTeacher%Doctorate = adjustl(value)

                case ('Specialization')
                    wrkTeacher%Specialization = adjustl(value)

                case ('Password')
                    wrkTeacher%Password = adjustl(value)

                case ('Role')
                    wrkTeacher%Role = adjustl(value)
                    i = -1
                    do j=0,MAX_ALL_ROLES
                        if (wrkTeacher%Role/=txtRole(j)) cycle
                        i = j
                        exit
                    end do
                    if (i/=-1) then
                        wrkTeacher%Role = txtRole(i)
                    else
                        wrkTeacher%Role = GUEST
                    end if

                case ('/Teacher') ! add/merge temporary teacher data to Teacher()
                    if (len_trim(wrkTeacher%TeacherId)==0) cycle
                    if (trim(wrkTeacher%TeacherId)==trim(GUEST) ) cycle ! Guest already in
                    if (len_trim(wrkTeacher%Name)==0) cycle ! no name
                    ! teacher encountered previously?
                    i = 0
                    do j=1,NumTeachers
                        if (wrkTeacher%TeacherId/=Teacher(j)%TeacherId) cycle
                        i = j
                        exit
                    end do
                    if (i/=0) then ! overwrite existing record
                        call log_comment ('Duplicate record for '//trim(wrkTeacher%TeacherId)//'; updated.')
                        Teacher(i) = wrkTeacher
                    else
                        NumTeachers = NumTeachers + 1
                        call check_array_bound (NumTeachers, MAX_ALL_TEACHERS, 'MAX_ALL_TEACHERS')
                        Teacher(NumTeachers) = wrkTeacher
                        i = NumTeachers
                    end if
                    if (is_teacher_password(i, GUEST) .or. len_trim(Teacher(i)%Password)==0) &
                        call set_password(Teacher(i)%Password)
                    Department(Teacher(i)%DeptIdx)%hasInfo = .true.
                case default
                    ! do nothing
            end select

        end do

        close(unitXML)
        call log_comment (itoa(NumTeachers)//' teachers in '//pathTofile)

    end subroutine xml_read_teachers



    subroutine xml_write_teachers(pathToFile)

        character(len=*), intent(in) :: pathToFile

        call move_to_backup(pathToFile)
        call log_comment('xml_write_teachers('//trim(pathToFile)//')')

        open(unit=unitXML, file=pathToFile)
        write(unitXML,AFORMAT) XML_DOC

        call xml_teachers(unitXML)

        close(unitXML)

    end subroutine xml_write_teachers



    subroutine xml_teachers(unitXML)

        integer, intent(in) :: unitXML

        integer :: ldx

        write(unitXML,AFORMAT) '<'//XML_ROOT_TEACHERS//'>', &
        '    <comment>', &
        '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                    FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
        '        TeacherId - teacher code', &
        '        Name - name of teacher', &
        '        Department - responsible department', &
        '    </comment>'

        do ldx = 1,NumTeachers+NumAdditionalTeachers
            if (trim(Teacher(ldx)%TeacherId)==SPACE .or. trim(Teacher(ldx)%TeacherId)==trim(GUEST) ) cycle

            call xml_write_character(unitXML, indent0, 'Teacher')
            call xml_write_character(unitXML, indent1, 'TeacherId', Teacher(ldx)%TeacherId)
            call xml_write_character(unitXML, indent1, 'Name', Teacher(ldx)%Name)
            call xml_write_character(unitXML, indent1, 'Department', Department(Teacher(ldx)%DeptIdx)%Code)
            if (Teacher(ldx)%MaxLoad>0) &
                call xml_write_integer(unitXML, indent1, 'MaxLoad', Teacher(ldx)%MaxLoad)
            if (Teacher(ldx)%Rank>0) &
                call xml_write_character(unitXML, indent1, 'Rank', AcademicRank(Teacher(ldx)%Rank))
            if (Teacher(ldx)%Step>0) &
                call xml_write_character(unitXML, indent1, 'Step', RankStep(Teacher(ldx)%Step))
            if (Teacher(ldx)%Bachelor/=SPACE) &
                call xml_write_character(unitXML, indent1, 'Bachelor', Teacher(ldx)%Bachelor)
            if (Teacher(ldx)%Master/=SPACE) &
                call xml_write_character(unitXML, indent1, 'Master', Teacher(ldx)%Master)
            if (Teacher(ldx)%Doctorate/=SPACE)  &
                call xml_write_character(unitXML, indent1, 'Doctorate', Teacher(ldx)%Doctorate)
            if (Teacher(ldx)%Specialization/=SPACE)  &
                call xml_write_character(unitXML, indent1, 'Specialization', Teacher(ldx)%Specialization)
            call xml_write_character(unitXML, indent1, 'Password', Teacher(ldx)%Password)
            if (Teacher(ldx)%Role/=SPACE)  &
                call xml_write_character(unitXML, indent1, 'Role', Teacher(ldx)%Role)
            call xml_write_character(unitXML, indent0, '/Teacher')

        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_TEACHERS//'>'

    end subroutine xml_teachers


!===========================================================
! routines for subjects
!===========================================================



    subroutine xml_read_subjects(pathToFile, errNo)

        character(len=*), intent(in) :: pathToFile
        integer, intent (out) :: errNo

        integer :: i, j, k, l
        type(TYPE_SUBJECT) :: wrkSubject
        character (len=MAX_LEN_DEPARTMENT_CODE) :: tDept
        character (len=MAX_LEN_SUBJECT_CODE) :: token

        ! open file for basic info on subjects, return on any error
        call xml_read_file(unitXML, XML_ROOT_SUBJECTS, pathToFile, errNo)
        if (errNo/=0) return

        ! read subject code & responsible department
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('/'//XML_ROOT_SUBJECTS)
                    exit

                case ('Subject') ! initialize temporary subject data
                    call initialize_subject (wrkSubject)

                case ('Code')
                    wrkSubject%Name = adjustl(value)

                case ('Department')
                    tDept = adjustl(value)
                    j = index_to_dept(tDept)
                    if (j==0) j = NumDepartments ! use SYSAD for invalid department code
                    wrkSubject%DeptIdx = j

                case ('/Subject') ! add temporary subject data to Subject()
                    ! no subject code ?
                    if (trim(wrkSubject%Name)==SPACE) cycle
                    ! duplicate subject ?
                    i = index_to_subject(wrkSubject%Name)
                    if (i/=0) cycle ! duplicate

                    ! not a dummy subject
                    Department(wrkSubject%DeptIdx)%hasInfo = .true.

                    if (wrkSubject%DeptIdx>1) then
                        NumSubjects = NumSubjects + 1
                        call check_array_bound (NumSubjects, MAX_ALL_SUBJECTS, 'MAX_ALL_SUBJECTS')
                        i = NumSubjects
                        do while (wrkSubject%Name<Subject(i-1)%Name)
                            Subject(i)%Name = Subject(i-1)%Name
                            i = i-1
                        end do
                        Subject(i)%Name = wrkSubject%Name

                    elseif (wrkSubject%DeptIdx==1) then ! dummy subject
                        NumDummySubjects = NumDummySubjects-1
                        Subject(NumDummySubjects)%Name = wrkSubject%Name

                    end if

                case default
                ! do nothing

            end select

        end do
        close(unitXML)

        call log_comment (itoa(NumSubjects)//' subjects in '//pathTofile)

        ! fix INDEX_TO_NONE
        token = 'NONE'
        INDEX_TO_NONE = index_to_subject(token)
        Subject(:)%Prerequisite(1) = INDEX_TO_NONE
        Subject(:)%Corequisite(1) = INDEX_TO_NONE
        Subject(:)%Concurrent(1) = INDEX_TO_NONE
        Subject(:)%ConcPrerequisite(1) = INDEX_TO_NONE

        ! read the rest of subject basic info
        call xml_read_file(unitETC, XML_ROOT_SUBJECTS, pathToFile, eof)
        do
            read(unitETC, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('/'//XML_ROOT_SUBJECTS)
                    exit

                case ('Subject') ! initialize temporary subject data
                    call initialize_subject (wrkSubject)

                case ('Code')
                    wrkSubject%Name = adjustl(value)

                case ('Title')
                    wrkSubject%Title = adjustl(value)

                case ('Department')
                    tDept = adjustl(value)
                    j = index_to_dept(tDept)
                    if (j==0) j = NumDepartments ! use SYSAD for invalid department code
                    wrkSubject%DeptIdx = j

                case ('Units')
                    wrkSubject%Units = atof(value)

                case ('Enrollment')
                    call index_to_delimiters(COMMA, value, ndels, pos)
                    do k=1,6,2 !  1st term, 2nd term, summer
                        l = (k+1)/2
                        i = atoi(value(pos(k)+1:pos(k+1)-1)) ! pass
                        j = atoi(value(pos(k+1)+1:pos(k+2)-1)) ! fail
                        wrkSubject%GrandTotal(1,l) = i
                        wrkSubject%GrandTotal(2,l) = j
                        wrkSubject%Failrate(l) = (1.0*j)/max(1,i+j)
                    end do

                case ('TermOffered')
                    wrkSubject%TermOffered = 0
                    if (index(value, '1')>0) wrkSubject%TermOffered = wrkSubject%TermOffered+1
                    if (index(value, '2')>0) wrkSubject%TermOffered = wrkSubject%TermOffered+2
                    if (index(value, 'S')>0) wrkSubject%TermOffered = wrkSubject%TermOffered+4

                case ('LectHours')
                    wrkSubject%LectHours = atof(value)

                case ('MinLectSize')
                    wrkSubject%MinLectSize = atoi(value)

                case ('MaxLectSize')
                    wrkSubject%MaxLectSize = atoi(value)

                case ('LabHours')
                    wrkSubject%LabHours = atof(value)

                case ('MinLabSize')
                    wrkSubject%MinLabSize = atoi(value)

                case ('MaxLabSize')
                    wrkSubject%MaxLabSize = atoi(value)

                ! read the additional info also, in case the file has the old format
                case ('LabFee')
                    wrkSubject%LabFee = atof(value)

                case ('Tuition')
                    wrkSubject%Tuition = atof(value)

                case ('LectLoad')
                    wrkSubject%LectLoad = atof(value)

                case ('LabLoad')
                    wrkSubject%LabLoad = atof(value)

                case ('Prerequisite')
                    call tokenize_subjects(value, '+', MAX_ALL_SUBJECT_PREREQ, &
                        wrkSubject%lenPreq, wrkSubject%Prerequisite, eof)
                    if (eof>0) exit

                case ('Corequisite')
                    call tokenize_subjects(value, '+', MAX_ALL_SUBJECT_COREQ, &
                        wrkSubject%lenCoreq, wrkSubject%Corequisite, eof)
                    if (eof>0) exit
                    if (wrkSubject%lenCoreq>0 .and. Subject(wrkSubject%Corequisite(1))%Name/='NONE') then
                        call log_comment(trim(wrkSubject%Name)//' has co-requisite '// &
                            Subject(wrkSubject%Corequisite(1))%Name ) ! , j=1,wrkSubject%lenCoreq)
                    end if

                case ('ConcurrentWith')
                    call tokenize_subjects(value, '+', MAX_ALL_SUBJECT_CONCURRENT, wrkSubject%lenConc, wrkSubject%Concurrent, eof)
                    if (eof>0) exit
                    if (wrkSubject%lenConc>0 .and. Subject(wrkSubject%Concurrent(1))%Name/='NONE') then
                        call log_comment(trim(wrkSubject%Name)//' is concurrent with '// &
                            Subject(wrkSubject%Concurrent(1))%Name ) !, j=1,wrkSubject%lenConc)
                    end if

                case ('ConcurrentPrerequisite')
                    call tokenize_subjects(value, '+', MAX_ALL_SUBJECT_CONCPREQ, wrkSubject%lenConcPreq, &
                    wrkSubject%ConcPrerequisite, eof)
                    if (eof>0) exit
                    if (wrkSubject%lenConcPreq>0 .and. Subject(wrkSubject%ConcPrerequisite(1))%Name/='NONE') then
                        call log_comment(trim(wrkSubject%Name)//' has pre-req that can be concurrent : '// &
                           Subject(wrkSubject%ConcPrerequisite(1))%Name) ! , j=1,wrkSubject%lenConcPreq)
                    end if

                case ('/Subject') ! add temporary subject data to Subject()
                    i = index_to_subject(wrkSubject%Name)
                    !wrkSubject%TermOffered = 7 ! HARDCODE
                    Subject(i) = wrkSubject

                case default
                    ! do nothing

            end select

        end do

        close(unitETC)

        call get_subject_areas()

    end subroutine xml_read_subjects



    subroutine xml_write_subjects(pathToFile)

        character(len=*), intent(in) :: pathToFile

        call move_to_backup(pathToFile)
        call log_comment('xml_write_subjects('//trim(pathToFile)//')')

        open(unit=unitXML, file=pathToFile)
        write(unitXML,AFORMAT) XML_DOC

        call xml_subjects(unitXML)

        close(unitXML)

    end subroutine xml_write_subjects



    subroutine xml_subjects(unitXML)

        integer, intent(in) :: unitXML
        integer :: subj, i, j
        character(len=255) :: mesg1, mesg2, mesg3, mesg4

        write(unitXML,AFORMAT) '<'//XML_ROOT_SUBJECTS//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        Code - subject identifier', &
            '        Title - subject title', &
            '        Department - responsible department', &
            '        Units - credit to the student', &
            '        Enrollment - #(Pass 1st),#(Fail 1st),#(Pass 2nd),#(Fail 2nd),#(Pass Sum.),#(Fail Sum.)', &
            '            where: #(Pass) = #(Grade>=75) + #(Grade<=3.0); #(Fail) = not Pass', &
            '        TermOffered - 1 for first semester, 2 for second semester, S for summer; or combinations of 1, 2, and S', &
            '        LectHours - no. of lecture hours; 0 if the subject is lab-only', &
            '        MinLectSize - minimum size to open lecture class; 0 if the subject is lab-only', &
            '        MaxLectSize - maximum size to create another lecture class; 0 if the subject is lab-only', &
            '        LabHours - laboratory/recitation/computation class hours; 0 if the subject is lecture-only', &
            '        MinLabSize - minimum size to open lab class; 0 if the subject is lecture-only', &
            '        MaxLabSize - maximum size to create another lab class; 0 if the subject is lecture-only', &
            '        DisplayUnits - how the number of units will be displayed (i.e., 3, 2.0, (1.5) )', &
            '        Tuition - how much a student will pay if he takes the subject', &
            '        LabFee - how much (in addn to Tuition) a student will pay for laboratory fee', &
            '        LectLoad - workload credit to teacher of lecture class', &
            '        LabLoad - workload credit to teacher of laboratory/recitation/computation class', &
            '        Prerequisite - subject prerequisite in prefix format, tokens being separated by "+"', &
            '          possible values are', &
            '            1. NONE', &
            '            2. COI', &
            '            3. Student classification (FRESHMAN, SOPHOMORE, JUNIOR, SENIOR)', &
            '            4. year level in curriculum (FIRST,SECOND,THIRD,FOURTH,FIFTH,GRADUATING)', &
            '            5. subject code - another subject', &
            '            6. OR+2+5, OR+3+5, OR+4+5', &
            '            7. OR+5+5, AND+5+5', &
            '            8. OR+6+6, OR+6+7, OR+7+7, AND+7+7', &
            '        Corequisite - subject co-requisite', &
            '        Concurrent - subject to be concurrently registered', &
            '        ConcurrentPrerequisite - prerequisite that can be registered concurrently', &
            '    </comment>'

        do subj=NumDummySubjects,NumSubjects+NumAdditionalSubjects
            if (subj==-1 .or. subj==0) cycle

            ! prerequisite
            i = Subject(subj)%Prerequisite(1)
            mesg1 = Subject(i)%Name
            do j=2,Subject(subj)%lenPreq
                i = Subject(subj)%Prerequisite(j)
                mesg1 = trim(mesg1)//'+'//Subject(i)%Name
            end do
            ! corequisite
            i = Subject(subj)%Corequisite(1)
            mesg2 = Subject(i)%Name
            do j=2,Subject(subj)%lenCoreq
                i = Subject(subj)%Corequisite(j)
                mesg2 = trim(mesg2)//'+'//Subject(i)%Name
            end do
            ! concurrent
            i = Subject(subj)%Concurrent(1)
            mesg3 = Subject(i)%Name
            do j=2,Subject(subj)%lenConc
                i = Subject(subj)%Concurrent(j)
                mesg3 = trim(mesg3)//'+'//Subject(i)%Name
            end do
            ! prerequisite that can be taken concurrently
            i = Subject(subj)%ConcPrerequisite(1)
            mesg4 = Subject(i)%Name
            do j=2,Subject(subj)%lenConcPreq
                i = Subject(subj)%ConcPrerequisite(j)
                mesg4 = trim(mesg4)//'+'//Subject(i)%Name
            end do

            call xml_write_character(unitXML, indent0, 'Subject')
            call xml_write_character(unitXML, indent1, 'Code', Subject(subj)%Name)
            call xml_write_character(unitXML, indent1, 'Title', Subject(subj)%Title)
            call xml_write_character(unitXML, indent1, 'Department', Department(Subject(subj)%DeptIdx)%Code)
            call xml_write_character(unitXML, indent1, 'TermOffered', text_term_offered(Subject(subj)%TermOffered))
            if (Subject(subj)%Units/=0.0) call xml_write_float(unitXML, indent1, 'Units', Subject(subj)%Units,2)
            if (Subject(subj)%Units>0.0) call xml_write_character(unitXML, indent1, 'DisplayUnits', ftoa(Subject(subj)%Units,2))
            call xml_write_character(unitXML, indent1, 'Enrollment', &
                trim(itoa(Subject(subj)%GrandTotal(1,1)))//COMMA// &
                trim(itoa(Subject(subj)%GrandTotal(2,1)))//COMMA// &
                trim(itoa(Subject(subj)%GrandTotal(1,2)))//COMMA// &
                trim(itoa(Subject(subj)%GrandTotal(2,2)))//COMMA// &
                trim(itoa(Subject(subj)%GrandTotal(1,3)))//COMMA// &
                trim(itoa(Subject(subj)%GrandTotal(2,3))) )
            if (Subject(subj)%Tuition/=0.0) call xml_write_float(unitXML, indent1, 'Tuition', Subject(subj)%Tuition,2)
            if (Subject(subj)%LabFee/=0.0) call xml_write_float(unitXML, indent1, 'LabFee', Subject(subj)%LabFee,2)
            if (Subject(subj)%LectHours/=0.0) call xml_write_float(unitXML, indent1, 'LectHours', Subject(subj)%LectHours,2)
            if (Subject(subj)%MinLectSize/=0) call xml_write_integer(unitXML, indent1, 'MinLectSize', Subject(subj)%MinLectSize)
            if (Subject(subj)%MaxLectSize/=0) call xml_write_integer(unitXML, indent1, 'MaxLectSize', Subject(subj)%MaxLectSize)
            if (Subject(subj)%LectLoad/=0.0) call xml_write_float(unitXML, indent1, 'LectLoad', Subject(subj)%LectLoad,2)
            if (Subject(subj)%LabHours/=0.0) call xml_write_float(unitXML, indent1, 'LabHours', Subject(subj)%LabHours,2)
            if (Subject(subj)%MinLabSize/=0) call xml_write_integer(unitXML, indent1, 'MinLabSize', Subject(subj)%MinLabSize)
            if (Subject(subj)%MaxLabSize/=0) call xml_write_integer(unitXML, indent1, 'MaxLabSize', Subject(subj)%MaxLabSize)
            if (Subject(subj)%LabLoad/=0.0) call xml_write_float(unitXML, indent1, 'LabLoad', Subject(subj)%LabLoad,2)
            if (trim(mesg1)/='NONE') call xml_write_character(unitXML, indent1, 'Prerequisite', mesg1)
            if (trim(mesg2)/='NONE') call xml_write_character(unitXML, indent1, 'Corequisite', mesg2)
            if (trim(mesg3)/='NONE') call xml_write_character(unitXML, indent1, 'ConcurrentWith', mesg3)
            if (trim(mesg4)/='NONE') call xml_write_character(unitXML, indent1, 'ConcurrentPrerequisite', mesg4)

            call xml_write_character(unitXML, indent0, '/Subject')

        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_SUBJECTS//'>'

    end subroutine xml_subjects


!===========================================================
! routines for curricula
!===========================================================


    subroutine xml_read_curricula(pathToFile, errNo)

        character(len=*), intent(in) :: pathToFile
        integer, intent (out) :: errNo

        type(TYPE_CURRICULUM) :: tmpCurriculum

        integer :: i, j, k, idxterm, year, term, ierr
        character (len=MAX_LEN_SUBJECT_CODE) :: token
        character (len=MAX_LEN_COLLEGE_CODE) :: tCollege
        character (len=MAX_LEN_TEXT_SEMESTER) :: strTerm
        character (len=MAX_LEN_TEXT_YEAR) :: strYear
        integer :: nLoad, loadArray(MAX_SUBJECTS_PER_TERM)

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_CURRICULA, pathToFile, errNo)
        if (errNo/=0) return

        ! examine the file line by line
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('/'//XML_ROOT_CURRICULA)
                    exit

                case ('Curriculum') ! initialize temporary curriculum data
                    tmpCurriculum = Curriculum(0)

                case ('Code')
                    tmpCurriculum%Code = adjustl(value)

                case ('Title')
                    tmpCurriculum%Title = adjustl(value)

                case ('Specialization')
                    tmpCurriculum%Specialization = adjustl(value)

                case ('Remark')
                    tmpCurriculum%Remark = adjustl(value)

                case ('Status') ! value is ACTIVE or INACTIVE
                    tmpCurriculum%Active = trim(value)=='ACTIVE'

                case ('College') ! value is a college code
                    tCollege = value
                    tmpCurriculum%CollegeIdx = index_to_college(tCollege)

                case ('Load') ! value is empty
                    nLoad = 0
                    loadArray = 0
                    year = -1
                    term = -1

                case ('Year') ! value is one of FIRST, SECOND, THIRD, FOURTH, ...
                    strYear = adjustl(value)
                    call upper_case(strYear)
                    year = index_to_year(strYear)

                case ('Term') ! value is one of FIRST, SECOND, SUMMER
                    strTerm = adjustl(value)
                    call upper_case(strTerm)
                    term = index_to_term(strTerm)

                case ('Subjects') ! value is comma-separated list of subjects
                    call tokenize_subjects(value, ',', MAX_SUBJECTS_PER_TERM, nLoad, loadArray, ierr)

                case ('/Load') ! value is empty
                    if (year>0 .and. term>0) then ! ok
                        ! collect subjects
                        idxTerm = (year-1)*3 + term
                        tmpCurriculum%NumTerms = idxTerm
                        do k = 1,nLoad
                            if (INDEX_TO_NONE==loadArray(k)) cycle
                            token = Subject(loadArray(k))%Name
                            i = index_to_new_subject(loadArray(k))
                            !if (i/=loadArray(k)) &
                            !    call log_comment (tCurriculum//token//' renamed '//Subject(i)%Name)
                            if ( is_offered(i,term) ) then
                                j = tmpCurriculum%NSubjects+1
                                tmpCurriculum%NSubjects = j
                                tmpCurriculum%SubjectIdx(j) = i
                                tmpCurriculum%SubjectTerm(j) = idxTerm
                            else
                                call log_comment (token//': subject not offered during '//strTerm//' Term')
                            !return
                            end if
                        end do
                    end if
                    nLoad = 0
                    loadArray = 0
                    year = -1
                    term = -1

                case ('/Curriculum') ! add temporary curriculum data to Curriculum()
                    if (trim(tmpCurriculum%Code)=='OTHER') cycle ! ignore OTHER
                    if (trim(tmpCurriculum%Code)==SPACE) cycle ! ignore
                    NumCurricula = NumCurricula + 1
                    call check_array_bound (NumCurricula, MAX_ALL_CURRICULA, 'MAX_ALL_CURRICULA')
                    Curriculum(NumCurricula) = tmpCurriculum
                    College(tmpCurriculum%CollegeIdx)%hasInfo = .true.

                    ! if active curriculum, check that prerequisites are taken before successor subjects
                    if (tmpCurriculum%Active) then
                        nLoad = tmpCurriculum%NSubjects
                    else
                        nLoad = 0
                        !write(*,*) 'Not active: '//tmpCurriculum%Code
                    end if
                    do k = 1, nLoad
                        i = tmpCurriculum%SubjectIdx(k)
                        if (.not. is_prerequisite_satisfiable_in_curriculum(i,NumCurricula)) then
                            token = Subject(i)%Name
                            call rank_to_year_term (tmpCurriculum%SubjectTerm(k), year, term)
                            strYear = txtYear(year)
                            strTerm = txtSemester(term)
                            call log_comment (trim(tmpCurriculum%Code)//', '// &
                                trim(strYear)//' year, '//trim(strTerm)//' term, '//trim(token)// &
                                ': preq '//trim(text_prerequisite_in_curriculum(i))//' not specified earlier!')
                        end if
                    end do
                case default
                    ! do nothing
            end select

        end do

        close(unitXML)

        ! sort
        do i=1,NumCurricula-1
            do j=i+1,NumCurricula
                if (Curriculum(i)%Code>Curriculum(j)%Code) then
                    tmpCurriculum = Curriculum(i)
                    Curriculum(i) = Curriculum(j)
                    Curriculum(j) = tmpCurriculum
                end if
            end do
        end do

        call log_comment (itoa(NumCurricula)//' curricula in '//pathToFile)

        ! add OTHER
        NumCurricula = NumCurricula + 1
        call check_array_bound (NumCurricula, MAX_ALL_CURRICULA, 'MAX_ALL_CURRICULA')
        Curriculum(NumCurricula)%Code = 'OTHER'
        Curriculum(NumCurricula)%CollegeIdx = NumColleges
        Curriculum(NumCurricula)%Title = 'Change curriculum'
        Curriculum(NumCurricula)%Specialization = SPACE
        Curriculum(NumCurricula)%Remark = SPACE
        Curriculum(NumCurricula)%NSubjects = 0
        Curriculum(NumCurricula)%Active = .true.

        call make_curriculum_groups()

    end subroutine xml_read_curricula



    subroutine xml_write_curricula(pathToFile)

        character(len=*), intent(in) :: pathToFile

        call move_to_backup(pathToFile)
        call log_comment('xml_write_curricula('//trim(pathToFile)//')')

        open(unit=unitXML, file=pathToFile)
        write(unitXML,AFORMAT) XML_DOC

        call xml_curricula(unitXML)

        close(unitXML)

    end subroutine xml_write_curricula



    subroutine xml_curricula(unitXML)

        integer, intent(in) :: unitXML
        integer :: idxCOLL, idxCURR, idx, tdx, Year, Term
        character(len=255) :: mesg
        character(len=MAX_LEN_CURRICULUM_CODE) :: tCurriculum

        write(unitXML,AFORMAT) '<'//XML_ROOT_CURRICULA//'>', &
        '    <comment>', &
        '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                    FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
        '        Code - code for the curriculum', &
        '        Title - long name of curriculum', &
        '        Specialization - curriculum option/major area', &
        '        Remark - other info on the curriculum', &
        '        College - responsible college', &
        '        Status - to indicate status of curriculum: ACTIVE or INACTIVE', &
        '        Load, Year, Term, Subjects - Subjects to be taken during (Year, Term)', &
        '            where Year is one of FIRST, SECOND, THIRD, FOURTH, FIFTH', &
        '            and   Term is one of FIRST, SECOND, SUMMER', &
        '        Substitution - to indicate allowed automatic substitutions in this curriculum', &
        '            subjects in this list which are required in the curriculum will', &
        '            be considered "passed" if the rest of the subjects in the list have passing grades;', &
        '            i.e., MATH 11 and MATH 14 can be substituted by MATH I and MATH 17', &
        '    </comment>'

        do idxCURR=1,NumCurricula-1

            idxCOLL = Curriculum(idxCURR)%CollegeIdx

            tCurriculum = Curriculum(idxCURR)%Code
            if (trim(tCurriculum)==SPACE) cycle
            call xml_write_character(unitXML, indent0, 'Curriculum')
            call xml_write_character(unitXML, indent1, 'Code', tCurriculum)
            call xml_write_character(unitXML, indent1, 'Title', Curriculum(idxCURR)%Title)

            if (Curriculum(idxCURR)%Specialization/=SPACE) then
                call xml_write_character(unitXML, indent1, 'Specialization', Curriculum(idxCURR)%Specialization)
            end if

            if (Curriculum(idxCURR)%Remark/=SPACE) then
                call xml_write_character(unitXML, indent1, 'Remark', Curriculum(idxCURR)%Remark)
            end if

            if (Curriculum(idxCURR)%Active) then
                mesg = 'ACTIVE'
            else
                mesg = 'INACTIVE'
            end if
            call xml_write_character(unitXML, indent1, 'Status', mesg)

            call xml_write_character(unitXML, indent1, 'College', College(idxCOLL)%Code)

            do tdx=1,Curriculum(idxCURR)%NumTerms
                call rank_to_year_term(tdx, Year, Term)
                mesg = SPACE
                do idx=1,Curriculum(idxCURR)%NSubjects
                    if (INDEX_TO_NONE==Curriculum(idxCURR)%SubjectIdx(idx)) cycle
                    if (Curriculum(idxCURR)%SubjectTerm(idx) == tdx) then
                        mesg = trim(mesg)//COMMA//Subject(Curriculum(idxCURR)%SubjectIdx(idx))%Name
                    end if
                end do
                if (mesg==SPACE) cycle
                call xml_write_character(unitXML, indent1, 'Load')
                call xml_write_character(unitXML, indent2, 'Year', txtYear(Year))
                call xml_write_character(unitXML, indent2, 'Term', txtSemester(Term))
                call xml_write_character(unitXML, indent2, 'Subjects', mesg(2:))
                call xml_write_character(unitXML, indent1, '/Load')
            end do
            do tdx=1,NumSubst
                if (Substitution(SubstIdx(tdx))==idxCURR) then
                    mesg = SPACE
                    do idx=SubstIdx(tdx)+1, SubstIdx(tdx+1)-1
                        mesg = trim(mesg)//COMMA//Subject(Substitution(idx))%Name
                    end do
                    call xml_write_character(unitXML, indent1, 'Substitution', mesg(2:))
                end if
            end do

            call xml_write_character(unitXML, indent0, '/Curriculum')

        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_CURRICULA//'>'

    end subroutine xml_curricula



    subroutine xml_read_equivalencies(path, errNo, backupFile)

        character(len=*), intent(in) :: path
        integer, intent (out) :: errNo
        character (len=*), intent(in), optional :: backupFile

        character (len=MAX_LEN_CURRICULUM_CODE) :: tCurriculum
        integer :: idxCURR

        integer :: i, ptrS
        integer :: nLoad, loadArray(MAX_SUBJECTS_PER_TERM)

        ptrS = 0 ! substitutions

        ! open CURRICULUM file, return on any error
        if (present(backupFile)) then
            fileName = trim(path)//backupFile
        else
            fileName = trim(path)//'CURRICULA.XML'
        end if
        call xml_read_file(unitXML, XML_ROOT_CURRICULA, fileName, errNo)
        if (errNo==0) then
            ! examine the file line by line
            do
                read(unitXML, AFORMAT, iostat=eof) line
                if (eof<0) exit
                if (trim(line)=='</'//XML_ROOT_CURRICULA//'>') exit

                ! get tag and value if any
                call xml_parse_line(line, tag, value, eof)
                if (eof/=0) exit

                select case (trim(tag))

                    case ('Code')
                        tCurriculum = adjustl(value)
                        idxCURR = index_to_curriculum(tCurriculum)

                    case ('Substitution') ! value is comma-separated list of subjects
                        call tokenize_subjects(value, ',', MAX_SUBJECTS_PER_TERM, nLoad, loadArray, errNo)
                        call check_array_bound (NumSubst+1, MAX_ALL_SUBSTITUTIONS, 'MAX_ALL_SUBSTITUTIONS')
                        call check_array_bound (ptrS+nLoad, MAX_LEN_SUBSTITUTION_ARRAY, 'MAX_LEN_SUBSTITUTION_ARRAY')
                        NumSubst = NumSubst + 1
                        ptrS = ptrS+1
                        SubstIdx(NumSubst) = ptrS
                        Substitution(ptrS) = idxCURR
                        do i=1,nLoad
                            ptrS = ptrS+1
                            Substitution(ptrS) = loadArray(i)
                        end do
                    case default
                        ! do nothing
                end select
            end do
            close(unitXML)
        end if

        ! open EQUIVALENCIES file, return on any error
        if (present(backupFile)) then
            fileName = trim(path)//backupFile
        else
            fileName = trim(path)//'EQUIVALENCIES.XML'
        end if
        call xml_read_file(unitXML, XML_ROOT_EQUIVALENCIES, fileName, errNo)
        if (errNo==0) then
            ! examine the file line by line
            do
                read(unitXML, AFORMAT, iostat=eof) line
                if (eof<0) exit

                ! get tag and value if any
                call xml_parse_line(line, tag, value, eof)
                if (eof/=0) exit

                select case (trim(tag))

                    case ('/'//XML_ROOT_EQUIVALENCIES)
                        exit

                    case ('Equivalence') ! value is comma-separated list of subjects
                        call tokenize_subjects(value, ',', MAX_SUBJECTS_PER_TERM, nLoad, loadArray, errNo)
                        call check_array_bound (NumSubst+1, MAX_ALL_SUBSTITUTIONS, 'MAX_ALL_SUBSTITUTIONS')
                        call check_array_bound (ptrS+nLoad, MAX_LEN_SUBSTITUTION_ARRAY, 'MAX_LEN_SUBSTITUTION_ARRAY')
                        NumSubst = NumSubst + 1
                        ptrS = ptrS+1
                        SubstIdx(NumSubst) = ptrS
                        Substitution(ptrS) = -1
                        do i=1,nLoad
                            ptrS = ptrS+1
                            Substitution(ptrS) = loadArray(i)
                        end do
                    case default
                        ! do nothing
                end select
            end do
            SubstIdx(NumSubst+1) = ptrS+1
            close(unitXML)
        end if

    end subroutine xml_read_equivalencies


    subroutine xml_write_equivalencies(pathToFile)

        character(len=*), intent(in) :: pathToFile

        call move_to_backup(pathToFile)
        call log_comment('xml_write_equivalencies('//trim(pathToFile)//')')

        open(unit=unitXML, file=pathToFile)
        write(unitXML,AFORMAT) XML_DOC

        call xml_equivalencies(unitXML)

        close(unitXML)

    end subroutine xml_write_equivalencies



    subroutine xml_equivalencies(unitXML)

        integer, intent(in) :: unitXML
        integer :: idx, tdx
        character(len=255) :: mesg

        write(unitXML,AFORMAT) '<'//XML_ROOT_EQUIVALENCIES//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        Equivalence - to indicate allowed automatic substitutions in all curricula', &
            '            Subjects in a list which are required in a curriculum will', &
            '            be considered "passed" if the rest of the subjects in the list have earned credits', &
            '    </comment>'
        do tdx=1,NumSubst
            if (Substitution(SubstIdx(tdx))==-1) then
                mesg = SPACE
                do idx=SubstIdx(tdx)+1, SubstIdx(tdx+1)-1
                    mesg = trim(mesg)//COMMA//Subject(Substitution(idx))%Name
                end do
                call xml_write_character(unitXML, indent0, 'Equivalence', mesg(2:))
            end if
        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_EQUIVALENCIES//'>'

    end subroutine xml_equivalencies



    subroutine xml_read_intake(path, errNo)

        character(len=*), intent(in) :: path
        integer, intent (out) :: errNo

        integer :: idxCURR
        character (len=MAX_LEN_CURRICULUM_CODE) :: tCurriculum

        ! open file, return on any error
        fileName = trim(path)//'INTAKE.XML'
        call xml_read_file(unitXML, XML_ROOT_INTAKE, fileName, errNo)
        if (errNo/=0) return

        ! examine the file line by line
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('/'//XML_ROOT_INTAKE)
                    exit

                case ('Intake')
                    call index_to_delimiters(COMMA, value, ndels, pos)
                    tCurriculum = value(:pos(2)-1)
                    idxCURR = index_to_curriculum(tCurriculum)
                    if (idxCURR == 0) then
                        cycle
                    else if (idxCURR <= 0) then
                        idxCURR = -idxCURR
                    end if
                    NFintake(idxCURR) = atoi(value(pos(2)+1:pos(3)-1))

                case default ! do nothing

            end select

        end do

        close(unitXML)

    end subroutine xml_read_intake


    subroutine xml_write_intake(path)

        character(len=*), intent(in) :: path

        fileName = trim(path)//'INTAKE.XML'
        call move_to_backup(fileName)
        call log_comment('xml_write_intake('//trim(fileName)//')')

        open(unit=unitXML, file=fileName)
        write(unitXML,AFORMAT) XML_DOC

        call xml_intake(unitXML)

        close(unitXML)

    end subroutine xml_write_intake



    subroutine xml_intake(unitXML)

        integer, intent(in) :: unitXML
        integer :: idxCURR

        write(unitXML,AFORMAT) '<'//XML_ROOT_INTAKE//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)//FSLASH// &
                        currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        Intake - curriculum,count', &
            '    </comment>'

        do idxCURR=1,NumCurricula
            if (NFintake(idxCURR)==0) cycle
            call xml_write_character(unitXML, indent0, 'Intake', &
                trim(Curriculum(idxCURR)%Code)//COMMA//itoa(NFintake(idxCURR)) )
        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_INTAKE//'>'

    end subroutine xml_intake



!===========================================================
! routines for sections
!===========================================================


    subroutine read_classes(path, iTerm, NumSections, Section, Offering, errNo, backupFile)

        character(len=*), intent(in) :: path
        type (TYPE_SECTION), intent(in out) :: Section(0:)
        integer, intent (in) :: iTerm
        integer, intent (in out) :: NumSections
        type (TYPE_OFFERED_SUBJECTS), intent (in out), dimension (MAX_ALL_DUMMY_SUBJECTS:MAX_ALL_SUBJECTS) :: Offering
        integer, intent (out) :: errNo
        character(len=*), intent(in), optional :: backupFile

        integer :: ierr

        errNo = 0 ! 0 is OK; there might be no classes entered yet
        NumSections = 0
        call initialize_section (Section(0))
        Section(:) = Section(0)

        if ( present(backupFile) )then
            fileName = trim(path)//backupFile
        else
            fileName = trim(path)//'CLASSES.XML'
        end if
        call xml_read_classes(fileName, iTerm, NumSections, Section, ierr)

        ! sort & summarize
        call offerings_sort(NumSections, Section)
        call offerings_summarize(NumSections, Section, Offering, 0)

    end subroutine read_classes


    subroutine xml_read_classes(fName, iTerm, NumSections, Section, errNo)

        character(len=*), intent(in) :: fName
        type (TYPE_SECTION), intent(in out) :: Section(0:)
        integer, intent (in) :: iTerm
        integer, intent (in out) :: NumSections
        integer, intent (out) :: errNo

        integer :: i, j, k
        character(len=MAX_LEN_XML_LINE) :: value
        character(len=MAX_LEN_XML_TAG) :: tag
        type(TYPE_SECTION) :: wrkSection
        integer :: btime, dayidx(6), etime, ndays, iidx, pDASH
        integer :: subj, rmidx, tidx
        character (len = 1) :: ch
        character (len=5) :: strBTime, strETime
        character (len=MAX_LEN_DEPARTMENT_CODE) :: tDept
        character (len=MAX_LEN_SUBJECT_CODE) :: tSubject
        character (len=MAX_LEN_CLASS_ID) :: token
        character (len=MAX_LEN_ROOM_CODE) :: tRoom
        character (len=MAX_LEN_TEACHER_CODE) :: tTeacher
        logical :: flag

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_SECTIONS//trim(txtSemester(iTerm)), fName, errNo)
        if (errNo/=0) then
            call log_comment ('ierr='//itoa(errNo)//' when opening '//fName)
            return
        end if

        ! examine the file line by line
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('Section') ! initialize temporary section data
                    call initialize_section(wrkSection)

                case ('Subject') ! subject code
                    tSubject = adjustl(value)
                    subj = index_to_subject(tSubject)
                    if (subj<=0) then
                        errNo = 141
                        call log_comment (trim(value)//' : subject not in catalog')
                        return
                    end if
                    wrkSection%SubjectIdx = subj

                case ('Class') ! section code
                    wrkSection%Code = adjustl(value)

                case ('GradesIn') ! grade submission date
                    wrkSection%GradeSubmissionDate = adjustl(value)

                case ('Owner') ! available seats in class
                    tDept = adjustl(value)
                    iidx = index_to_dept (tDept)
                    if (iidx==0) iidx = NumDepartments ! Registrar
                    wrkSection%DeptIdx = iidx

                case ('Seats') ! available seats in class
                    wrkSection%Slots = atoi(value)

                case ('Meeting') ! a meeting
                   ! do nothing for now

                case ('Time') ! begin, end times
                    j = index(value, '-')
                    if (j==0) then ! assume TBA
                        btime = 0
                        etime = 0
                    else
                        strBTime = value(1:j-1)
                        strETime = value(j+1:)
                        btime = index_to_time(strBTime)
                        etime = index_to_time(strETime)
                        if (etime<btime) then ! begin time is later than end time; assume evening class
                            etime = etime+48
                            call log_comment (trim(value)//' - assuming '//strETime//' is evening...')
                        end if
                    end if

                case ('Day') !   days
                    ndays = 0
                    dayidx = 0
                    k = len_trim(value)
                    if (value(:k)/='TBA') then
                        pDASH = -1
                        do i=1,k
                            ch = value(i:i)
                            iidx = 0
                            if (ch=='M') then
                                iidx = 1
                            else if (ch=='-') then
                                pDASH = i
                            else if (ch=='T') then
                                if (value(i+1:i+1)=='h' .or. value(i+1:i+1)=='H') then
                                    iidx = 4
                                else
                                    iidx = 2
                                end if
                            else if (ch=='W') then
                                iidx = 3
                            else if (ch=='F') then
                                iidx = 5
                            else if (ch=='S') then
                                iidx = 6
                            end if
                            if (iidx>0) then
                                ndays = ndays+1
                                if (ndays>6) then
                                    call log_comment('Too many days: '//trim(value))
                                    ndays = 1 ! force to be TBA
                                    dayidx = 0
                                    btime = 0
                                    etime = 0
                                    exit
                                end if
                                dayidx(ndays) = iidx
                                if (pDASH==i-1) then
                                    do j=dayidx(ndays-1)+1,iidx
                                        dayidx(ndays) = j
                                        ndays = ndays+1
                                    end do
                                    ndays = ndays-1
                                end if
                            end if
                        end do
                    else
                        ndays = 1 ! count TBA day-time as 1 meeting
                    end if

                case ('Room') ! room
                    tRoom = adjustl(value)
                    if (tRoom=='TBA') then
                        rmidx = 0
                    else
                        rmidx = index_to_room (tRoom)
                        if (rmidx==0) then
                            call log_comment (trim(value)//' - '//trim(tRoom)//' room is not valid; using TBA')
                        end if
                    end if

                case ('Teacher') ! teacher
                    tTeacher = adjustl(value)
                    if (tTeacher=='TBA') then
                        tidx = 0
                    else
                        tidx = index_to_teacher (tTeacher)
                        if (tidx==0) then
                            call log_comment (trim(value)//' - '//trim(tTeacher)//' teacher is not valid; using TBA')
                        end if
                    end if

                case ('/Meeting') ! transfer to list of meetings
                    k = wrkSection%NMeets
                    wrkSection%DayIdx(k+1:k+ndays) = dayidx(1:ndays)
                    wrkSection%bTimeIdx(k+1:k+ndays) = btime
                    wrkSection%eTimeIdx(k+1:k+ndays) = etime
                    wrkSection%RoomIdx(k+1:k+ndays) = rmidx
                    wrkSection%TeacherIdx(k+1:k+ndays) = tidx
                    wrkSection%NMeets = wrkSection%NMeets + ndays

                case ('/Section') ! make ClassId, then add to list of sections
                    token = trim(Subject(wrkSection%SubjectIdx)%Name)//SPACE//wrkSection%Code
                    wrkSection%ClassId = token
                    flag = .true.
                    do i=1,NumSections
                        if (Section(i)%ClassId .ne. wrkSection%ClassId) cycle
                        flag = .false.
                        exit
                    end do
                    if (flag) then
                        NumSections = NumSections + 1
                        call check_array_bound (NumSections, MAX_ALL_SECTIONS, 'MAX_ALL_SECTIONS')
                        Section(NumSections) = wrkSection
                    else
                        call log_comment ('In '//trim(fName)//' : '//trim(wrkSection%ClassId)// &
                            ' owned by '//trim(tDept)//' - duplicate class; ignored.')
                    end if

                case default
                    if ( trim(tag)=='/'//XML_ROOT_SECTIONS//trim(txtSemester(iTerm)) ) exit

            end select
        end do

        close(unitXML)
        call log_comment (itoa(NumSections)//' sections after reading '//fName)

    end subroutine xml_read_classes



    subroutine xml_write_classes(path, NumSections, Section, iDept)

        character(len=*), intent(in) :: path
        type (TYPE_SECTION), intent(in) :: Section(0:)
        integer, intent (in) :: NumSections
        integer, intent (in) :: iDept
        integer :: iTerm

        ! all sections, or only the sections for given department?
        if (iDept>0) then
            fileName = trim(path)//'CLASSES-'//trim(Department(iDept)%Code)//'.XML'
        else
            fileName = trim(path)//'CLASSES.XML'
        end if
        do iTerm=1,3
            if (index(path, trim(txtSemester(iTerm)))>0) exit
        end do

        call move_to_backup(fileName)
        call html_comment('xml_write_classes('//trim(fileName)//')')

        open(unit=unitXML, file=fileName)
        write(unitXML,AFORMAT) XML_DOC

        call xml_classes(unitXML, NumSections, Section, iDept, iTerm)

        close(unitXML)

    end subroutine xml_write_classes



    subroutine xml_classes(unitXML, NumSections, Section, iDept, iTerm)

        type (TYPE_SECTION), intent(in) :: Section(0:)
        integer, intent (in) :: unitXML, NumSections, iDept, iTerm

        integer :: sdx, mdx, subj

        write(unitXML,AFORMAT) '<'//XML_ROOT_SECTIONS//trim(txtSemester(iTerm))//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        Subject - subject code', &
            '        Class - class code, to differentiate classes for the same subject', &
            '        GradesIn - Date when grades were submitted', &
            '        Owner - responsible department', &
            '        Slots - class capacity', &
            '        BlockID - block code, if class is assigned to a blocked section', &
            '        Meeting - a class meeting', &
            '        Time - begin time - end time of meeting', &
            '        Days - days of meetings', &
            '        Room - code for meeting room', &
            '        Teacher - code for teacher of meeting', &
            '    </comment>'

        do sdx=1,NumSections
            subj = Section(sdx)%SubjectIdx
            if (subj==0) cycle
            !write(*,*) Section(sdx)%ClassId, Section(sdx)%SubjectIdx

            ! subject belongs to given department?
            if (iDept>0 .and. Section(sdx)%DeptIdx/=iDept) cycle

            if (is_regular_schedule(sdx, Section)) then

                ! class is "regular": single entry for all meetings
                call xml_write_character(unitXML, indent0, 'Section')
                call xml_write_character(unitXML, indent1, 'Subject', Subject(subj)%Name)
                call xml_write_character(unitXML, indent1, 'Class', Section(sdx)%Code)
                if (len_trim(Section(sdx)%GradeSubmissionDate)>0) &
                    call xml_write_character(unitXML, indent1, 'GradesIn', Section(sdx)%GradeSubmissionDate)
                call xml_write_character(unitXML, indent1, 'Owner', Department(Section(sdx)%DeptIdx)%Code)
                call xml_write_integer(unitXML,   indent1, 'Seats', Section(sdx)%Slots)
                call xml_write_character(unitXML, indent1, 'Meeting')
                call xml_write_character(unitXML, indent2, 'Time', text_time_period(Section(sdx)%bTimeIdx(1), &
                    Section(sdx)%eTimeIdx(1)))
                call xml_write_character(unitXML, indent2, 'Day', text_days_of_section(Section(sdx)))
                call xml_write_character(unitXML, indent2, 'Room', Room(Section(sdx)%RoomIdx(1))%Code)
                call xml_write_character(unitXML, indent2, 'Teacher', Teacher(Section(sdx)%TeacherIdx(1))%TeacherId)
                call xml_write_character(unitXML, indent1, '/Meeting')
                call xml_write_character(unitXML, indent0, '/Section')

            else ! class is "irregular": one entry for each meeting
                call xml_write_character(unitXML, indent0, 'Section')
                call xml_write_character(unitXML, indent1, 'Subject', Subject(subj)%Name)
                call xml_write_character(unitXML, indent1, 'Class', Section(sdx)%Code)
                if (len_trim(Section(sdx)%GradeSubmissionDate)>0) &
                    call xml_write_character(unitXML, indent1, 'GradesIn', Section(sdx)%GradeSubmissionDate)
                call xml_write_character(unitXML, indent1, 'Owner', Department(Section(sdx)%DeptIdx)%Code)
                call xml_write_integer(unitXML,   indent1, 'Seats', Section(sdx)%Slots)
                do mdx=1,Section(sdx)%NMeets
                    call xml_write_character(unitXML, indent1, 'Meeting')
                    call xml_write_character(unitXML, indent2, 'Time', text_time_period(Section(sdx)%bTimeIdx(mdx), &
                        Section(sdx)%eTimeIdx(mdx)))
                    call xml_write_character(unitXML, indent2, 'Day', txtDay(Section(sdx)%DayIdx(mdx)))
                    call xml_write_character(unitXML, indent2, 'Room', Room(Section(sdx)%RoomIdx(mdx))%Code)
                    call xml_write_character(unitXML, indent2, 'Teacher', Teacher(Section(sdx)%TeacherIdx(mdx))%TeacherId)
                    call xml_write_character(unitXML, indent1, '/Meeting')
                end do
                call xml_write_character(unitXML, indent0, '/Section')
            end if

        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_SECTIONS//trim(txtSemester(iTerm))//'>'

    end subroutine xml_classes


!===========================================================
! routines for blocks
!===========================================================


    subroutine read_blocks(path, iTerm, NumBlocks, Block, NumSections, Section, errNo, backupFile)

        character(len=*), intent(in) :: path
        integer, intent (in) :: NumSections, iTerm
        type (TYPE_SECTION), intent(in) :: Section(0:)
        integer, intent (out) :: NumBlocks
        type (TYPE_BLOCK), intent(out) :: Block(0:)
        integer, intent (out) :: errNo
        character(len=*), intent(in), optional :: backupFile

        integer :: blk, ierr, numEntries

        NumBlocks = 0
        call initialize_block(Block(0))
        Block(:) = Block(0)

        errNo = 0 ! no blocks is OK; none may be defined yet
        if ( present(backupFile) )then
            fileName = trim(path)//backupFile
        else
            fileName = trim(path)//'BLOCKS.XML'
        end if
        call xml_read_blocks(fileName, iTerm, NumBlocks, Block, NumSections, Section, ierr)

        ! compress block array
        numEntries = 0
        do blk=1,NumBlocks
            !write(*,*) blk, Block(blk)%BlockID, Block(blk)%CurriculumIdx
            if (Block(blk)%CurriculumIdx/=0) then
                numEntries = numEntries+1
                Block(numEntries) = Block(blk)
                !write(*,*) 'Adding ', mainEntries, Block(blk)%BlockID
            end if
        end do
        NumBlocks = numEntries

        call sort_alphabetical_blocks(NumBlocks, Block)

    end subroutine read_blocks



    subroutine xml_read_blocks(fName, iTerm, NumBlocks, Block, NumSections, Section, errNo)

        character(len=*), intent(in) :: fName ! YEAR/TERM/BLOCKS(-CURR)
        integer, intent (in) :: iTerm, NumSections
        type (TYPE_SECTION), intent(in) :: Section(0:)
        integer, intent (out) :: NumBlocks
        type (TYPE_BLOCK), intent(out) :: Block(0:)
        integer, intent (out) :: errNo

        type (TYPE_BLOCK) :: wrkBlock
        character (len=MAX_LEN_CURRICULUM_CODE) :: tCurriculum
        character (len=MAX_LEN_DEPARTMENT_CODE) :: tDepartment
        character (len=MAX_LEN_SUBJECT_CODE) :: tSubject
        character (len=MAX_LEN_CLASS_ID) :: tSection
        character (len=MAX_LEN_XML_LINE) :: value
        character (len=MAX_LEN_XML_TAG) :: tag
        logical :: flag
        integer :: i, idxCurr, idxSubj, idxSect, loc

        ! open file, return on any error
        call xml_read_file(unitXML, XML_ROOT_BLOCKS//trim(txtSemester(iTerm)), fName, errNo)
        if (errNo/=0) then
            call log_comment ('ierr='//itoa(errNo)//' when opening '//fName)
            return
        end if

        ! examine the file line by line
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit
            select case (trim(tag))

                case ('Block')
                    call initialize_block(wrkBlock)

                case ('Code')
                    wrkBlock%BlockID = adjustl(value)

                case ('Description')
                    wrkBlock%Name = adjustl(value)

                case ('Curriculum')
                    tCurriculum = adjustl(value)
                    idxCurr = index_to_curriculum(tCurriculum)
                    if (idxCurr<0) then
                        idxCurr = -idxCurr
                    else if (idxCurr==0) then
                        idxCurr =NumCurricula
                    end if
                    wrkBlock%CurriculumIdx = idxCurr

                case ('Year')
                    wrkBlock%Year = atoi(value)

                case ('Term')
                    wrkBlock%Term = atoi(value)
                    if (wrkBlock%Term==0) wrkBlock%Term = 3

                case ('Owner')
                    tDepartment = adjustl(value)
                    wrkBlock%DeptIdx = index_to_dept(tDepartment)
                    if (wrkBlock%DeptIdx==0) wrkBlock%DeptIdx = NumDepartments

                case ('Subject')
                    tSubject = adjustl(value)
                    idxSubj = index_to_subject(tSubject)
                    if (idxSubj==0) cycle

                    ! check if duplicate
                    loc = 0 ! not found
                    do i=1,wrkBlock%NumClasses
                        if (wrkBlock%Subject(i)==idxSubj) then
                            loc = i
                            exit
                        end if
                    end do
                    if (loc==0) then ! not a duplicate
                        wrkBlock%NumClasses = wrkBlock%NumClasses + 1
                        wrkBlock%Subject(wrkBlock%NumClasses) = idxSubj
                    else
                        call log_comment ('In '//trim(fName)//' : '//trim(WrkBlock%BlockID)// &
                            ' duplicate subject '//trim(tSubject)//'; ignored.')
                    end if

                case ('Section')
                    tSection = adjustl(value)
                    idxSect = index_to_section(tSection, NumSections, Section)
                    if (idxSect==0) cycle ! section does not exist

                    idxSubj = Section(idxSect)%SubjectIdx
                    ! check if duplicate
                    loc = 0 ! not found
                    do i=1,wrkBlock%NumClasses
                        if (wrkBlock%Subject(i)==idxSubj) then
                            loc = i
                            exit
                        end if
                    end do
                    if (loc==0) then ! not a duplicate
                        loc = wrkBlock%NumClasses + 1
                        wrkBlock%NumClasses = loc
                        wrkBlock%Subject(loc) = idxSubj
                        wrkBlock%Section(loc) = idxSect
                    elseif (wrkBlock%Section(loc)==0) then ! duplicate subject and prior entry had no section
                        wrkBlock%Section(loc) = idxSect
                    else ! duplicate subject and prior entry had a section
                        call log_comment ('In '//trim(fName)//' : '//trim(WrkBlock%BlockID)// &
                            ' using section '//trim(tSection)//' instead of earlier entry '// &
                            Section(wrkBlock%Section(loc))%ClassID)
                        wrkBlock%Section(loc) = idxSect
                    end if

                case ('/Block')
                    flag = .true.
                    do idxCurr=1,NumBlocks
                        if (wrkBlock%BlockID/=Block(idxCurr)%BlockID) cycle
                        flag = .false.
                        exit
                    end do
                    if (flag) then
                        NumBlocks = NumBlocks + 1
                        call check_array_bound (NumBlocks, MAX_ALL_BLOCKS, 'MAX_ALL_BLOCKS')
                        Block(NumBlocks) = wrkBlock
                    else
                        call log_comment ('In '//trim(fName)//' : '//trim(WrkBlock%BlockID)// &
                            ' owned by '//trim(tDepartment)//' - duplicate block; ignored.')
                    end if

                case default
                    if (trim(tag)=='/'//XML_ROOT_BLOCKS//trim(txtSemester(iTerm)) ) exit

                    ! do nothing
            end select
        end do
        close(unitXML)
        call log_comment (itoa(NumBlocks)//' blocks after reading '//fName)

    end subroutine xml_read_blocks



    subroutine xml_write_blocks(path, NumBlocks, Block, Section, iDept)

        integer, intent (in) :: iDept, NumBlocks
        character(len=*), intent(in) :: path
        type (TYPE_BLOCK), intent(in) :: Block(0:)
        type (TYPE_SECTION), intent(in) :: Section(0:)
        integer :: iTerm

        ! generate file name
        if (iDept>0) then
            fileName = trim(path)//'BLOCKS-'//trim(Department(iDept)%Code)//'.XML'
        else
            fileName = trim(path)//'BLOCKS.XML'
        end if
        do iTerm=1,3
            if (index(path, trim(txtSemester(iTerm)))>0) exit
        end do

        call move_to_backup(fileName)
        call html_comment('xml_write_blocks('//trim(fileName)//')')

        open(unit=unitXML, file=fileName)
        write(unitXML,AFORMAT) XML_DOC

        call xml_blocks(unitXML, NumBlocks, Block, Section, iDept, iTerm)

        close(unitXML)

    end subroutine xml_write_blocks



    subroutine xml_blocks(unitXML, NumBlocks, Block, Section, iDept, iTerm)

        integer, intent (in) :: unitXML, iDept, NumBlocks, iTerm
        type (TYPE_BLOCK), intent(in) :: Block(0:)
        type (TYPE_SECTION), intent(in) :: Section(0:)

        integer :: blk, sect, i

        write(unitXML,AFORMAT) '<'//XML_ROOT_BLOCKS//trim(txtSemester(iTerm))//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        Code - Block identifier', &
            '        Curriculum - Curricular program for block', &
            '        Description - Block description', &
            '        Year - Year level in curriculum', &
            '        Term - Term of the year in curriculum', &
            '        Owner - Department that created (thus, can modify) block', &
            '        Section - Section already assigned to a subject', &
            '        Subject - Subject not yet assigned a section', &
            '    </comment>'

        ! loop over blocks
        do blk=1,NumBlocks

            ! block was created / is modifiable by given department?
            if (iDept>0 .and. Block(blk)%DeptIdx/=iDept) cycle

            ! any classes assigned to this block?
            if (Block(blk)%NumClasses==0) cycle

            ! block info start
            call xml_write_character(unitXML, indent0, 'Block')
            call xml_write_character(unitXML, indent1, 'Code', Block(blk)%BlockID)
            call xml_write_character(unitXML, indent1, 'Description', Block(blk)%Name)
            call xml_write_character(unitXML, indent1, 'Curriculum', Curriculum(Block(blk)%CurriculumIdx)%Code)
            call xml_write_integer(unitXML,   indent1, 'Year', Block(blk)%Year)
            call xml_write_integer(unitXML,   indent1, 'Term', Block(blk)%Term)
            call xml_write_character(unitXML, indent1, 'Owner', Department(Block(blk)%DeptIdx)%Code)

            ! write classes assigned to block
            do i=1,Block(blk)%NumClasses
                sect = Block(blk)%Section(i)
                if (sect==0) then
                    call xml_write_character(unitXML, indent2, 'Subject', Subject(Block(blk)%Subject(i))%Name)
                else
                    call xml_write_character(unitXML, indent2, 'Section', Section(sect)%ClassId)
                end if
            end do

            ! block info end
            call xml_write_character(unitXML, indent0, '/Block')
        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_BLOCKS//trim(txtSemester(iTerm))//'>'

    end subroutine xml_blocks


!===========================================================
! routines for students
!===========================================================


    subroutine read_students(path, errNo)

        character(len=*), intent(in) :: path
        integer, intent (out) :: errNo

        integer :: iCurr, ierr, i, partialEntries, mainEntries

        errNo = 0 ! errors or 'not found' are OK; there might be no students entered yet

        call xml_read_students (path, 0, mainEntries, ierr)

        ! check for students added by program advisers
        done = .false.
        do iCurr=1,NumCurricula
            if (done(iCurr)) cycle
            call xml_read_students (path, iCurr, partialEntries, ierr)
            do i = iCurr+1,NumCurricula
                if (CurrProgCode(iCurr)==CurrProgCode(i)) done(i) = .true.
            end do
        end do

        if (NumStudents>mainEntries) call xml_write_students(path, 0)

        ! update advisee counts
        do i=1,NumTeachers+NumAdditionalTeachers
            Teacher(i)%NumAdvisees = 0
        end do
        do i=1,NumStudents+NumAdditionalTeachers
            iCurr = index_to_teacher(Student(i)%Adviser)
            Teacher(iCurr)%NumAdvisees = Teacher(iCurr)%NumAdvisees + 1
        end do

    end subroutine read_students



    subroutine xml_read_students(path, iCurr, numEntries, errNo, backupFile)

        character(len=*), intent(in) :: path ! YEAR/TERM/
        integer, intent (in) :: iCurr
        integer, intent (out) :: numEntries, errNo
        character(len=*), intent(in), optional :: backupFile

        type (TYPE_STUDENT) :: wrkStudent
        character (len=MAX_LEN_CURRICULUM_CODE) :: tCurriculum
        integer :: indexLoc, idxCurr

        ! generate file name
        if (iCurr>0) then
            fileName = trim(path)//'STUDENTS-'//trim(CurrProgCode(iCurr))//'.XML'
        elseif ( present(backupFile) ) then
            fileName = trim(path)//backupFile
        else
            fileName = trim(path)//'STUDENTS.XML'
        end if

        ! open file, return on any error
        numEntries = 0
        call xml_read_file(unitXML, XML_ROOT_STUDENTS, fileName, errNo)
        if (errNo/=0) return

        ! examine the file line by line
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('/'//XML_ROOT_STUDENTS)
                    exit

                case ('Student')
                    call initialize_student(wrkStudent)

                case ('StdNo')
                    wrkStudent%StdNo = adjustl(value)
                    call upper_case(wrkStudent%StdNo)

                case ('Name')
                    wrkStudent%Name = adjustl(value)
                    call upper_case(wrkStudent%Name)

                case ('BirthDate')
                    !wrkStudent%BirthDate = adjustl(value)

                case ('EntryDate')
                    !wrkStudent%EntryDate = adjustl(value)

                case ('BirthPlace')
                    !wrkStudent%BirthPlace = adjustl(value)

                case ('HomeAddress')
                    !wrkStudent%HomeAddress = adjustl(value)

                case ('LastAttended')
                    !wrkStudent%LastAttended = adjustl(value)

                case ('Gender')
                    wrkStudent%Gender = adjustl(value)

                case ('Password')
                    wrkStudent%Password = adjustl(value)

                case ('Adviser')
                    wrkStudent%Adviser = adjustl(value)

                case ('Curriculum')
                    tCurriculum = adjustl(value)
                    idxCurr = index_to_curriculum(tCurriculum)
                    if (idxCurr<0) then
                        idxCurr = -idxCurr
                    else if (idxCurr==0) then
                        idxCurr = NumCurricula
                    end if
                    wrkStudent%CurriculumIdx = idxCurr

                case ('Country')
                    !wrkStudent%CountryIdx = atoi(value)

                case ('Classification')
                    wrkStudent%Classification = atoi(value)

                case ('/Student')
                    if (len_trim(wrkStudent%StdNo)==0) cycle
                    if (len_trim(wrkStudent%Password)==0) then
                        call set_password(wrkStudent%Password)
                        isDirtySTUDENTS = .true.
                    end if
                    call update_student_info(wrkStudent, indexLoc)
                    if (indexLoc<0) numEntries = numEntries + 1

                case default
                    ! do nothing
            end select
        end do
        close(unitXML)
        call log_comment (itoa(numEntries)//' students from '//fileName)

    end subroutine xml_read_students



    subroutine xml_write_students(path, iCurr)

        integer, intent (in) :: iCurr
        character(len=*), intent(in) :: path ! YEAR/TERM/
        integer :: i, j

        ! generate file name
        if (iCurr>0) then
            fileName = trim(path)//'STUDENTS-'//trim(CurrProgCode(iCurr))//'.XML'
        else
            fileName = trim(path)//'STUDENTS.XML'
        end if

        call move_to_backup(fileName)
        call log_comment('xml_write_students('//trim(fileName)//')')

        ! write file
        open(unit=unitXML, file=fileName)
        write(unitXML,AFORMAT) XML_DOC

        call xml_students(unitXML, iCurr)

        close(unitXML)

        if (iCurr==0) then ! remove STUDENTS-<curr>.XML
            isDirtySTUDENTS = .false.
            done = .false.
            do j=1,NumCurricula
                if (done(j)) cycle
                call move_to_backup(trim(path)//'STUDENTS-'//trim(CurrProgCode(j))//'.XML')
                do i = j+1,NumCurricula
                    if (CurrProgCode(j)==CurrProgCode(i)) done(i) = .true.
                end do
            end do
        end if

    end subroutine xml_write_students



    subroutine xml_students(unitXML, iCurr)

        integer, intent(in) :: unitXML
        integer, intent (in) :: iCurr

        integer :: std, idx

        write(unitXML,AFORMAT) '<'//XML_ROOT_STUDENTS//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        StdNo - Student number', &
            '        Name - Student name', &
            '        Password - Encrypted password', &
            '        Adviser - TeacherId of adviser', &
            '        Curriculum - Curriculum code', &
            '        Classification - 0=undetermined; 1=NF, 2=SO, 3=JR, 4=SR', &
            '    </comment>'

        ! loop over students
        do std=1,NumStudents+NumAdditionalStudents

            if (len_trim(Student(std)%StdNo)==0) cycle
            !if (Student(std)%Classification>=NotOfficiallyEnrolled .and. &
            !    sum(Enlistment(1:3,std)%lenSubject)==0) cycle ! no record for previous, current, next terms

            idx = Student(std)%CurriculumIdx
            if (iCurr>0) then
                if (CurrProgCode(idx)/=CurrProgCode(iCurr)) cycle
            end if

            call xml_write_character(unitXML, indent0, 'Student')

            call xml_write_character(unitXML, indent1, 'StdNo', Student(std)%StdNo)

            call xml_write_character(unitXML, indent1, 'Name', Student(std)%Name)

            !if (len_trim(Student(std)%BirthDate)/=0) &
            !    call xml_write_character(unitXML, indent1, 'BirthDate', Student(std)%BirthDate)

            !if (len_trim(Student(std)%EntryDate)/=0) &
            !    call xml_write_character(unitXML, indent1, 'EntryDate', Student(std)%EntryDate)

            !if (len_trim(Student(std)%BirthPlace)/=0) &
            !    call xml_write_character(unitXML, indent1, 'BirthPlace', Student(std)%BirthPlace)

            !if (len_trim(Student(std)%HomeAddress)/=0) &
            !    call xml_write_character(unitXML, indent1, 'HomeAddress', Student(std)%HomeAddress)

            !if (len_trim(Student(std)%LastAttended)/=0) &
            !    call xml_write_character(unitXML, indent1, 'LastAttended', Student(std)%LastAttended)

            call xml_write_character(unitXML, indent1, 'Gender', Student(std)%Gender)

            call xml_write_character(unitXML, indent1, 'Password', Student(std)%Password)

            if (len_trim(Student(std)%Adviser)/=0) &
                call xml_write_character(unitXML, indent1, 'Adviser', Student(std)%Adviser)

            !if (Student(std)%CountryIdx/=1) &
            !    call xml_write_integer(unitXML,   indent1, 'Country', Student(std)%CountryIdx)

            call xml_write_character(unitXML, indent1, 'Curriculum', Curriculum(idx)%Code)

            if (Student(std)%Classification/=0) &
                call xml_write_integer(unitXML,   indent1, 'Classification', Student(std)%Classification)

            call xml_write_character(unitXML, indent0, '/Student')
        end do
        write(unitXML,AFORMAT) '</'//XML_ROOT_STUDENTS//'>'

    end subroutine xml_students


!===========================================================
! routines for pre-enlistment
!===========================================================

    subroutine read_enlistment(path, iTerm, basename, firstGrp, lastGrp, NumSections, Section, &
        eList, numEntries, errNo, backupFile)

        character(len=*), intent(in) :: path, basename ! YEAR/TERM
        integer, intent (in) :: firstGrp, lastGrp, NumSections, iTerm
        type (TYPE_SECTION), intent(in out) :: Section(0:)
        type (TYPE_PRE_ENLISTMENT), intent(out) :: eList(0:)
        integer, intent (in out) :: numEntries
        character (len=*), intent(in), optional :: backupFile
        integer, intent (out) :: errNo

        integer :: grp, mainEntries, partialEntries, ierr
        logical :: noXML


        numEntries = 0
        call initialize_pre_enlistment(eList(0))
        eList(:) = eList(0)
        errNo = 0 ! OK if there's no enlistment record

        ! read the university-level data
        if ( present(backupFile) ) then
            fileName = backupFile
        else
            fileName = basename
        end if
        grp = index(fileName, '.XML')
        if (grp>0) fileName(grp:) = SPACE

        ! try the monolithic XML file
        call xml_read_pre_enlistment(path, iTerm, fileName, NumSections, Section, eList, numEntries, errNo)
        noXML = numEntries==0
        mainEntries = numEntries
        if (noXML) then
            ! try each priority group
            do grp=firstGrp, lastGrp
                fileName = 'ENLISTMENT-'//itoa(grp)
                call xml_read_pre_enlistment(path, iTerm, fileName, NumSections, Section, eList, &
                    partialEntries, ierr)
                numEntries = numEntries + partialEntries
                if (partialEntries>0) then ! not empty; move to backup
                    call move_to_backup(trim(path)//trim(fileName)//'.XML')
                end if
            end do
        end if
        ! get curriculum group enlistment if any
        done = .false.
        do grp=1,NumCurricula
            if (done(grp)) cycle
            fileName = 'ENLISTMENT-'//CurrProgCode(grp)
            call xml_read_pre_enlistment(path, iTerm, fileName, NumSections, Section, eList, partialEntries, ierr)
            numEntries = numEntries + partialEntries
            if (partialEntries>0) then ! not empty; move to backup
                call move_to_backup(trim(path)//trim(fileName)//'.XML')
            end if
            do ierr=grp,NumCurricula
                if (CurrProgCode(grp)==CurrProgCode(ierr)) done(ierr) = .true.
            end do
        end do

        if (numEntries>mainEntries) then ! write the XML enlistment file?
            call xml_write_pre_enlistment(path, 'ENLISTMENT', eList, Section)
        end if

    end subroutine read_enlistment



    subroutine xml_read_pre_enlistment(path, iTerm, basename, NumSections, Section, eList, numEntries, errNo)

        character(len=*), intent(in) :: path, basename
        integer, intent (in) :: iTerm, NumSections
        type (TYPE_SECTION), intent(in) :: Section(0:)
        type (TYPE_PRE_ENLISTMENT), intent(in out) :: eList(0:)
        integer, intent (out) :: numEntries, errNo

        type(TYPE_PRE_ENLISTMENT) :: wrk
        character (len=MAX_LEN_SUBJECT_CODE) :: tSubject
        character (len=MAX_LEN_CLASS_ID) :: tClass
        character (len=MAX_LEN_STUDENT_CODE) :: tStdNo
        character (len = MAX_LEN_TEXT_GRADE) :: tGrade
        integer :: cdx, idx, sdx, std,gdx, pos, i

        numEntries = 0
        ! open file, return on any error
        fileName = trim(path)//trim(basename)//'.XML'
        call xml_read_file(unitXML, XML_ROOT_ENLISTMENT//trim(txtSemester(iTerm)), fileName, errNo)
        if (errNo/=0) return

        ! examine the file line by line
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('Student') ! initialize temporary college data
                    call initialize_pre_enlistment (wrk)

                case ('StdNo')
                    tStdNo = adjustl(value)
                    std = index_to_student(tStdNo)

                case ('UnitsEarned')
                    wrk%UnitsEarned = atof(value)

                case ('StdYear')
                    wrk%StdYear = atoi(value)

                case ('StdClassification')
                    wrk%StdClassification = atoi(value)

                case ('AllowedLoad')
                    wrk%AllowedLoad = atof(value)

                case ('StdPriority')
                    wrk%StdPriority = atoi(value)

                case ('NPriority')
                    wrk%NPriority = atoi(value)

                case ('NAlternates')
                    wrk%NAlternates = atoi(value)

                case ('NCurrent')
                    wrk%NCurrent = atoi(value)

                case ('Status')
                    wrk%Status = atoi(value)

                case ('ErrNSTP')
                    wrk%errNSTP = atoi(value)

!                case ('Enlisted')
!                    tClass = adjustl(value)
!                    sdx = index_to_section(tClass, NumSections, Section)
!                    if (sdx==0) then ! invalid class; attempt to extract subject
!                        sdx = len_trim(tClass)
!                        do while (sdx>1 .and. tClass(sdx:sdx)/=SPACE)
!                            sdx = sdx-1
!                        end do
!                        tSubject = tClass(:sdx)
!                        cdx = index_to_subject(tSubject)
!                        if (cdx<=0) then ! subject code not found
!                            call log_comment ('No such class; ignored - '//tClass)
!                            cycle
!                        end if
!                        ! add as subject
!                        call check_array_bound (wrk%lenSubject, MAX_SUBJECTS_PER_TERM, 'MAX_SUBJECTS_PER_TERM')
!                        wrk%lenSubject = wrk%lenSubject + 1
!                        wrk%Subject(wrk%lenSubject) = cdx
!                    else ! add as section
!                        call check_array_bound (wrk%lenSubject, MAX_SUBJECTS_PER_TERM, 'MAX_SUBJECTS_PER_TERM')
!                        wrk%lenSubject = wrk%lenSubject + 1
!                        wrk%Section(wrk%lenSubject) = sdx
!                        wrk%Subject(wrk%lenSubject) = Section(sdx)%SubjectIdx
!                        wrk%Grade(wrk%lenSubject) = gdxREGD
!                    end if

                case ('Predicted')
                    idx = index(value, COMMA)
                    tSubject = adjustl(value(:idx-1))
                    cdx = index_to_subject(tSubject)
                    if (cdx<=0) then ! subject code not found
                        call log_comment ('No such subject; ignored - '//tSubject)
                        cycle
                    end if
                    ! check if already among previous entries
                    pos = 0
                    do i=1,wrk%lenSubject
                        if (wrk%Subject(i)==cdx) pos = i
                    end do
                    if (pos==0) then
                        pos = wrk%lenSubject + 1
                        call check_array_bound (pos, MAX_SUBJECTS_PER_TERM, 'MAX_SUBJECTS_PER_TERM')
                        wrk%lenSubject = pos
                    else
                        call log_comment('Using duplicate entry:  '//trim(tStdNo)//DASH//trim(line))
                    end if
                    ! add as predicted subject
                    wrk%Subject(pos) = cdx
                    wrk%Contrib(pos) = atof( trim( value(idx+1:) ) )

                case ('Allowed')
                    tSubject = adjustl(value)
                    cdx = index_to_subject(tSubject)
                    if (cdx<=0) then ! subject code not found
                        call log_comment ('No such subject; ignored - '//tSubject)
                        cycle
                    end if
                    ! check if already among previous entries
                    pos = 0
                    do i=1,wrk%lenSubject
                        if (wrk%Subject(i)==cdx) pos = i
                    end do
                    if (pos==0) then
                        pos = wrk%lenSubject + 1
                        call check_array_bound (pos, MAX_SUBJECTS_PER_TERM, 'MAX_SUBJECTS_PER_TERM')
                        wrk%lenSubject = pos
                        ! add as allowed subject
                        wrk%Subject(pos) = cdx
                        wrk%Contrib(pos) = 0.0
                    else
                        call log_comment('Discarding duplicate entry:  '//trim(tStdNo)//DASH//trim(line))
                    end if

                case ('Graded')
                    idx = index(value, COMMA)
                    tClass = adjustl(value(:idx-1))
                    tGrade = adjustl(value(idx+1:))
                    sdx = index_to_section(tClass, NumSections, Section)
                    gdx = index_to_grade(tGrade)
                    ! check if already among previous entries
                    pos = 0
                    do i=1,wrk%lenSubject
                        if (wrk%Subject(i)==Section(sdx)%SubjectIdx) pos = i
                    end do
                    if (pos==0) then
                        pos = wrk%lenSubject + 1
                        call check_array_bound (pos, MAX_SUBJECTS_PER_TERM, 'MAX_SUBJECTS_PER_TERM')
                        wrk%lenSubject = pos
                    else
                        call log_comment('Using duplicate entry:  '//trim(tStdNo)//DASH//trim(line))
                    end if
                    wrk%Section(pos) = sdx
                    wrk%Subject(pos) = Section(sdx)%SubjectIdx
                    wrk%Grade(pos) = gdx
                    wrk%Contrib(pos) = 1.0

                case ('/Student')
                    if (wrk%NPriority+wrk%NAlternates+wrk%NCurrent /= wrk%lenSubject) then
                        wrk%NPriority = wrk%lenSubject
                        wrk%NAlternates = 0
                        wrk%NCurrent = 0
                    end if
                    if (std/=0) then
                        eList(std) = wrk
                        numEntries = numEntries+1
                    else
                        call log_comment ('No such student; ignored - '//tStdNo)
                    end if

                case default
                    if ( trim(tag)=='/'//XML_ROOT_ENLISTMENT//trim(txtSemester(iTerm)) ) exit

            end select

        end do

        close(unitXML)
        call log_comment (itoa(numEntries)//' pre-enlistment entries in '//fileName)

    end subroutine xml_read_pre_enlistment


    subroutine xml_write_pre_enlistment(path, basename, eList, Section, curriculumFilter)
        character (len=*), intent (in) :: path, basename ! YEAR/TERM/(ENLISTMENT,PREDICTION,WAIVER-COI)
        type (TYPE_PRE_ENLISTMENT), intent(in) :: eList(0:)
        type (TYPE_SECTION), intent(in) :: Section(0:)
        integer, intent (in), optional :: curriculumFilter

        integer :: filter, iTerm

        if (present(curriculumFilter)) then
            filter = curriculumFilter
        else
            filter = 0
        end if

        ! generate file name
        fileName = trim(path)//basename
        if (filter>0) then
            fileName = trim(fileName)//DASH//trim(CurrProgCode(filter))//'.XML'
        else
            fileName = trim(fileName)//'.XML'
        end if
        do iTerm=1,3
            if (index(path, trim(txtSemester(iTerm)))>0) exit
        end do

        call move_to_backup(fileName)
        call html_comment('xml_write_pre_enlistment('//trim(fileName)//')')

        ! write file
        open(unit=unitXML, file=fileName)
        write(unitXML,AFORMAT) XML_DOC

        call xml_pre_enlistment(unitXML, eList, Section, filter, iTerm)

        close(unitXML)

        ! remove curriculum enlistment files
        if (filter==0) then
            done = .false.
            do filter=1,NumCurricula
                if (done(filter)) cycle
                call move_to_backup(trim(path)//trim('ENLISTMENT-'//CurrProgCode(filter))//'.XML')
                do iTerm=filter,NumCurricula
                    if (CurrProgCode(filter)==CurrProgCode(iTerm)) done(iTerm) = .true.
                end do
            end do
        end if

    end subroutine xml_write_pre_enlistment



    subroutine xml_pre_enlistment(unitXML, eList, Section, filter, iTerm)

        integer, intent (in) :: unitXML, filter, iTerm
        type (TYPE_PRE_ENLISTMENT), intent(in) :: eList(0:)
        type (TYPE_SECTION), intent(in) :: Section(0:)

        integer :: std, sect, i, lenRecord, gdx

        write(unitXML,AFORMAT) '<'//XML_ROOT_ENLISTMENT//trim(txtSemester(iTerm))//'>', &
            '    <comment>', &
            '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                        FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
            '        UnitsEarned       : Units earned in curriculum', &
            '        StdClassification : Student classification (25% rule) - 1=FRESHMAN, 2=SOPHOMORE, 3=JUNIOR, 4=SENIOR', &
            '        StdYear           : Year level in curriculum - 1=FIRST, 2=SECOND, 3=THIRD, 4=FOURTH, 5=FIFTH', &
            '        AllowedLoad       : Units to enlist based on year+term level in curriculum', &
            '        StdPriority       : (see below)', &
            '        Status            : 1="Feasible subjects fixed"; 2="Sections fixed"', &
            '        ErrNSTP           : 1="Track mismatch in NSTP 11/12"', &
            '        NPriority         : No. of priority subjects', &
            '        NAlternates       : No. of alternate subjects', &
            '        NCurrent          : No. of subjects currently registered', &
            '        Graded            : Enlisted section', &
            '        Allowed           : Subject with satisfied prerequisite', &
            '        Predicted         : Allowed subject that contributes to demand', &
            '        StdPriority=0     : Manually enlisted ("special-treatment" students)', &
            '        StdPriority=1     : New Student (no record of any grade)', &
            '        StdPriority=2     : Graduating (27 units or less left, no remaining subjects w/ unsatisfied prereqs)', &
            '        StdPriority=3     : Did not fail any subject last sem, or on LOA last sem', &
            '        StdPriority=4     : Failed (0-50%] of units last sem', &
            '        StdPriority=5     : Failed (50%,75%] of units', &
            '        StdPriority=6     : Failed (75%-100%] of units last sem', &
            '        StdPriority=7     : (reserved)', &
            '        StdPriority=8     : (reserved)', &
            '        StdPriority=9     : Subjects not offered, or prerequisites not satisfied', &
            '        StdPriority=10    : Curricular program completed?', &
            '    </comment>'

        do std=1,NumStudents+NumAdditionalStudents
            ! skip student with no record
            lenRecord = max(eList(std)%lenSubject, eList(std)%NPriority+eList(std)%NAlternates+eList(std)%NCurrent)
            if (lenRecord==0) cycle
            ! skip student if curriculum does not match filter
            if (filter>0) then
                if (CurrProgCode(filter)/=CurrProgCode(Student(std)%CurriculumIdx)) cycle
            end if

            ! student info start
            call xml_write_character(unitXML, indent0, 'Student')
            call xml_write_character(unitXML, indent1, 'StdNo', Student(std)%StdNo)
            call xml_write_character(unitXML, indent1, 'Name', Student(std)%Name)
            if (eList(std)%UnitsEarned/=0.0) &
                call xml_write_character  (unitXML, indent1, 'UnitsEarned', ftoa(eList(std)%UnitsEarned,1))
            if (eList(std)%StdYear/=0) &
                call xml_write_integer  (unitXML, indent1, 'StdYear', eList(std)%StdYear)
            if (eList(std)%StdClassification/=0) &
                call xml_write_integer  (unitXML, indent1, 'StdClassification', eList(std)%StdClassification)
            if (eList(std)%AllowedLoad/=0.0) &
                call xml_write_character  (unitXML, indent1, 'AllowedLoad', ftoa(eList(std)%AllowedLoad,1))
            if (eList(std)%StdPriority/=0) &
                call xml_write_integer  (unitXML, indent1, 'StdPriority', eList(std)%StdPriority)
            if (eList(std)%NPriority/=0) &
                call xml_write_integer  (unitXML, indent1, 'NPriority', eList(std)%NPriority)
            if (eList(std)%NAlternates/=0) &
                call xml_write_integer  (unitXML, indent1, 'NAlternates', eList(std)%NAlternates)
            if (eList(std)%NCurrent/=0) &
                call xml_write_integer  (unitXML, indent1, 'NCurrent', eList(std)%NCurrent)
            if (eList(std)%Status/=0) &
                call xml_write_integer  (unitXML, indent1, 'Status', eList(std)%Status)
            if (eList(std)%ErrNSTP/=0) &
                call xml_write_integer  (unitXML, indent1, 'ErrNSTP', eList(std)%errNSTP)

            do i=1,lenRecord
                sect = eList(std)%Section(i)
                if (sect>0) then
                    gdx = eList(std)%Grade(i)
                    !if (gdx>0) then
                        call xml_write_character(unitXML, indent1, 'Graded', &
                            trim(Subject(Section(sect)%SubjectIdx)%Name)//SPACE//trim(Section(sect)%Code)//COMMA// &
                                txtGrade(pGrade(gdx)) )
                    !else
                    !    call xml_write_character(unitXML, indent1, 'Enlisted', &
                    !        trim(Subject(Section(sect)%SubjectIdx)%Name)//SPACE//Section(sect)%Code )
                    !end if
                elseif (eList(std)%Subject(i)>0) then
                    if (eList(std)%Contrib(i)>0.0) then
                        call xml_write_character(unitXML, indent1, 'Predicted', &
                            trim(Subject(eList(std)%Subject(i))%Name)//COMMA//ftoa(eList(std)%Contrib(i),5) )
                    else
                        call xml_write_character(unitXML, indent1, 'Allowed', Subject(eList(std)%Subject(i))%Name)
                    end if
                end if
            end do
            ! student info end
            call xml_write_character(unitXML, indent0, '/Student')
        end do

        write(unitXML,AFORMAT) '</'//XML_ROOT_ENLISTMENT//trim(txtSemester(iTerm))//'>'

    end subroutine xml_pre_enlistment



    subroutine xml_read_waivers(path, iTerm, NumSections, Section, numEntries, errNo, backupFile)

        character(len=*), intent(in) :: path
        integer, intent (in) :: NumSections, iTerm
        type (TYPE_SECTION), intent(in) :: Section(0:)
        integer, intent (out) :: numEntries, errNo
        character(len=*), intent(in), optional :: backupFile

        type(TYPE_WAIVER) :: wrk
        character (len=MAX_LEN_SUBJECT_CODE) :: tSubject
        character (len=MAX_LEN_CLASS_ID) :: tClass
        character (len=MAX_LEN_STUDENT_CODE) :: tStdNo
        integer :: cdx, sdx, std

        numEntries = 0
        ! open file, return on any error
        if (present(backupFile)) then
            fileName = trim(path)//backupFile
        else
            fileName = trim(path)//'WAIVER-COI.XML'
        end if
        call xml_read_file(unitXML, XML_ROOT_WAIVERS//trim(txtSemester(iTerm)), fileName, errNo)
        if (errNo/=0) then
            call log_comment ('ierr='//itoa(errNo)//' when opening '//fileName)
            return
        end if

        ! examine the file line by line
        do
            read(unitXML, AFORMAT, iostat=eof) line
            if (eof<0) exit

            ! get tag and value if any; exit on any error
            call xml_parse_line(line, tag, value, eof)
            if (eof/=0) exit

            select case (trim(tag))

                case ('WaiverCOI') ! initialize temporary data
                    call initialize_waiver (wrk)

                case ('StdNo')
                    tStdNo = adjustl(value)
                    std = index_to_student(tStdNo)

                case ('Section')
                    tClass = adjustl(value)
                    sdx = index_to_section(tClass, NumSections, Section)
                    if (sdx==0) then ! invalid class; attempt to extract subject
                        sdx = len_trim(tClass)
                        do while (sdx>1 .and. tClass(sdx:sdx)/=SPACE)
                            sdx = sdx-1
                        end do
                        tSubject = tClass(:sdx)
                        cdx = index_to_subject(tSubject)
                        if (cdx<=0) then ! subject code not found
                            call log_comment ('No such class; ignored - '//tClass)
                            cycle
                        end if
                        ! add as subject
                        call check_array_bound (wrk%lenSubject, MAX_SUBJECTS_PER_TERM, 'MAX_SUBJECTS_PER_TERM')
                        wrk%lenSubject = wrk%lenSubject + 1
                        wrk%Subject(wrk%lenSubject) = cdx
                    else ! add as section
                        call check_array_bound (wrk%lenSubject, MAX_SUBJECTS_PER_TERM, 'MAX_SUBJECTS_PER_TERM')
                        wrk%lenSubject = wrk%lenSubject + 1
                        wrk%Section(wrk%lenSubject) = sdx
                        wrk%Subject(wrk%lenSubject) = Section(sdx)%SubjectIdx
                    end if

                case ('Subject')
                    tSubject = adjustl(value)
                    cdx = index_to_subject(tSubject)
                    if (cdx<=0) then ! subject code not found
                        call log_comment ('No such subject; ignored - '//tSubject)
                        cycle
                    end if
                    ! add as allowed subject
                    call check_array_bound (wrk%lenSubject, MAX_SUBJECTS_PER_TERM, 'MAX_SUBJECTS_PER_TERM')
                    wrk%lenSubject = wrk%lenSubject + 1
                    wrk%Subject(wrk%lenSubject) = cdx

                case ('/WaiverCOI')
                    if (std/=0) then
                        WaiverCOI(std) = wrk
                        numEntries = numEntries+1
                    else
                        call log_comment ('No such student; ignored - '//tStdNo)
                    end if

                case default
                    if ( trim(tag)=='/'//XML_ROOT_WAIVERS//trim(txtSemester(iTerm)) ) exit


            end select

        end do

        close(unitXML)
        call log_comment (itoa(numEntries)//' Waiver/COI entries in '//fileName)

    end subroutine xml_read_waivers


    subroutine xml_write_waivers(path, Section, iTerm)
        character (len=*), intent (in) :: path ! YEAR/TERM/WAIVER-COI
        type (TYPE_SECTION), intent(in) :: Section(0:)
        integer, intent (in) :: iTerm

        ! generate file name
        fileName = trim(path)//'WAIVER-COI.XML'

        call move_to_backup(fileName)
        call html_comment('xml_write_waivers('//trim(fileName)//')')

        open(unit=unitXML, file=fileName)
        write(unitXML,AFORMAT) XML_DOC
        call xml_waivers(unitXML, Section, iTerm)
        close(unitXML)

    end subroutine xml_write_waivers


    subroutine xml_waivers(unitXML, Section, iTerm)
        integer, intent (in) :: unitXML, iTerm
        type (TYPE_SECTION), intent(in) :: Section(0:)

        integer :: std, sect, i

        write(unitXML,AFORMAT) '<'//XML_ROOT_WAIVERS//trim(txtSemester(iTerm))//'>', &
        '    <comment>', &
        '        Generated by '//PROGNAME//VERSION//' on '//currentDate(1:4)// &
                    FSLASH//currentDate(5:6)//FSLASH//currentDate(7:8), &
        '        StdNo    : Student number', &
        '        Section   : Enlisted section', &
        '        Subject    : Allowed subject (COI/waive prerequisite)', &
        '    </comment>'

        do std=1,NumStudents+NumAdditionalStudents
            if (WaiverCOI(std)%lenSubject==0) cycle ! skip student with no record
            call xml_write_character(unitXML, indent0, 'WaiverCOI')
            call xml_write_character(unitXML, indent1, 'StdNo', Student(std)%StdNo)
            do i=1,WaiverCOI(std)%lenSubject
                sect = WaiverCOI(std)%Section(i)
                if (sect>0) then
                    call xml_write_character(unitXML, indent1, 'Section', Section(sect)%ClassId)
                else
                    call xml_write_character(unitXML, indent1, 'Subject', Subject(WaiverCOI(std)%Subject(i))%Name)
                end if
            end do
            call xml_write_character(unitXML, indent0, '/WaiverCOI')
        end do

        ! close file
        write(unitXML,AFORMAT) '</'//XML_ROOT_WAIVERS//trim(txtSemester(iTerm))//'>'

    end subroutine xml_waivers



    subroutine xml_read_basic_data(path, backupFile)

        character (len=*), intent(in) :: path
        character (len=*), intent(in), optional :: backupFile

        integer :: jTmp, iTmp, errNo

        ! read the university-level data
        if ( present(backupFile) ) then
            fileName = trim(path)//backupFile
        else
            fileName = trim(path)//'UNIVERSITY.XML'
        end if
        call xml_read_university(fileName, errNo)
        if (errNo/=0) call terminate('Error in reading university info')

        ! read the colleges
        if ( present(backupFile) ) then
            fileName = trim(path)//backupFile
        else
            fileName = trim(path)//'COLLEGES.XML'
        end if
        call xml_read_colleges(fileName, errNo)
        if (errNo/=0) call terminate('Error in reading the list of colleges')

        ! log directory for users in the college
        do iTmp=1,NumColleges
            call make_directory( trim(dirLOG)//trim(College(iTmp)%Code)//DIRSEP )
        end do

        ! read the departments
        if ( present(backupFile) ) then
            fileName = trim(path)//backupFile
        else
            fileName = trim(path)//'DEPARTMENTS.XML'
        end if
        call xml_read_departments(fileName, errNo)
        if (errNo/=0) call terminate('Error in reading the list of departments')

        ! read the subjects
        if ( present(backupFile) ) then
            fileName = trim(path)//backupFile
        else
            fileName = trim(path)//'SUBJECTS.XML'
        end if
        call xml_read_subjects(fileName, errNo)
        if (errNo/=0) call terminate('Error in reading the list of subjects')

        ! subject areas
        call get_subject_areas()

        ! read the curricular programs
        if ( present(backupFile) ) then
            fileName = trim(path)//backupFile
        else
            fileName = trim(path)//'CURRICULA.XML'
        end if
        call xml_read_curricula(fileName, errNo)
        if (errNo/=0) call terminate('Error in reading the list of curricular programs')

        ! read the substitution rules
        if ( present(backupFile) ) then
            call xml_read_equivalencies(path, iTmp, backupFile)
        else
            call xml_read_equivalencies(path, iTmp)
        end if
        call log_comment('EQUIVALENCIES')
        do iTmp=1,NumSubst
            if (Substitution(SubstIdx(iTmp))>0 .and. Substitution(SubstIdx(iTmp))<=NumCurricula) then
                line = trim(Curriculum(Substitution(SubstIdx(iTmp)))%Code)//' : '
            elseif (Substitution(SubstIdx(iTmp))==-1) then
                line = 'All curricula : '
            end if
            do jTmp=SubstIdx(iTmp)+1, SubstIdx(iTmp+1)-1
                line = trim(line)//SPACE//trim(Subject(Substitution(jTmp))%Name)//SPACE
            end do
            call log_comment(itoa(iTmp)//line)
        end do

        ! Synchronize pre-requisites of co-requisite subjects
        ! For example, CHEM 17.0 has MATH 11 or MATH 17, CHEM 17.1 has NONE. Set
        ! pre-requisite of CHEM 17.1 to that of CHEM 17
        call log_comment('Synchronizing pre-requisites of co-requisite subjects...')
        do jTmp=1,NumSubjects
            if (Subject(Subject(jTmp)%Prerequisite(1))%Name/='NONE') cycle ! pre-requisite is NONE
            if (Subject(jTmp)%lenCoreq/=1) cycle ! should be one token only
            iTmp = Subject(jTmp)%Corequisite(1)
            if (iTmp<=0) cycle ! token should be a named subject
            call log_comment(Subject(jTmp)%Name//'has co-requisite '//Subject(iTmp)%Name)
            ! pre-requisite is NONE, co-requisite is a named subject
            Subject(jTmp)%lenPreq = Subject(iTmp)%lenPreq
            Subject(jTmp)%Prerequisite = Subject(iTmp)%Prerequisite
        end do

        ! read the rooms
        if ( present(backupFile) ) then
            fileName = trim(path)//backupFile
        else
            fileName = trim(path)//'ROOMS.XML'
        end if
        call xml_read_rooms(fileName, errNo)
        if (NumRooms==0) then
            do iTmp=2,NumDepartments-1 ! create rooms for each department
                NumRooms = NumRooms+1
                call initialize_room(Room(NumRooms), trim(Department(iTmp)%Code)//' Room', &
                    iTmp, 0, 0)
            end do
            errNo = 0
        end if

        ! read the teachers
        if ( present(backupFile) ) then
            fileName = trim(path)//backupFile
        else
            fileName = trim(path)//'TEACHERS.XML'
        end if
        call xml_read_teachers(fileName, errNo) ! try the XML file
        Teacher(1)%DeptIdx = NumDepartments ! Guest's unit is not previously set
        if (errNo/=0 .or. NumTeachers==1) then ! 1=Guest only

            do iTmp=2,NumDepartments-1 ! create teacher for each department
                NumTeachers = NumTeachers+1
                call check_array_bound (NumTeachers, MAX_ALL_TEACHERS, 'MAX_ALL_TEACHERS')
                Teacher(NumTeachers)%TeacherID = trim(Department(iTmp)%Code)//'-Teacher'
                Teacher(NumTeachers)%DeptIdx = iTmp
                Teacher(NumTeachers)%Role = GUEST
                Teacher(NumTeachers)%Name = trim(Department(iTmp)%Code)//' Teacher'
                Teacher(NumTeachers)%MaxLoad = 0
                Teacher(NumTeachers)%Specialization = 'Teaching'
                call set_password(Teacher(NumTeachers)%Password)

            end do
            errNo = 0

            ! the Developer account
            NumTeachers = NumTeachers+1
            call check_array_bound (NumTeachers, MAX_ALL_TEACHERS, 'MAX_ALL_TEACHERS')
            Teacher(NumTeachers)%TeacherID = PROGNAME
            Teacher(NumTeachers)%DeptIdx = NumDepartments
            Teacher(NumTeachers)%Role = SYSAD
            Teacher(NumTeachers)%Name = PROGNAME//' Developer'
            Teacher(NumTeachers)%MaxLoad = 0
            Teacher(NumTeachers)%Specialization = 'HEEDS Development'
            call set_password(Teacher(NumTeachers)%Password)

            ! the Administrator
            NumTeachers = NumTeachers+1
            call check_array_bound (NumTeachers, MAX_ALL_TEACHERS, 'MAX_ALL_TEACHERS')
            Teacher(NumTeachers)%TeacherID = SYSAD
            Teacher(NumTeachers)%DeptIdx = NumDepartments
            Teacher(NumTeachers)%Role = SYSAD
            Teacher(NumTeachers)%Name = PROGNAME//' Administrator'
            Teacher(NumTeachers)%MaxLoad = 0
            Teacher(NumTeachers)%Specialization = 'HEEDS Administration'
            call set_password(Teacher(NumTeachers)%Password)

        end if

        call sort_teachers()
        call sort_alphabetical_teachers()

        ! mark colleges with subject or curriculum information
        do jTmp=1,NumDepartments
            iTmp = Department(jTmp)%CollegeIdx
            College(iTmp)%hasInfo = College(iTmp)%hasInfo .or. Department(jTmp)%hasInfo
        end do

        ! read the students
        if ( present(backupFile) ) then
            call xml_read_students(path, 0, iTmp, errNo, 'BACKUP.XML')
        else
            call read_students(path, errNo)
        end if
        call sort_alphabetical_students()

    end subroutine xml_read_basic_data


    subroutine xml_write_data()

        integer :: i, tYear, tTerm

        ! year data
        dirPath = trim(dirDATA)//trim(itoa(currentYear))//DIRSEP
        call xml_write_university(trim(dirPath)//'UNIVERSITY.XML')
        call xml_write_colleges(trim(dirPath)//'COLLEGES.XML')
        call xml_write_departments(trim(dirPath)//'DEPARTMENTS.XML')
        call xml_write_rooms(trim(dirPath)//'ROOMS.XML')
        call xml_write_teachers(trim(dirPath)//'TEACHERS.XML')
        call xml_write_subjects(trim(dirPath)//'SUBJECTS.XML')
        call xml_write_curricula(trim(dirPath)//'CURRICULA.XML')
        call xml_write_equivalencies(trim(dirPath)//'EQUIVALENCIES.XML')
        call xml_write_students(trim(dirPath), 0)

        ! term-specific data
        do i=termBegin,termEnd
            call qualify_term (i, tYear, tTerm)
            dirPath = trim(dirDATA)//trim(itoa(tYear))//DIRSEP//trim(txtSemester(tTerm))//DIRSEP
            call xml_write_classes(dirPath, NumSections(tTerm), Section(tTerm,0:), 0)
            call xml_write_blocks(dirPath, NumBlocks(tTerm), Block(tTerm,0:), Section(tTerm,0:), 0)
            call xml_write_pre_enlistment(dirPath, 'ENLISTMENT', Enlistment(tTerm,0:), Section(tTerm,0:))
        end do

    end subroutine xml_write_data


end module XMLIO
